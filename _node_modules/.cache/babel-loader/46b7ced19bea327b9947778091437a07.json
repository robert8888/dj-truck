{"ast":null,"code":"import store from \"./../../../../../../store\";\nimport WaveSurfer from \"wavesurfer\";\nimport { hexToRgb } from \"./../../../../../../utils/colors/converter\";\nimport { getBeatLength } from \"./../../../../../../utils/bpm/converter\";\nexport default class Looper {\n  makeLoop(channel, loopLength) {\n    channel.loop = {}; // namespace for loop variables;\n\n    const state = store.getState();\n    const channelName = channel.channelName;\n    const beatLength = getBeatLength(state.console.channel[channelName].track.bpm);\n    const beatOffset = state.console.channel[channelName].playBackState.offset;\n    const currentPosition = channel.master.getCurrentTime();\n    const audioBufferSource = channel.master.backend.source;\n    channel.loop.audioBufferSource = audioBufferSource;\n    channel.loop.beatLength = beatLength; //starting from last whole beat starts\n\n    channel.loop.start = currentPosition - (currentPosition - beatOffset) % beatLength;\n\n    if (loopLength < 1) {\n      channel.loop.start = currentPosition + (beatLength * loopLength - (currentPosition - beatOffset) % (beatLength * loopLength));\n    }\n\n    channel.loop.end = channel.loop.start + beatLength * loopLength;\n\n    if (isNaN(channel.loop.start) || isNaN(channel.loop.end)) {\n      throw new Error(\"invalid value of range variables\");\n    }\n\n    audioBufferSource.loopStart = channel.loop.start;\n    audioBufferSource.loopEnd = channel.loop.end;\n    audioBufferSource.loop = true; //looping waveSurrfer and update end position if is set; \n\n    channel.loop.watch = time => {\n      if (time > channel.loop.end) {\n        channel.master.backend.startPosition = channel.loop.start + (time - channel.loop.end);\n        channel.master.backend.lastPlay = channel.master.backend.ac.currentTime;\n        channel.master.drawer.progress(channel.master.backend.getPlayedPercents());\n\n        if (channel.loop.nextEnd) {\n          this._updateLoopEnd(channel, channel.loop.nextEnd);\n\n          delete channel.loop.nextEnd;\n        }\n      }\n    };\n\n    channel.loop.reset = () => {\n      channel.loop.audioBufferSource = channel.master.backend.source;\n      channel.loop.audioBufferSource.loopStart = channel.loop.start;\n      channel.loop.audioBufferSource.loopEnd = channel.loop.end;\n      channel.loop.audioBufferSource.loop = true;\n    };\n\n    channel.master.on(\"audioprocess\", channel.loop.watch);\n    channel.master.on(\"interaction\", channel.loop.reset);\n    this.drawLoop(channel);\n  }\n\n  updateLoop(channel, loopLength) {\n    const {\n      start,\n      beatLength\n    } = channel.loop;\n    const newEnd = start + beatLength * loopLength;\n    const currentPosition = channel.master.getCurrentTime();\n\n    if (newEnd < currentPosition) {\n      channel.loop.nextEnd = newEnd;\n    } else {\n      this._updateLoopEnd(channel, newEnd);\n    }\n  }\n\n  _updateLoopEnd(channel, newEnd) {\n    channel.loop.end = newEnd;\n    channel.loop.audioBufferSource.loopEnd = newEnd;\n    this.clearDraw(channel);\n    this.drawLoop(channel);\n  }\n\n  endLoop(channel) {\n    channel.master.un(\"audioprocess\", channel.loop.watch);\n    channel.master.un(\"interaction\", channel.loop.reset);\n    channel.master.backend.source.loop = false;\n    this.clearDraw(channel);\n    delete channel.loop;\n  }\n\n  drawLoop(channel) {\n    let {\n      start,\n      end\n    } = channel.loop;\n    const wrapper = channel.master.drawer.wrapper;\n    const styleApply = WaveSurfer.Drawer.style;\n    const minPxPerSec = channel.master.params.minPxPerSec;\n    const color = hexToRgb(channel.master.params.waveColor);\n    const regionStyle = {\n      position: \"absolute\",\n      top: \"0px\",\n      height: \"100%\",\n      background: \"rgba(\" + color.r + \",\" + color.g + \",\" + color.b + \", 0.3)\"\n    };\n    const region = document.createElement(\"div\");\n    regionStyle.left = start * minPxPerSec + \"px\";\n    regionStyle.width = (end - start) * minPxPerSec + \"px\";\n    styleApply(region, regionStyle);\n    wrapper.appendChild(region);\n    channel.loop.region = region;\n  }\n\n  clearDraw(channel) {\n    channel.loop.region.remove();\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/src/pages/app/core/console/channels/looper/looper.js"],"names":["store","WaveSurfer","hexToRgb","getBeatLength","Looper","makeLoop","channel","loopLength","loop","state","getState","channelName","beatLength","console","track","bpm","beatOffset","playBackState","offset","currentPosition","master","getCurrentTime","audioBufferSource","backend","source","start","end","isNaN","Error","loopStart","loopEnd","watch","time","startPosition","lastPlay","ac","currentTime","drawer","progress","getPlayedPercents","nextEnd","_updateLoopEnd","reset","on","drawLoop","updateLoop","newEnd","clearDraw","endLoop","un","wrapper","styleApply","Drawer","style","minPxPerSec","params","color","waveColor","regionStyle","position","top","height","background","r","g","b","region","document","createElement","left","width","appendChild","remove"],"mappings":"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","sourcesContent":["import store from \"./../../../../../../store\";\r\nimport WaveSurfer from \"wavesurfer\";\r\nimport { hexToRgb } from \"./../../../../../../utils/colors/converter\";\r\nimport { getBeatLength } from \"./../../../../../../utils/bpm/converter\";\r\n\r\nexport default class Looper {\r\n    makeLoop(channel, loopLength) {\r\n        channel.loop = {}// namespace for loop variables;\r\n        const state = store.getState();\r\n        const channelName = channel.channelName;\r\n\r\n        const beatLength = getBeatLength(state.console.channel[channelName].track.bpm);\r\n        const beatOffset = state.console.channel[channelName].playBackState.offset;\r\n        const currentPosition = channel.master.getCurrentTime();\r\n        const audioBufferSource = channel.master.backend.source;\r\n        channel.loop.audioBufferSource = audioBufferSource;\r\n        channel.loop.beatLength = beatLength;\r\n\r\n        //starting from last whole beat starts\r\n        channel.loop.start = currentPosition - ((currentPosition - beatOffset) % beatLength);\r\n\r\n        if (loopLength < 1) {\r\n            channel.loop.start = currentPosition\r\n                + ((beatLength * loopLength) - (currentPosition - beatOffset) % (beatLength * loopLength));\r\n        }\r\n        channel.loop.end = channel.loop.start + beatLength * loopLength;\r\n\r\n        if (isNaN(channel.loop.start) || isNaN(channel.loop.end)) {\r\n            throw new Error(\"invalid value of range variables\")\r\n        }\r\n        audioBufferSource.loopStart = channel.loop.start;\r\n        audioBufferSource.loopEnd = channel.loop.end;\r\n        audioBufferSource.loop = true;\r\n\r\n        //looping waveSurrfer and update end position if is set; \r\n        channel.loop.watch = (time) => {\r\n            if (time > channel.loop.end) {\r\n                channel.master.backend.startPosition = channel.loop.start + (time - channel.loop.end);\r\n                channel.master.backend.lastPlay = channel.master.backend.ac.currentTime;\r\n                channel.master.drawer.progress(channel.master.backend.getPlayedPercents());\r\n                if (channel.loop.nextEnd) {\r\n                    this._updateLoopEnd(channel, channel.loop.nextEnd);\r\n                    delete channel.loop.nextEnd;\r\n                }\r\n            }\r\n        }\r\n\r\n        channel.loop.reset = () => {\r\n            channel.loop.audioBufferSource = channel.master.backend.source;\r\n            channel.loop.audioBufferSource.loopStart = channel.loop.start;\r\n            channel.loop.audioBufferSource.loopEnd = channel.loop.end;\r\n            channel.loop.audioBufferSource.loop = true;\r\n        }\r\n\r\n        channel.master.on(\"audioprocess\", channel.loop.watch);\r\n        channel.master.on(\"interaction\", channel.loop.reset)\r\n        this.drawLoop(channel);\r\n    }\r\n\r\n    updateLoop(channel, loopLength) {\r\n        const { start, beatLength } = channel.loop;\r\n        const newEnd = start + beatLength * loopLength;\r\n        const currentPosition = channel.master.getCurrentTime();\r\n        if (newEnd < currentPosition) {\r\n            channel.loop.nextEnd = newEnd;\r\n        } else {\r\n            this._updateLoopEnd(channel, newEnd)\r\n        }\r\n    }\r\n\r\n    _updateLoopEnd(channel, newEnd) {\r\n        channel.loop.end = newEnd;\r\n        channel.loop.audioBufferSource.loopEnd = newEnd;\r\n        this.clearDraw(channel);\r\n        this.drawLoop(channel);\r\n    }\r\n\r\n    endLoop(channel) {\r\n        channel.master.un(\"audioprocess\", channel.loop.watch);\r\n        channel.master.un(\"interaction\", channel.loop.reset);\r\n        channel.master.backend.source.loop = false;\r\n        this.clearDraw(channel);\r\n        delete channel.loop;\r\n    }\r\n\r\n    drawLoop(channel) {\r\n        let { start, end } = channel.loop;\r\n        const wrapper = channel.master.drawer.wrapper;\r\n        const styleApply = WaveSurfer.Drawer.style;\r\n        const minPxPerSec = channel.master.params.minPxPerSec;\r\n        const color = hexToRgb(channel.master.params.waveColor);\r\n\r\n        const regionStyle = {\r\n            position: \"absolute\",\r\n            top: \"0px\",\r\n            height: \"100%\",\r\n            background: \"rgba(\" + color.r + \",\" + color.g + \",\" + color.b + \", 0.3)\"\r\n        };\r\n\r\n        const region = document.createElement(\"div\");\r\n        regionStyle.left = start * minPxPerSec + \"px\";\r\n        regionStyle.width = (end - start) * minPxPerSec + \"px\";\r\n\r\n        styleApply(region, regionStyle);\r\n        wrapper.appendChild(region);\r\n        channel.loop.region = region;\r\n    }\r\n\r\n    clearDraw(channel) {\r\n        channel.loop.region.remove();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}