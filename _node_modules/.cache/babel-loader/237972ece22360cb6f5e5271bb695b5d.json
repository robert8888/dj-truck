{"ast":null,"code":"//const map = require('unist-util-map');\nconst vFile = require('vfile');\n\nmodule.exports = attacher;\n\nconst newFileFrom = (vfile, contents) => {\n  return vFile({ ...vfile,\n    contents: contents\n  });\n};\n\nfunction attacher() {\n  // console.log(\"the this\", this.Parser);\n  const pattern = /{\\.(\\w+)}/;\n  const processor = this;\n\n  function transformer(tree, file) {\n    let inlineMethods = processor.Parser.prototype.inlineMethods;\n    let blockMethods = processor.Parser.prototype.blockMethods;\n    console.log(\"before modification\", tree);\n\n    const modify = node => {\n      console.log(\"in modify\", node);\n      if (!node.children) return node;\n      node.children = node.children.map(node => {\n        //\n        if (node.type === \"text\") {\n          var _processor$parse;\n\n          let match = pattern.exec(node.value);\n          if (!match) return node;\n          const value = node.value.replace(match[0], \"\");\n          const subNodes = (_processor$parse = processor.parse(newFileFrom(file, value))) === null || _processor$parse === void 0 ? void 0 : _processor$parse.children; // if(subNodes.some( subNode => blockMethods.includes(subNode.type)\n          //     && [\"paragraph\", \"heading\"].includes(parent.type))){\n          //     console.log(\"yeas it is\", subNodes[0]);\n          //     parent = subNodes[0];\n          //     parent.className = match[1];\n          //     return;\n          // }\n\n          let newNode = subNodes[0];\n          newNode.className = match[1];\n          return newNode;\n        } //\n\n\n        if (!node.children) return node;\n        let parent = node;\n        const children = node.children.map(node => {\n          console.log(\"visted\", node, parent);\n\n          if (node.children) {\n            node = modify(node);\n          }\n\n          if (node.type === \"text\") {\n            var _processor$parse2;\n\n            let match = pattern.exec(node.value);\n            if (!match) return node;\n            const value = node.value.replace(match[0], \"\");\n            const subNodes = (_processor$parse2 = processor.parse(newFileFrom(file, value))) === null || _processor$parse2 === void 0 ? void 0 : _processor$parse2.children;\n\n            if (subNodes.some(subNode => blockMethods.includes(subNode.type) && [\"paragraph\", \"heading\"].includes(parent.type))) {\n              console.log(\"yeas it is\", subNodes[0]);\n              parent = subNodes[0];\n              parent.className = match[1];\n              return;\n            }\n\n            let newNode = subNodes[0];\n            newNode.className = match[1];\n            return newNode;\n            console.log(\"subnodes\", subNodes);\n          }\n\n          return node;\n        }).filter(node => !!node);\n\n        if (children.length) {\n          parent.children = children;\n        }\n\n        return parent; // let match = pattern.exec(node.value);\n        // if(!match) return node;\n        // const value = node.value.replace(match[0], \"\");\n        // const subNodes = processor.parse(newFileFrom(file, value))?.children;\n        // console.log(\"sub nodes\" , subNodes);\n        // return node;\n      });\n      return node;\n    }; // if(node.type !== \"text\") return modify(node);\n    // console.log(\"node in\", node)\n    // let match = pattern.exec(node.value);\n    // if(!match) return node;\n    // const value = node.value.replace(match[0], \"\");\n    // const subNodes = processor.parse(newFileFrom(file, value))?.children;\n    // // console.log(\"parnet subnodes\", parent, subNodes)\n    // if(subNodes.some( subNode => subNode.type === \"thematicBreak\")\n    //     && parent.type === \"paragraph\"){\n    //     parent = subNodes.find( subNode => subNode.type === \"thematicBreak\");\n    //     parent.className = match[1];\n    //     parent.position = node.position;\n    //     parent.position.end.column-=match[0].length;\n    //     parent.position.end.offset-=match[0].length;\n    //\n    // }\n\n\n    const next = modify(tree);\n    console.log(\"after modyfication\", next);\n    return next;\n  }\n\n  return transformer;\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/introduction/MarkDonwExtesnion/reamark-hclass.js"],"names":["vFile","require","module","exports","attacher","newFileFrom","vfile","contents","pattern","processor","transformer","tree","file","inlineMethods","Parser","prototype","blockMethods","console","log","modify","node","children","map","type","match","exec","value","replace","subNodes","parse","newNode","className","parent","some","subNode","includes","filter","length","next"],"mappings":"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","sourcesContent":["//const map = require('unist-util-map');\r\nconst vFile = require('vfile');\r\n\r\n\r\nmodule.exports = attacher\r\n\r\nconst newFileFrom = (vfile, contents) => {\r\n    return vFile({...vfile, contents: contents})\r\n}\r\n\r\nfunction attacher() {\r\n   // console.log(\"the this\", this.Parser);\r\n    const pattern = /{\\.(\\w+)}/;\r\n    const processor = this;\r\n    function transformer(tree, file) {\r\n        let inlineMethods =processor.Parser.prototype.inlineMethods;\r\n        let blockMethods = processor.Parser.prototype.blockMethods;\r\n\r\n        console.log(\"before modification\", tree)\r\n\r\n        const modify = node => {\r\n            console.log(\"in modify\", node)\r\n            if(!node.children) return node;\r\n            node.children = node.children.map( node => {\r\n                //\r\n                if(node.type === \"text\"){\r\n                    let match = pattern.exec(node.value);\r\n                    if(!match) return node;\r\n                    const value = node.value.replace(match[0], \"\");\r\n                    const subNodes = processor.parse(newFileFrom(file, value))?.children;\r\n                    // if(subNodes.some( subNode => blockMethods.includes(subNode.type)\r\n                    //     && [\"paragraph\", \"heading\"].includes(parent.type))){\r\n                    //     console.log(\"yeas it is\", subNodes[0]);\r\n                    //     parent = subNodes[0];\r\n                    //     parent.className = match[1];\r\n                    //     return;\r\n                    // }\r\n                    let newNode = subNodes[0];\r\n                    newNode.className = match[1];\r\n                    return newNode;\r\n                }\r\n\r\n                //\r\n                if(!node.children) return node;\r\n                let parent = node;\r\n                const children = node.children.map( node => {\r\n                    console.log(\"visted\", node, parent)\r\n                   if(node.children){\r\n                       node = modify(node);\r\n                   }\r\n                   if(node.type === \"text\"){\r\n                       let match = pattern.exec(node.value);\r\n                       if(!match) return node;\r\n                       const value = node.value.replace(match[0], \"\");\r\n                       const subNodes = processor.parse(newFileFrom(file, value))?.children;\r\n                       if(subNodes.some( subNode => blockMethods.includes(subNode.type)\r\n                           && [\"paragraph\", \"heading\"].includes(parent.type))){\r\n                            console.log(\"yeas it is\", subNodes[0]);\r\n                            parent = subNodes[0];\r\n                            parent.className = match[1];\r\n                            return;\r\n                       }\r\n                       let newNode = subNodes[0];\r\n                       newNode.className = match[1];\r\n                       return newNode;\r\n                       console.log(\"subnodes\", subNodes)\r\n                   }\r\n                   return node;\r\n                }).filter( node => !!node);\r\n                if(children.length){\r\n                    parent.children = children;\r\n                }\r\n                return parent;\r\n                // let match = pattern.exec(node.value);\r\n                // if(!match) return node;\r\n                // const value = node.value.replace(match[0], \"\");\r\n                // const subNodes = processor.parse(newFileFrom(file, value))?.children;\r\n                // console.log(\"sub nodes\" , subNodes);\r\n                // return node;\r\n\r\n            })\r\n            return node;\r\n        }\r\n\r\n        // if(node.type !== \"text\") return modify(node);\r\n        // console.log(\"node in\", node)\r\n        // let match = pattern.exec(node.value);\r\n        // if(!match) return node;\r\n        // const value = node.value.replace(match[0], \"\");\r\n        // const subNodes = processor.parse(newFileFrom(file, value))?.children;\r\n        // // console.log(\"parnet subnodes\", parent, subNodes)\r\n        // if(subNodes.some( subNode => subNode.type === \"thematicBreak\")\r\n        //     && parent.type === \"paragraph\"){\r\n        //     parent = subNodes.find( subNode => subNode.type === \"thematicBreak\");\r\n        //     parent.className = match[1];\r\n        //     parent.position = node.position;\r\n        //     parent.position.end.column-=match[0].length;\r\n        //     parent.position.end.offset-=match[0].length;\r\n        //\r\n        // }\r\n        const next =  modify(tree);\r\n        console.log(\"after modyfication\", next);\r\n        return next;\r\n    }\r\n\r\n    return transformer\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}