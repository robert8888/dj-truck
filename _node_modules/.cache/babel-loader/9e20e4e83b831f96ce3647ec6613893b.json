{"ast":null,"code":"import store from \"./../../store\";\nimport Observer from \"./observer/observer\";\nimport STATUS from \"./observer/STATUS\";\nimport { togglePlay, setTimeLeft, setCuePoint } from \"./../../actions/actions\";\nimport Player from \"../../components/Deck/Player/Player\";\nlet mixConsole;\nexport default class Console {\n  constructor() {\n    store.subscribe(this.handleChange.bind(this));\n    this.dispatch = store.dispatch;\n    this.observer = new Observer(store);\n    this.channels = {\n      A: null,\n      B: null\n    };\n  }\n\n  static Init() {\n    mixConsole = new Console();\n  }\n\n  static Get() {\n    if (!mixConsole) {\n      mixConsole = new Console();\n      return mixConsole;\n    } else {\n      return mixConsole;\n    }\n  }\n\n  setPlayer(channel, player) {\n    this.channels[channel] = player;\n    this.attachActions(channel);\n  }\n\n  attachActions(channel) {\n    const player = this.channels[channel];\n    player.on('finish', () => {\n      this.dispatch(togglePlay(channel));\n    });\n    let lastUpdate = new Date().getTime();\n    player.on('audioprocess', () => {\n      const currentTime = new Date().getTime();\n\n      if (currentTime - lastUpdate >= 999) {\n        lastUpdate = currentTime;\n        this.dispatch(setTimeLeft(channel, parseInt(player.getDuration() - player.getCurrentTime())));\n      }\n    }); // updating time Left value\n    ///Because on seek event is called a 1000 time per second, is created watcher witch update \n    // value after 500 ms with last progress value \n\n    let lastCall = {\n      time: new Date().getTime(),\n      value: null\n    };\n    let watcher = null;\n    player.on('seek', progress => {\n      lastCall.time = new Date().getTime();\n      lastCall.value = progress;\n\n      if (!watcher) {\n        watcher = setInterval(() => {\n          if (new Date().getTime() - lastCall.time >= 100) {\n            this.dispatch(setTimeLeft(channel, parseInt(player.getDuration() * lastCall.value)));\n            clearInterval(watcher);\n            watcher = null;\n          }\n        }, 500);\n      }\n    });\n  }\n\n  handleChange() {\n    const storeChanges = this.observer.check();\n\n    for (let diff of storeChanges) {\n      this.callAction(diff);\n    }\n  }\n\n  callAction(diff) {\n    switch (diff.status) {\n      case STATUS.TOGGLE_PLAY:\n        {\n          this.togglePlay(diff.channel, diff.currentValue);\n          break;\n        }\n\n      case STATUS.TOGGLE_CUE:\n        {\n          this.toggleCue(diff.channel, diff.currentValue);\n          break;\n        }\n\n      default:\n        return;\n      //by default don't call any action \n    }\n  }\n\n  togglePlay(channelName, currentValue) {\n    if (currentValue) //paused true\n      {\n        this.channels[channelName].pause();\n      } else {\n      this.channels[channelName].play();\n    }\n  }\n\n  toggleCue(channelName, currentValue) {\n    const player = this.channels[channelName];\n    const isPaused = store.getState().console.channel[channelName].playBackState.paused;\n\n    if (!currentValue && isPaused) {\n      // back to cue point and pause\n      let cuePoint = store.getState().console.channel[channelName].playBackState.cuePoint; //in seconds\n      //seek to\n\n      player.pause();\n      player.backend.seekTo(cuePoint);\n      player.drawer.progress(cuePoint / player.getDuration());\n      player.drawer.recenter(cuePoint / player.getDuration());\n    } else if (!currentValue) {\n      //Cancel cue and play\n      if (!player.isPlaying()) {\n        player.play();\n      }\n    } else {\n      const cuePoint = this.channels[channelName].getCurrentTime();\n      this.channels[channelName].play();\n      this.dispatch(setCuePoint(channelName, cuePoint)); // in float seconds\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/src/core/console/console.js"],"names":["store","Observer","STATUS","togglePlay","setTimeLeft","setCuePoint","Player","mixConsole","Console","constructor","subscribe","handleChange","bind","dispatch","observer","channels","A","B","Init","Get","setPlayer","channel","player","attachActions","on","lastUpdate","Date","getTime","currentTime","parseInt","getDuration","getCurrentTime","lastCall","time","value","watcher","progress","setInterval","clearInterval","storeChanges","check","diff","callAction","status","TOGGLE_PLAY","currentValue","TOGGLE_CUE","toggleCue","channelName","pause","play","isPaused","getState","console","playBackState","paused","cuePoint","backend","seekTo","drawer","recenter","isPlaying"],"mappings":"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","sourcesContent":["import store from \"./../../store\";\r\nimport Observer from \"./observer/observer\";\r\nimport STATUS from \"./observer/STATUS\";\r\nimport { togglePlay,\r\n         setTimeLeft,\r\n         setCuePoint, }\r\n         from \"./../../actions/actions\";\r\nimport Player from \"../../components/Deck/Player/Player\";\r\n\r\nlet mixConsole;\r\nexport default class Console{\r\n    constructor(){\r\n        store.subscribe(this.handleChange.bind(this));\r\n        this.dispatch = store.dispatch;\r\n        this.observer = new Observer(store);\r\n        this.channels = {\r\n            A: null, \r\n            B: null\r\n        }\r\n    }\r\n\r\n    static Init(){\r\n        mixConsole = new Console();\r\n    }\r\n\r\n    static Get(){\r\n        if(!mixConsole){\r\n            mixConsole = new Console();\r\n            return mixConsole;\r\n        } else {\r\n            return mixConsole;\r\n        }\r\n    }\r\n\r\n    setPlayer(channel, player){\r\n        this.channels[channel] = player;\r\n        this.attachActions(channel);\r\n    }\r\n\r\n    attachActions(channel){\r\n        const player = this.channels[channel];\r\n        player.on('finish', ()=>{\r\n            this.dispatch(togglePlay(channel))\r\n        })\r\n\r\n        let lastUpdate = (new Date()).getTime();\r\n        player.on('audioprocess', ()=>{\r\n            const currentTime = (new Date()).getTime();\r\n            if((currentTime - lastUpdate) >= 999){\r\n                lastUpdate = currentTime;\r\n                this.dispatch(setTimeLeft(channel, parseInt(player.getDuration() - player.getCurrentTime())))\r\n            }\r\n        })\r\n        // updating time Left value\r\n        ///Because on seek event is called a 1000 time per second, is created watcher witch update \r\n        // value after 500 ms with last progress value \r\n        let lastCall = {\r\n            time :(new Date()).getTime(),\r\n            value : null\r\n        };\r\n        let watcher = null;\r\n        player.on('seek', progress => {\r\n            lastCall.time = (new Date()).getTime();\r\n            lastCall.value = progress;\r\n            if(!watcher){\r\n                watcher = setInterval(()=>{\r\n                        if(((new Date()).getTime() - lastCall.time) >= 100)\r\n                        {\r\n                            this.dispatch(setTimeLeft(channel, parseInt(player.getDuration() * lastCall.value)))\r\n                            clearInterval(watcher);\r\n                            watcher = null\r\n                        }\r\n                    }, 500)\r\n            }\r\n        })\r\n    }\r\n\r\n    handleChange(){\r\n        const storeChanges = this.observer.check();\r\n        for(let diff of storeChanges){\r\n            this.callAction(diff);\r\n        }\r\n    }\r\n\r\n    callAction(diff){\r\n        switch(diff.status){\r\n            case STATUS.TOGGLE_PLAY : {\r\n                this.togglePlay(diff.channel, diff.currentValue);\r\n                break;\r\n            }\r\n            case STATUS.TOGGLE_CUE : {\r\n                this.toggleCue(diff.channel, diff.currentValue)\r\n                break;\r\n            }\r\n\r\n            default : return; //by default don't call any action \r\n        }\r\n    }\r\n\r\n    togglePlay(channelName, currentValue){\r\n        if(currentValue)//paused true\r\n        {\r\n            this.channels[channelName].pause();\r\n        } else {\r\n            this.channels[channelName].play();\r\n        }\r\n    }\r\n\r\n    toggleCue(channelName, currentValue){\r\n        const player = this.channels[channelName]\r\n        const isPaused = store.getState().console.channel[channelName].playBackState.paused;\r\n        if(!currentValue && isPaused){ // back to cue point and pause\r\n            let cuePoint =  store.getState().console.channel[channelName].playBackState.cuePoint; //in seconds\r\n            //seek to\r\n            player.pause();\r\n            player.backend.seekTo(cuePoint);\r\n            player.drawer.progress(cuePoint / player.getDuration());\r\n            player.drawer.recenter(cuePoint / player.getDuration());\r\n        } else if(!currentValue) { //Cancel cue and play\r\n            if(!player.isPlaying()){\r\n                player.play();\r\n            }\r\n        }\r\n        else {\r\n            const cuePoint = this.channels[channelName].getCurrentTime();\r\n            this.channels[channelName].play();\r\n            this.dispatch(setCuePoint(channelName, cuePoint)) // in float seconds\r\n        }\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}