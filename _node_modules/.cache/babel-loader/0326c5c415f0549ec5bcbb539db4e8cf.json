{"ast":null,"code":"'use strict';\n\nvar entities = require('character-entities-html4');\n\nvar legacy = require('character-entities-legacy');\n\nvar hexadecimal = require('is-hexadecimal');\n\nvar decimal = require('is-decimal');\n\nvar alphanumerical = require('is-alphanumerical');\n\nvar dangerous = require('./dangerous.json');\n\nmodule.exports = encode;\nencode.escape = escape;\nvar own = {}.hasOwnProperty; // Characters\n\nvar equalsTo = 61; // List of enforced escapes.\n\nvar escapes = ['\"', \"'\", '<', '>', '&', '`']; // Map of characters to names.\n\nvar characters = construct(); // Default escapes.\n\nvar defaultEscapes = toExpression(escapes); // Surrogate pairs.\n\nvar surrogatePair = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g; // Non-ASCII characters.\n// eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\n\nvar bmp = /[\\x01-\\t\\x0B\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g; // Encode special characters in `value`.\n\nfunction encode(value, options) {\n  var settings = options || {};\n  var subset = settings.subset;\n  var set = subset ? toExpression(subset) : defaultEscapes;\n  var escapeOnly = settings.escapeOnly;\n  var omit = settings.omitOptionalSemicolons;\n  value = value.replace(set, replace);\n\n  if (subset || escapeOnly) {\n    return value;\n  }\n\n  return value.replace(surrogatePair, replaceSurrogatePair).replace(bmp, replace);\n\n  function replaceSurrogatePair(pair, pos, slice) {\n    return toHexReference((pair.charCodeAt(0) - 0xd800) * 0x400 + pair.charCodeAt(1) - 0xdc00 + 0x10000, slice.charCodeAt(pos + 2), omit);\n  }\n\n  function replace(char, pos, slice) {\n    return one(char, slice.charCodeAt(pos + 1), settings);\n  }\n} // Shortcut to escape special characters in HTML.\n\n\nfunction escape(value) {\n  return encode(value, {\n    escapeOnly: true,\n    useNamedReferences: true\n  });\n} // Encode `char` according to `options`.\n\n\nfunction one(char, next, options) {\n  var shortest = options.useShortestReferences;\n  var omit = options.omitOptionalSemicolons;\n  var named;\n  var code;\n  var numeric;\n  var decimal;\n\n  if ((shortest || options.useNamedReferences) && own.call(characters, char)) {\n    named = toNamed(characters[char], next, omit, options.attribute);\n  }\n\n  if (shortest || !named) {\n    code = char.charCodeAt(0);\n    numeric = toHexReference(code, next, omit); // Use the shortest numeric reference when requested.\n    // A simple algorithm would use decimal for all code points under 100, as\n    // those are shorter than hexadecimal:\n    //\n    // * `&#99;` vs `&#x63;` (decimal shorter)\n    // * `&#100;` vs `&#x64;` (equal)\n    //\n    // However, because we take `next` into consideration when `omit` is used,\n    // And it would be possible that decimals are shorter on bigger values as\n    // well if `next` is hexadecimal but not decimal, we instead compare both.\n\n    if (shortest) {\n      decimal = toDecimalReference(code, next, omit);\n\n      if (decimal.length < numeric.length) {\n        numeric = decimal;\n      }\n    }\n  }\n\n  if (named && (!shortest || named.length < numeric.length)) {\n    return named;\n  }\n\n  return numeric;\n} // Transform `code` into an entity.\n\n\nfunction toNamed(name, next, omit, attribute) {\n  var value = '&' + name;\n\n  if (omit && own.call(legacy, name) && dangerous.indexOf(name) === -1 && (!attribute || next && next !== equalsTo && !alphanumerical(next))) {\n    return value;\n  }\n\n  return value + ';';\n} // Transform `code` into a hexadecimal character reference.\n\n\nfunction toHexReference(code, next, omit) {\n  var value = '&#x' + code.toString(16).toUpperCase();\n  return omit && next && !hexadecimal(next) ? value : value + ';';\n} // Transform `code` into a decimal character reference.\n\n\nfunction toDecimalReference(code, next, omit) {\n  var value = '&#' + String(code);\n  return omit && next && !decimal(next) ? value : value + ';';\n} // Create an expression for `characters`.\n\n\nfunction toExpression(characters) {\n  return new RegExp('[' + characters.join('') + ']', 'g');\n} // Construct the map.\n\n\nfunction construct() {\n  var chars = {};\n  var name;\n\n  for (name in entities) {\n    chars[entities[name]] = name;\n  }\n\n  return chars;\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/node_modules/stringify-entities/index.js"],"names":["entities","require","legacy","hexadecimal","decimal","alphanumerical","dangerous","module","exports","encode","escape","own","hasOwnProperty","equalsTo","escapes","characters","construct","defaultEscapes","toExpression","surrogatePair","bmp","value","options","settings","subset","set","escapeOnly","omit","omitOptionalSemicolons","replace","replaceSurrogatePair","pair","pos","slice","toHexReference","charCodeAt","char","one","useNamedReferences","next","shortest","useShortestReferences","named","code","numeric","call","toNamed","attribute","toDecimalReference","length","name","indexOf","toString","toUpperCase","String","RegExp","join","chars"],"mappings":"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","sourcesContent":["'use strict'\n\nvar entities = require('character-entities-html4')\nvar legacy = require('character-entities-legacy')\nvar hexadecimal = require('is-hexadecimal')\nvar decimal = require('is-decimal')\nvar alphanumerical = require('is-alphanumerical')\nvar dangerous = require('./dangerous.json')\n\nmodule.exports = encode\nencode.escape = escape\n\nvar own = {}.hasOwnProperty\n\n// Characters\nvar equalsTo = 61\n\n// List of enforced escapes.\nvar escapes = ['\"', \"'\", '<', '>', '&', '`']\n\n// Map of characters to names.\nvar characters = construct()\n\n// Default escapes.\nvar defaultEscapes = toExpression(escapes)\n\n// Surrogate pairs.\nvar surrogatePair = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g\n\n// Non-ASCII characters.\n// eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\nvar bmp = /[\\x01-\\t\\x0B\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g\n\n// Encode special characters in `value`.\nfunction encode(value, options) {\n  var settings = options || {}\n  var subset = settings.subset\n  var set = subset ? toExpression(subset) : defaultEscapes\n  var escapeOnly = settings.escapeOnly\n  var omit = settings.omitOptionalSemicolons\n\n  value = value.replace(set, replace)\n\n  if (subset || escapeOnly) {\n    return value\n  }\n\n  return value\n    .replace(surrogatePair, replaceSurrogatePair)\n    .replace(bmp, replace)\n\n  function replaceSurrogatePair(pair, pos, slice) {\n    return toHexReference(\n      (pair.charCodeAt(0) - 0xd800) * 0x400 +\n        pair.charCodeAt(1) -\n        0xdc00 +\n        0x10000,\n      slice.charCodeAt(pos + 2),\n      omit\n    )\n  }\n\n  function replace(char, pos, slice) {\n    return one(char, slice.charCodeAt(pos + 1), settings)\n  }\n}\n\n// Shortcut to escape special characters in HTML.\nfunction escape(value) {\n  return encode(value, {escapeOnly: true, useNamedReferences: true})\n}\n\n// Encode `char` according to `options`.\nfunction one(char, next, options) {\n  var shortest = options.useShortestReferences\n  var omit = options.omitOptionalSemicolons\n  var named\n  var code\n  var numeric\n  var decimal\n\n  if ((shortest || options.useNamedReferences) && own.call(characters, char)) {\n    named = toNamed(characters[char], next, omit, options.attribute)\n  }\n\n  if (shortest || !named) {\n    code = char.charCodeAt(0)\n    numeric = toHexReference(code, next, omit)\n\n    // Use the shortest numeric reference when requested.\n    // A simple algorithm would use decimal for all code points under 100, as\n    // those are shorter than hexadecimal:\n    //\n    // * `&#99;` vs `&#x63;` (decimal shorter)\n    // * `&#100;` vs `&#x64;` (equal)\n    //\n    // However, because we take `next` into consideration when `omit` is used,\n    // And it would be possible that decimals are shorter on bigger values as\n    // well if `next` is hexadecimal but not decimal, we instead compare both.\n    if (shortest) {\n      decimal = toDecimalReference(code, next, omit)\n\n      if (decimal.length < numeric.length) {\n        numeric = decimal\n      }\n    }\n  }\n\n  if (named && (!shortest || named.length < numeric.length)) {\n    return named\n  }\n\n  return numeric\n}\n\n// Transform `code` into an entity.\nfunction toNamed(name, next, omit, attribute) {\n  var value = '&' + name\n\n  if (\n    omit &&\n    own.call(legacy, name) &&\n    dangerous.indexOf(name) === -1 &&\n    (!attribute || (next && next !== equalsTo && !alphanumerical(next)))\n  ) {\n    return value\n  }\n\n  return value + ';'\n}\n\n// Transform `code` into a hexadecimal character reference.\nfunction toHexReference(code, next, omit) {\n  var value = '&#x' + code.toString(16).toUpperCase()\n  return omit && next && !hexadecimal(next) ? value : value + ';'\n}\n\n// Transform `code` into a decimal character reference.\nfunction toDecimalReference(code, next, omit) {\n  var value = '&#' + String(code)\n  return omit && next && !decimal(next) ? value : value + ';'\n}\n\n// Create an expression for `characters`.\nfunction toExpression(characters) {\n  return new RegExp('[' + characters.join('') + ']', 'g')\n}\n\n// Construct the map.\nfunction construct() {\n  var chars = {}\n  var name\n\n  for (name in entities) {\n    chars[entities[name]] = name\n  }\n\n  return chars\n}\n"]},"metadata":{},"sourceType":"script"}