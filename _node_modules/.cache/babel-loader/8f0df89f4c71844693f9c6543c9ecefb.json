{"ast":null,"code":"import store from \"./../../../../../store\";\nexport default class Mixer {\n  constructor(channels) {\n    this.config = store.getState().configuration.mixer;\n    this.channels = channels;\n    this.initChannelContainer('audioNodes');\n    this.initChannelContainer('sampleBuffers');\n    this.createMainChannel();\n  }\n\n  connect(external) {\n    this.external = external;\n  }\n\n  initChannelContainer(containerName) {\n    this[containerName] = {\n      channels: {}\n    };\n\n    for (let channelName of [...this.channels.getChannelNames(), \"main\"]) {\n      this[containerName].channels = { ...this[containerName].channels,\n        [channelName]: null\n      };\n    }\n  }\n\n  createMainChannel() {\n    //main audio context with is share between wavesurfer objects\n    this.mainAudioContext = new AudioContext();\n    let ac = this.mainAudioContext;\n    let main = this.audioNodes.channels['main'];\n    main = {};\n    main.gainNode = ac.createGain();\n    main.analyserNode = ac.createAnalyser();\n    main.gainNode.connect(main.analyserNode);\n    main.analyserNode.connect(ac.destination);\n  }\n\n  getChannelInterface(channelName) {\n    return {\n      getPeakMeter: () => this.getPeakMeter(channelName)\n    };\n  }\n\n  setUpChannelsAudioNodes(channelName) {\n    //surfer - waveSurfer obj\n    let surfer = this.channels.getChannel(channelName);\n    let audioCtx = surfer.backend.ac; //chained from up to down \n\n    this.audioNodes.channels[channelName] = {\n      eqHiFilterNode: audioCtx.createBiquadFilter(),\n      eqMidFilterNode: audioCtx.createBiquadFilter(),\n      eqLowFilterNode: audioCtx.createBiquadFilter(),\n      //low pass to do\n      //hi pass to do\n      sendNode: audioCtx.createGain(),\n      sendAndReturns: Array(this.config.externalChannels).fill(1).map(() => ({\n        send: audioCtx.createGain(),\n        return: null\n      })),\n      //\n      bypassNode: audioCtx.createGain(),\n      mainGainNode: audioCtx.createGain(),\n      analyserNode: audioCtx.createAnalyser(),\n      faderVolumeNode: audioCtx.createGain()\n    }; //--Confign\n\n    const channelNodes = this.audioNodes.channels[channelName]; //\n\n    channelNodes.analyserNode.fftSize = 256; //--EQ filters\n\n    channelNodes.eqLowFilterNode.type = \"lowshelf\";\n    channelNodes.eqLowFilterNode.frequency.setValueAtTime(this.config.low.frequency, audioCtx.currentTime);\n    channelNodes.eqHiFilterNode.type = \"highshelf\";\n    channelNodes.eqHiFilterNode.frequency.setValueAtTime(this.config.hi.frequency, audioCtx.currentTime);\n    channelNodes.eqMidFilterNode.type = \"peaking\";\n    channelNodes.eqMidFilterNode.frequency.setValueAtTime(this.config.mid.frequency, audioCtx.currentTime);\n    channelNodes.eqMidFilterNode.Q.setValueAtTime(this.config.mid.Q, audioCtx.currentTime); //--Filters\n    //--Send and return\n\n    channelNodes.sendAndReturns.forEach(channel => {\n      channelNodes.sendNode.connect(channel.send); //mute on start\n\n      channel.send.gain.value = 0;\n    });\n    const sends = channelNodes.sendAndReturns.map(channel => channel.send);\n\n    if (this.external && this.external.connect) {\n      const returns = this.external.connect(sends);\n      returns.forEach((returnNode, index) => {\n        returnNode.gain.value = 0;\n        channelNodes.sendAndReturns[index].return = returnNode;\n        returnNode.connect(channelNodes.mainGainNode);\n      });\n    } //Assign in chain \n\n\n    this.channels.getChannel(channelName).backend.setFilters([channelNodes.eqLowFilterNode, channelNodes.eqHiFilterNode, channelNodes.eqMidFilterNode, channelNodes.sendNode, channelNodes.bypassNode, channelNodes.mainGainNode, channelNodes.analyserNode, channelNodes.faderVolumeNode]); //-Conect to main output mixer channel\n\n    surfer.backend.gainNode.disconnect();\n    surfer.backend.gainNode.connect(this.mainAudioContext.destination);\n    this.setUpSampleBuffers(channelName);\n  }\n\n  setGainValue(channelName, knobValue, nodeName) {\n    let gain = 1 + knobValue / 100;\n    let audioCtx = this.channels.getChannel(channelName).backend.ac;\n    let channel = this.audioNodes.channels[channelName];\n    channel[nodeName].gain.setTargetAtTime(parseFloat(gain), audioCtx.currentTime, 0.01);\n  }\n\n  setFilterValue(channelName, knobValue, nodeName) {\n    let audioCtx = this.channels.getChannel(channelName).backend.ac;\n    let channel = this.audioNodes.channels[channelName];\n    channel[nodeName].gain.setValueAtTime(knobValue, audioCtx.currentTime);\n  }\n\n  setGain(channelName, knobValue) {\n    this.setGainValue(channelName, knobValue, 'mainGainNode');\n  }\n\n  setEqHigh(channelName, knobValue) {\n    this.setFilterValue(channelName, knobValue, 'eqHiFilterNode');\n  }\n\n  setEqMid(channelName, knobValue) {\n    this.setFilterValue(channelName, knobValue, 'eqMidFilterNode');\n  }\n\n  setEqLow(channelName, knobValue) {\n    this.setFilterValue(channelName, knobValue, 'eqLowFilterNode');\n  }\n\n  setSend(channelName, sendNumber, value) {\n    const sendAndReturns = this.audioNodes.channels[channelName].sendAndReturns;\n\n    if (value === 1) {\n      sendAndReturns._currentSends = sendAndReturns._currentSends ? sendAndReturns._currentSends.add(sendNumber) : new Set([sendNumber]);\n    } else if (value === 0 && sendAndReturns._currentSends) {\n      sendAndReturns._currentSends.remove(sendNumber);\n    }\n    /*\r\n            if (sendAndReturns._currentSends && sendAndReturns._currentSends.size > 1) {\r\n                value *= 0.70 ** sendAndReturns._currentSends.size;\r\n            }\r\n    \r\n            sendAndReturns.forEach((channel, index) => {\r\n                const { send, return: returns } = channel;\r\n                //current sending\r\n                if (sendAndReturns._currentSends.has(index)) {\r\n                    send.gain.setTargetAtTime(value, this.mainAudioContext.currentTime, 0.01);\r\n                    returns.gain.setTargetAtTime(value, this.mainAudioContext.currentTime, 0.01);\r\n                } else {\r\n                    send.gain.setTargetAtTime(0, this.mainAudioContext.currentTime, 0.01);\r\n                    returns.gain.setTargetAtTime(0, this.mainAudioContext.currentTime, 0.01);\r\n                }\r\n            })\r\n    \r\n    \r\n            //turn on/off bypass\r\n            const bypass = +!sendAndReturns._currentSends.size;\r\n            this.audioNodes.channels[channelName].bypassNode\r\n                .gain.setTargetAtTime(bypass, this.mainAudioContext.currentTime, 0.01);*/\n\n  }\n\n  setFader(value) {\n    //in procent from -50%  to + 50% (not 0.01) but 1\n    let faderVolumeNodeA = this.audioNodes.channels[\"A\"].faderVolumeNode;\n    let faderVolumeNodeB = this.audioNodes.channels[\"B\"].faderVolumeNode;\n    let audioCtxA = this.channels.getChannel(\"A\").backend.ac;\n    let audioCtxB = this.channels.getChannel(\"B\").backend.ac;\n\n    if (!faderVolumeNodeA || !faderVolumeNodeB || !audioCtxA || !audioCtxB) {\n      throw new Error(`Fader value not set. Mising auiodContext or AudioNode ref\n                            .Checkout funtion setFader in mixer object`);\n    }\n\n    let percent = (value + 50) / 100;\n    let volA = Math.cos(percent * 0.5 * Math.PI);\n    let volB = Math.cos((1 - percent) * 0.5 * Math.PI);\n    faderVolumeNodeA.gain.setTargetAtTime(volA, audioCtxA.currentTime, 0.01);\n    faderVolumeNodeB.gain.setTargetAtTime(volB, audioCtxB.currentTime, 0.01);\n  }\n\n  setUpSampleBuffers(channelName) {\n    let fftSize = this.audioNodes.channels[channelName].analyserNode.fftSize;\n    this.sampleBuffers.channels[channelName] = new Float32Array(fftSize);\n  }\n\n  getPeakMeter(channelName) {\n    var _this$audioNodes, _this$audioNodes$chan;\n\n    let analyser = (_this$audioNodes = this.audioNodes) === null || _this$audioNodes === void 0 ? void 0 : (_this$audioNodes$chan = _this$audioNodes.channels[channelName]) === null || _this$audioNodes$chan === void 0 ? void 0 : _this$audioNodes$chan.analyserNode;\n\n    if (!analyser) {\n      return [];\n    }\n\n    let sampleBuffer = this.sampleBuffers.channels[channelName];\n\n    if (!sampleBuffer) {\n      return [];\n    }\n\n    return this.getPeakData(analyser, sampleBuffer);\n  }\n\n  getPeakData(analyser, sampleBuffer) {\n    analyser.getFloatTimeDomainData(sampleBuffer); //average \n\n    let sumOfSquares = 0;\n\n    for (let i = 0; i < sampleBuffer.length; i++) {\n      sumOfSquares += sampleBuffer[i] ** 2;\n    }\n\n    const avgPowerDecibels = 10 * Math.log10(sumOfSquares / sampleBuffer.length); //peak \n\n    let peakPower = 0;\n\n    for (let i = 0; i < sampleBuffer.length; i++) {\n      const power = sampleBuffer[i] ** 2;\n      peakPower = Math.max(power, peakPower);\n    }\n\n    const peakPowerDecibels = 10 * Math.log10(peakPower);\n    return {\n      avgdB: avgPowerDecibels,\n      peakdB: peakPowerDecibels\n    };\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/src/pages/app/core/console/mixer/mixer.js"],"names":["store","Mixer","constructor","channels","config","getState","configuration","mixer","initChannelContainer","createMainChannel","connect","external","containerName","channelName","getChannelNames","mainAudioContext","AudioContext","ac","main","audioNodes","gainNode","createGain","analyserNode","createAnalyser","destination","getChannelInterface","getPeakMeter","setUpChannelsAudioNodes","surfer","getChannel","audioCtx","backend","eqHiFilterNode","createBiquadFilter","eqMidFilterNode","eqLowFilterNode","sendNode","sendAndReturns","Array","externalChannels","fill","map","send","return","bypassNode","mainGainNode","faderVolumeNode","channelNodes","fftSize","type","frequency","setValueAtTime","low","currentTime","hi","mid","Q","forEach","channel","gain","value","sends","returns","returnNode","index","setFilters","disconnect","setUpSampleBuffers","setGainValue","knobValue","nodeName","setTargetAtTime","parseFloat","setFilterValue","setGain","setEqHigh","setEqMid","setEqLow","setSend","sendNumber","_currentSends","add","Set","remove","setFader","faderVolumeNodeA","faderVolumeNodeB","audioCtxA","audioCtxB","Error","percent","volA","Math","cos","PI","volB","sampleBuffers","Float32Array","analyser","sampleBuffer","getPeakData","getFloatTimeDomainData","sumOfSquares","i","length","avgPowerDecibels","log10","peakPower","power","max","peakPowerDecibels","avgdB","peakdB"],"mappings":"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","sourcesContent":["import store from \"./../../../../../store\";\r\n\r\n\r\nexport default class Mixer {\r\n    constructor(channels) {\r\n\r\n        this.config = store.getState().configuration.mixer;\r\n\r\n        this.channels = channels;\r\n\r\n        this.initChannelContainer('audioNodes');\r\n        this.initChannelContainer('sampleBuffers');\r\n        this.createMainChannel();\r\n    }\r\n\r\n    connect(external) {\r\n        this.external = external;\r\n    }\r\n\r\n    initChannelContainer(containerName) {\r\n        this[containerName] = {\r\n            channels: {\r\n            }\r\n        }\r\n        for (let channelName of [...this.channels.getChannelNames(), \"main\"]) {\r\n            this[containerName].channels = {\r\n                ...this[containerName].channels,\r\n                [channelName]: null\r\n            }\r\n        }\r\n    }\r\n\r\n    createMainChannel() {\r\n        //main audio context with is share between wavesurfer objects\r\n        this.mainAudioContext = new AudioContext();\r\n\r\n        let ac = this.mainAudioContext;\r\n        let main = this.audioNodes.channels['main'];\r\n        main = {};\r\n\r\n        main.gainNode = ac.createGain();\r\n        main.analyserNode = ac.createAnalyser();\r\n        main.gainNode.connect(main.analyserNode);\r\n        main.analyserNode.connect(ac.destination);\r\n    }\r\n\r\n\r\n    getChannelInterface(channelName) {\r\n        return {\r\n            getPeakMeter: () => this.getPeakMeter(channelName),\r\n        }\r\n    }\r\n\r\n\r\n\r\n    setUpChannelsAudioNodes(channelName) {\r\n        //surfer - waveSurfer obj\r\n        let surfer = this.channels.getChannel(channelName)\r\n        let audioCtx = surfer.backend.ac;\r\n\r\n        //chained from up to down \r\n        this.audioNodes.channels[channelName] = {\r\n            eqHiFilterNode: audioCtx.createBiquadFilter(),\r\n            eqMidFilterNode: audioCtx.createBiquadFilter(),\r\n            eqLowFilterNode: audioCtx.createBiquadFilter(),\r\n            //low pass to do\r\n            //hi pass to do\r\n            sendNode: audioCtx.createGain(),\r\n            sendAndReturns: Array(this.config.externalChannels).fill(1).map(() => ({\r\n                send: audioCtx.createGain(),\r\n                return: null\r\n            })),\r\n            //\r\n            bypassNode: audioCtx.createGain(),\r\n            mainGainNode: audioCtx.createGain(),\r\n            analyserNode: audioCtx.createAnalyser(),\r\n            faderVolumeNode: audioCtx.createGain(),\r\n        }\r\n\r\n        //--Confign\r\n        const channelNodes = this.audioNodes.channels[channelName];\r\n        //\r\n        channelNodes.analyserNode.fftSize = 256;\r\n        //--EQ filters\r\n        channelNodes.eqLowFilterNode.type = \"lowshelf\";\r\n        channelNodes.eqLowFilterNode.frequency.setValueAtTime(this.config.low.frequency, audioCtx.currentTime);\r\n\r\n        channelNodes.eqHiFilterNode.type = \"highshelf\";\r\n        channelNodes.eqHiFilterNode.frequency.setValueAtTime(this.config.hi.frequency, audioCtx.currentTime);\r\n\r\n        channelNodes.eqMidFilterNode.type = \"peaking\";\r\n        channelNodes.eqMidFilterNode.frequency.setValueAtTime(this.config.mid.frequency, audioCtx.currentTime);\r\n        channelNodes.eqMidFilterNode.Q.setValueAtTime(this.config.mid.Q, audioCtx.currentTime);\r\n        //--Filters\r\n\r\n        //--Send and return\r\n        channelNodes.sendAndReturns.forEach((channel) => {\r\n            channelNodes.sendNode.connect(channel.send);\r\n            //mute on start\r\n            channel.send.gain.value = 0;\r\n        });\r\n        const sends = channelNodes.sendAndReturns.map(channel => channel.send);\r\n        if (this.external && this.external.connect) {\r\n            const returns = this.external.connect(sends);\r\n            returns.forEach((returnNode, index) => {\r\n                returnNode.gain.value = 0;\r\n                channelNodes.sendAndReturns[index].return = returnNode;\r\n                returnNode.connect(channelNodes.mainGainNode);\r\n            })\r\n        }\r\n\r\n\r\n        //Assign in chain \r\n        this.channels.getChannel(channelName).backend.setFilters([\r\n            channelNodes.eqLowFilterNode,\r\n            channelNodes.eqHiFilterNode,\r\n            channelNodes.eqMidFilterNode,\r\n            channelNodes.sendNode,\r\n            channelNodes.bypassNode,\r\n            channelNodes.mainGainNode,\r\n            channelNodes.analyserNode,\r\n            channelNodes.faderVolumeNode,\r\n        ])\r\n\r\n        //-Conect to main output mixer channel\r\n        surfer.backend.gainNode.disconnect();\r\n        surfer.backend.gainNode.connect(this.mainAudioContext.destination);\r\n\r\n        this.setUpSampleBuffers(channelName);\r\n    }\r\n\r\n\r\n\r\n    setGainValue(channelName, knobValue, nodeName) {\r\n        let gain = 1 + knobValue / 100;\r\n        let audioCtx = this.channels.getChannel(channelName).backend.ac;\r\n\r\n        let channel = this.audioNodes.channels[channelName];\r\n        channel[nodeName].gain.setTargetAtTime(parseFloat(gain), audioCtx.currentTime, 0.01);\r\n    }\r\n\r\n    setFilterValue(channelName, knobValue, nodeName) {\r\n        let audioCtx = this.channels.getChannel(channelName).backend.ac;\r\n\r\n        let channel = this.audioNodes.channels[channelName];\r\n        channel[nodeName].gain.setValueAtTime(knobValue, audioCtx.currentTime);\r\n    }\r\n\r\n\r\n    setGain(channelName, knobValue) {\r\n        this.setGainValue(channelName, knobValue, 'mainGainNode');\r\n    }\r\n\r\n    setEqHigh(channelName, knobValue) {\r\n        this.setFilterValue(channelName, knobValue, 'eqHiFilterNode');\r\n    }\r\n\r\n    setEqMid(channelName, knobValue) {\r\n        this.setFilterValue(channelName, knobValue, 'eqMidFilterNode');\r\n    }\r\n\r\n    setEqLow(channelName, knobValue) {\r\n        this.setFilterValue(channelName, knobValue, 'eqLowFilterNode');\r\n    }\r\n\r\n    setSend(channelName, sendNumber, value) {\r\n        const sendAndReturns = this.audioNodes.channels[channelName].sendAndReturns;\r\n        if (value === 1) {\r\n            sendAndReturns._currentSends =\r\n                (sendAndReturns._currentSends) ? sendAndReturns._currentSends.add(sendNumber) : new Set([sendNumber]);\r\n        } else if (value === 0 && sendAndReturns._currentSends) {\r\n            sendAndReturns._currentSends.remove(sendNumber);\r\n        }\r\n\r\n/*\r\n        if (sendAndReturns._currentSends && sendAndReturns._currentSends.size > 1) {\r\n            value *= 0.70 ** sendAndReturns._currentSends.size;\r\n        }\r\n\r\n        sendAndReturns.forEach((channel, index) => {\r\n            const { send, return: returns } = channel;\r\n            //current sending\r\n            if (sendAndReturns._currentSends.has(index)) {\r\n                send.gain.setTargetAtTime(value, this.mainAudioContext.currentTime, 0.01);\r\n                returns.gain.setTargetAtTime(value, this.mainAudioContext.currentTime, 0.01);\r\n            } else {\r\n                send.gain.setTargetAtTime(0, this.mainAudioContext.currentTime, 0.01);\r\n                returns.gain.setTargetAtTime(0, this.mainAudioContext.currentTime, 0.01);\r\n            }\r\n        })\r\n\r\n\r\n        //turn on/off bypass\r\n        const bypass = +!sendAndReturns._currentSends.size;\r\n        this.audioNodes.channels[channelName].bypassNode\r\n            .gain.setTargetAtTime(bypass, this.mainAudioContext.currentTime, 0.01);*/\r\n    }\r\n\r\n\r\n    setFader(value) {//in procent from -50%  to + 50% (not 0.01) but 1\r\n        let faderVolumeNodeA = this.audioNodes.channels[\"A\"].faderVolumeNode;\r\n        let faderVolumeNodeB = this.audioNodes.channels[\"B\"].faderVolumeNode;\r\n        let audioCtxA = this.channels.getChannel(\"A\").backend.ac;\r\n        let audioCtxB = this.channels.getChannel(\"B\").backend.ac;\r\n\r\n        if (!faderVolumeNodeA || !faderVolumeNodeB || !audioCtxA || !audioCtxB) {\r\n            throw new Error(`Fader value not set. Mising auiodContext or AudioNode ref\r\n                            .Checkout funtion setFader in mixer object`);\r\n        }\r\n\r\n        let percent = (value + 50) / 100;\r\n        let volA = Math.cos(percent * 0.5 * Math.PI);\r\n        let volB = Math.cos((1 - percent) * 0.5 * Math.PI);\r\n\r\n        faderVolumeNodeA.gain.setTargetAtTime(volA, audioCtxA.currentTime, 0.01);\r\n        faderVolumeNodeB.gain.setTargetAtTime(volB, audioCtxB.currentTime, 0.01);\r\n    }\r\n\r\n\r\n    setUpSampleBuffers(channelName) {\r\n        let fftSize = this.audioNodes.channels[channelName].analyserNode.fftSize;\r\n        this.sampleBuffers.channels[channelName] = new Float32Array(fftSize);\r\n    }\r\n\r\n    getPeakMeter(channelName) {\r\n        let analyser = this.audioNodes?.channels[channelName]?.analyserNode\r\n        if (!analyser) {\r\n            return [];\r\n        }\r\n        let sampleBuffer = this.sampleBuffers.channels[channelName];\r\n        if (!sampleBuffer) {\r\n            return [];\r\n        }\r\n        return this.getPeakData(analyser, sampleBuffer)\r\n    }\r\n\r\n    getPeakData(analyser, sampleBuffer) {\r\n        analyser.getFloatTimeDomainData(sampleBuffer);\r\n\r\n        //average \r\n        let sumOfSquares = 0;\r\n        for (let i = 0; i < sampleBuffer.length; i++) {\r\n            sumOfSquares += sampleBuffer[i] ** 2;\r\n        }\r\n\r\n        const avgPowerDecibels = 10 * Math.log10(sumOfSquares / sampleBuffer.length);\r\n\r\n        //peak \r\n\r\n        let peakPower = 0;\r\n        for (let i = 0; i < sampleBuffer.length; i++) {\r\n            const power = sampleBuffer[i] ** 2;\r\n            peakPower = Math.max(power, peakPower);\r\n        }\r\n        const peakPowerDecibels = 10 * Math.log10(peakPower);\r\n\r\n        return {\r\n            avgdB: avgPowerDecibels,\r\n            peakdB: peakPowerDecibels,\r\n        }\r\n    }\r\n\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}