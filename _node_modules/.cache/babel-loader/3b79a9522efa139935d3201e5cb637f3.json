{"ast":null,"code":"import store from \"./../../../../../../store\";\nimport { setChannelReady, setLoadingProgress, setTimeLeft, togglePlay, setLoop } from \"./../../../../../../actions\";\nexport default class EventHandler {\n  constructor() {\n    this.startSync = channel => {\n      channel.syncHandle = setInterval(() => {\n        channel.slave.drawer.progress(channel.master.backend.getPlayedPercents());\n      }, 500);\n    };\n\n    this.dispatch = store.dispatch;\n  }\n\n  CreateEventHandling(channel) {\n    this.onLoad(channel);\n    this.onLoading(channel);\n    this.onReady(channel);\n    this.onPlay(channel);\n    this.onStop(channel);\n    this.onSlaveSeek(channel);\n    this.onMasterSeek(channel);\n    this.onFinish(channel);\n  } // --- events below\n\n\n  onLoad(channel) {\n    channel.master.on(\"load\", () => {\n      this.clearState(channel);\n    });\n  }\n\n  onLoading(channel) {\n    channel.master.on(\"loading\", progress => {\n      this.dispatch(setLoadingProgress(channel.channelName, progress));\n    });\n  }\n\n  onReady(channel) {\n    channel.master.on(\"ready\", () => {\n      channel.currentDuration = channel.master.getDuration(); //resolution value is taken from manual test\n      // const resolution = 280;\n      // channel.slave.load(\n      //     null, \n      //     channel.master.backend.getPeaks(resolution, 0, resolution) \n      //   );\n\n      const resolution = 280;\n      const peaks = channel.master.backend.getPeaks(resolution, 0, resolution);\n      const start = 0;\n      const end = peaks.length / 2;\n      const width = channel.slave.params.container.getBoundingClientRect().width;\n      channel.slave.drawer.drawPeaks(peaks, width, start, end);\n      this.dispatch(setLoadingProgress(channel.channelName, 100));\n      this.dispatch(setChannelReady(true, channel.channelName));\n      this.startSync(channel);\n\n      channel.master.drawer._measureDimensions();\n    });\n  }\n\n  onPlay(channel) {\n    channel.master.on(\"play\", () => {\n      channel._clockHandle = setInterval(() => {\n        const timeLeft = parseInt(channel.master.getDuration() - channel.master.getCurrentTime());\n        this.dispatch(setTimeLeft(channel.channelName, timeLeft));\n      }, 500);\n    });\n  }\n\n  onStop(channel) {\n    channel.master.on('pause', () => {\n      clearInterval(channel._clockHandle);\n    });\n  }\n\n  onSlaveSeek(channel) {\n    channel.slave.on(\"seek\", progress => {\n      const wasPlaying = channel.master.isPlaying();\n      channel.master.backend.seekTo(progress * channel.currentDuration);\n      channel.master.drawer.progress(progress);\n      channel.master.fireEvent(\"seek\", progress);\n      channel.slave.drawer.progress(progress);\n      const timeLeft = parseInt(channel.master.getDuration() - channel.master.getDuration() * progress);\n      this.dispatch(setTimeLeft(channel.channelName, timeLeft));\n\n      if (wasPlaying) {\n        channel.master.play();\n      }\n    });\n  }\n\n  onMasterSeek(channel) {\n    // updating time Left value\n    ///Because on seek event is called a 1000 time per second, is created watcher witch update\n    // value after 500 ms with last progress value\n    let watcher = null;\n    let lastCall = {\n      time: new Date().getTime(),\n      value: null\n    };\n    channel.master.on(\"seek\", progress => {\n      lastCall.time = new Date().getTime();\n      lastCall.progress = progress;\n\n      if (!watcher) {\n        watcher = setTimeout(() => {\n          if (new Date().getTime() - lastCall.time >= 100) {\n            const timeLeft = parseInt(channel.master.getDuration() * lastCall.progress);\n            this.dispatch(setTimeLeft(channel.channelName, timeLeft));\n            clearTimeout(watcher);\n            watcher = null;\n          }\n        }, 500);\n      }\n    });\n    this.dispatch(setLoop(channel.channelName, false));\n  }\n\n  onFinish(channel) {\n    channel.master.on(\"finish\", () => {\n      this.dispatch(togglePlay(channel.channelName));\n      clearInterval(channel._clockHandle);\n    });\n  } //---------------------------------------\n\n\n  clearState(channel) {\n    channel.slave.load(null, []);\n\n    if (channel.barsElements) {\n      channel.barsElements.forEach(htmlElement => htmlElement.remove());\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/console/core/console/channels/channelEvnetHandler/channelEvnetHandler.js"],"names":["store","setChannelReady","setLoadingProgress","setTimeLeft","togglePlay","setLoop","EventHandler","constructor","startSync","channel","syncHandle","setInterval","slave","drawer","progress","master","backend","getPlayedPercents","dispatch","CreateEventHandling","onLoad","onLoading","onReady","onPlay","onStop","onSlaveSeek","onMasterSeek","onFinish","on","clearState","channelName","currentDuration","getDuration","resolution","peaks","getPeaks","start","end","length","width","params","container","getBoundingClientRect","drawPeaks","_measureDimensions","_clockHandle","timeLeft","parseInt","getCurrentTime","clearInterval","wasPlaying","isPlaying","seekTo","fireEvent","play","watcher","lastCall","time","Date","getTime","value","setTimeout","clearTimeout","load","barsElements","forEach","htmlElement","remove"],"mappings":"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","sourcesContent":["import store from \"./../../../../../../store\";\r\n\r\nimport {\r\n  setChannelReady,\r\n  setLoadingProgress,\r\n  setTimeLeft,\r\n  togglePlay,\r\n  setLoop\r\n} from \"./../../../../../../actions\";\r\n\r\nexport default class EventHandler {\r\n  constructor() {\r\n    this.dispatch = store.dispatch;\r\n  }\r\n\r\n  CreateEventHandling(channel) {\r\n    this.onLoad(channel);\r\n    this.onLoading(channel);\r\n    this.onReady(channel);\r\n    this.onPlay(channel);\r\n    this.onStop(channel);\r\n\r\n    this.onSlaveSeek(channel);\r\n    this.onMasterSeek(channel);\r\n    this.onFinish(channel);\r\n  }\r\n  // --- events below\r\n\r\n  onLoad(channel) {\r\n    channel.master.on(\"load\", () => {\r\n      this.clearState(channel);\r\n    });\r\n  }\r\n\r\n  onLoading(channel) {\r\n    channel.master.on(\"loading\", progress => {\r\n      this.dispatch(setLoadingProgress(channel.channelName, progress));\r\n    });\r\n  }\r\n\r\n  onReady(channel) {\r\n    channel.master.on(\"ready\", () => {\r\n      channel.currentDuration = channel.master.getDuration();\r\n      //resolution value is taken from manual test\r\n      // const resolution = 280;\r\n      // channel.slave.load(\r\n      //     null, \r\n      //     channel.master.backend.getPeaks(resolution, 0, resolution) \r\n      //   );\r\n      const resolution = 280;\r\n      const peaks = channel.master.backend.getPeaks(resolution, 0 , resolution);\r\n      const start = 0;\r\n      const end = peaks.length / 2;\r\n      const width = channel.slave.params.container.getBoundingClientRect().width\r\n      channel.slave.drawer.drawPeaks(peaks, width, start, end);\r\n      \r\n\r\n      this.dispatch(setLoadingProgress(channel.channelName, 100));\r\n      this.dispatch(setChannelReady(true, channel.channelName));\r\n\r\n      this.startSync(channel);\r\n\r\n      channel.master.drawer._measureDimensions();\r\n    });\r\n  }\r\n\r\n\r\n  onPlay(channel){\r\n    channel.master.on(\"play\", ()=>{\r\n        channel._clockHandle = setInterval(()=>{\r\n          const timeLeft = parseInt(channel.master.getDuration() - channel.master.getCurrentTime());\r\n          this.dispatch(setTimeLeft(channel.channelName, timeLeft))\r\n        }, 500)\r\n    })\r\n  }\r\n\r\n  onStop(channel){\r\n    channel.master.on('pause', ()=>{\r\n      clearInterval(channel._clockHandle)\r\n    })\r\n  }\r\n\r\n  onSlaveSeek(channel) {\r\n    channel.slave.on(\"seek\", progress => {\r\n      const wasPlaying = channel.master.isPlaying();\r\n\r\n      channel.master.backend.seekTo(progress * channel.currentDuration);\r\n      channel.master.drawer.progress(progress);\r\n      channel.master.fireEvent(\"seek\", progress);\r\n\r\n      channel.slave.drawer.progress(progress);\r\n\r\n      const timeLeft = parseInt(channel.master.getDuration() - channel.master.getDuration() * progress);\r\n      this.dispatch(setTimeLeft(channel.channelName, timeLeft));\r\n\r\n      if (wasPlaying) {\r\n        channel.master.play();\r\n      }\r\n    });\r\n  }\r\n\r\n  onMasterSeek(channel) {\r\n    // updating time Left value\r\n    ///Because on seek event is called a 1000 time per second, is created watcher witch update\r\n    // value after 500 ms with last progress value\r\n    let watcher = null;\r\n    let lastCall = {\r\n      time: new Date().getTime(),\r\n      value: null\r\n    };\r\n\r\n    channel.master.on(\"seek\", progress => {\r\n      lastCall.time = new Date().getTime();\r\n      lastCall.progress = progress;\r\n      if (!watcher) {\r\n        watcher = setTimeout(() => {\r\n          if (new Date().getTime() - lastCall.time >= 100) {\r\n            const timeLeft = parseInt(channel.master.getDuration() * lastCall.progress);\r\n            this.dispatch(setTimeLeft(channel.channelName, timeLeft));\r\n            clearTimeout(watcher);\r\n            watcher = null;\r\n          }\r\n        }, 500);\r\n      }\r\n    });\r\n\r\n    this.dispatch(setLoop(channel.channelName, false));\r\n  }\r\n\r\n\r\n  onFinish(channel) {\r\n    channel.master.on(\"finish\", () => {\r\n      this.dispatch(togglePlay(channel.channelName));\r\n      clearInterval(channel._clockHandle);\r\n    });\r\n  }\r\n\r\n  //---------------------------------------\r\n  clearState(channel) {\r\n    channel.slave.load(null, []);\r\n    if (channel.barsElements) {\r\n      channel.barsElements.forEach(htmlElement => htmlElement.remove());\r\n    }\r\n  }\r\n\r\n  startSync = channel => {\r\n    channel.syncHandle = setInterval(() => {\r\n      channel.slave.drawer.progress(\r\n        channel.master.backend.getPlayedPercents()\r\n      );\r\n    }, 500);\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}