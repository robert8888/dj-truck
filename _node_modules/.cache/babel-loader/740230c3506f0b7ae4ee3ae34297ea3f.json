{"ast":null,"code":"import store from \"./../../../store\";\nexport default class Mixer {\n  constructor(channels) {\n    this.config = store.getState().configuration.mixer;\n    this.channels = channels;\n    this.createOutputChannel();\n    this.initChannelContainer('audioNodes');\n    this.initChannelContainer('sampleBuffers');\n  }\n\n  initChannelContainer(containerName) {\n    this[containerName] = {\n      channels: {}\n    };\n\n    for (let channelName of [...this.channels.getChannelNames(), \"master\"]) {\n      this[containerName].channels = { ...this[containerName].channels,\n        [channelName]: null\n      };\n    }\n  }\n\n  createOutputChannel() {\n    //main audio context with is share between wavesurfer objects\n    this.output = {\n      ac: new AudioContext()\n    };\n    this.output.gainNode = this.output.ac.createGain();\n    this.output.gainNode.connect(this.output.ac.destination);\n  }\n\n  getChannelInterface(channelName) {\n    return {\n      getPeakMeter: () => this.getPeakMeter(channelName)\n    };\n  }\n\n  setUpAudioNodes(channelName) {\n    //surfer - waveSurfer obj\n    let surfer = this.channels.getChannel(channelName);\n    let audioCtx = surfer.backend.ac; //chained from up to down \n\n    this.audioNodes.channels[channelName] = {\n      analyserNode: audioCtx.createAnalyser(),\n      faderVolumeNode: audioCtx.createGain(),\n      gainNode: audioCtx.createGain(),\n      eqHiFilterNode: audioCtx.createBiquadFilter(),\n      eqMidFilterNode: audioCtx.createBiquadFilter(),\n      eqLowFilterNode: audioCtx.createBiquadFilter()\n    }; ////-----------Confign\n\n    const channelNodes = this.audioNodes.channels[channelName]; //\n\n    channelNodes.analyserNode.fftSize = 256; //\n\n    channelNodes.eqLowFilterNode.type = \"lowshelf\";\n    channelNodes.eqLowFilterNode.frequency.setValueAtTime(this.config.low.frequency, audioCtx.currentTime);\n    channelNodes.eqHiFilterNode.type = \"highshelf\";\n    channelNodes.eqHiFilterNode.frequency.setValueAtTime(this.config.hi.frequency, audioCtx.currentTime);\n    channelNodes.eqMidFilterNode.type = \"peaking\";\n    channelNodes.eqMidFilterNode.frequency.setValueAtTime(this.config.mid.frequency, audioCtx.currentTime);\n    channelNodes.eqMidFilterNode.Q.setValueAtTime(this.config.mid.Q, audioCtx.currentTime); //Assign in chain \n\n    this.channels.getChannel(channelName).backend.setFilters([channelNodes.eqLowFilterNode, channelNodes.eqMidFilterNode, channelNodes.eqHiFilterNode, channelNodes.gainNode, channelNodes.analyserNode, channelNodes.faderVolumeNode]); //-Conect to main output mixer channel\n\n    surfer.backend.gainNode.disconnect();\n    surfer.backend.gainNode.connect(this.output.gainNode);\n    this.setUpSampleBuffers(channelName);\n  }\n\n  setUpSampleBuffers(channelName) {\n    let fftSize = this.audioNodes.channels[channelName].analyserNode.fftSize;\n    this.sampleBuffers.channels[channelName] = new Float32Array(fftSize);\n  }\n\n  setGainValue(channelName, knobValue, nodeName) {\n    let gain = 1 + knobValue / 100;\n    let audioCtx = this.channels.getChannel(channelName).backend.ac;\n    let channel = this.audioNodes.channels[channelName];\n    channel[nodeName].gain.setTargetAtTime(parseFloat(gain), audioCtx.currentTime, 0.01);\n  }\n\n  setFilterValue(channelName, knobValue, nodeName) {\n    let audioCtx = this.channels.getChannel(channelName).backend.ac;\n    let channel = this.audioNodes.channels[channelName];\n    channel[nodeName].gain.setValueAtTime(knobValue, audioCtx.currentTime);\n  }\n\n  setGain(channelName, knobValue) {\n    this.setGainValue(channelName, knobValue, 'gainNode');\n  }\n\n  setEqHigh(channelName, knobValue) {\n    this.setFilterValue(channelName, knobValue, 'eqHiFilterNode');\n  }\n\n  setEqMid(channelName, knobValue) {\n    this.setFilterValue(channelName, knobValue, 'eqMidFilterNode');\n  }\n\n  setEqLow(channelName, knobValue) {\n    this.setFilterValue(channelName, knobValue, 'eqLowFilterNode');\n  }\n\n  setFader(value) {\n    //in procent from -50%  to + 50% (not 0.01) but 1\n    let faderVolumeNodeA = this.audioNodes.channels[\"A\"].faderVolumeNode;\n    let faderVolumeNodeB = this.audioNodes.channels[\"B\"].faderVolumeNode;\n    let audioCtxA = this.channels.getChannel(\"A\").backend.ac;\n    let audioCtxB = this.channels.getChannel(\"B\").backend.ac;\n\n    if (!faderVolumeNodeA || !faderVolumeNodeB || !audioCtxA || !audioCtxB) {\n      throw new Error(\"Fased value not set checkout funtion setFader in mixer object\");\n    }\n\n    let percent = (value + 50) / 100;\n    let volA = Math.cos(percent * 0.5 * Math.PI);\n    let volB = Math.cos((1 - percent) * 0.5 * Math.PI);\n    faderVolumeNodeA.gain.setTargetAtTime(volA, audioCtxA.currentTime, 0.01);\n    faderVolumeNodeB.gain.setTargetAtTime(volB, audioCtxB.currentTime, 0.01);\n  }\n\n  getPeakMeter(channelName) {\n    var _this$audioNodes, _this$audioNodes$chan;\n\n    let analyser = (_this$audioNodes = this.audioNodes) === null || _this$audioNodes === void 0 ? void 0 : (_this$audioNodes$chan = _this$audioNodes.channels[channelName]) === null || _this$audioNodes$chan === void 0 ? void 0 : _this$audioNodes$chan.analyserNode;\n\n    if (!analyser) {\n      return [];\n    }\n\n    let sampleBuffer = this.sampleBuffers.channels[channelName];\n\n    if (!sampleBuffer) {\n      return [];\n    }\n\n    return this.getAnalyserData(analyser, sampleBuffer);\n  }\n\n  getAnalyserData(analyser, sampleBuffer) {\n    analyser.getFloatTimeDomainData(sampleBuffer); //average \n\n    let sumOfSquares = 0;\n\n    for (let i = 0; i < sampleBuffer.length; i++) {\n      sumOfSquares += sampleBuffer[i] ** 2;\n    }\n\n    const avgPowerDecibels = 10 * Math.log10(sumOfSquares / sampleBuffer.length); //peak \n\n    let peakPower = 0;\n\n    for (let i = 0; i < sampleBuffer.length; i++) {\n      const power = sampleBuffer[i] ** 2;\n      peakPower = Math.max(power, peakPower);\n    }\n\n    const peakPowerDecibels = 10 * Math.log10(peakPower);\n    return {\n      avgdB: avgPowerDecibels,\n      peakdB: peakPowerDecibels\n    };\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/src/core/console/mixer/mixer.js"],"names":["store","Mixer","constructor","channels","config","getState","configuration","mixer","createOutputChannel","initChannelContainer","containerName","channelName","getChannelNames","output","ac","AudioContext","gainNode","createGain","connect","destination","getChannelInterface","getPeakMeter","setUpAudioNodes","surfer","getChannel","audioCtx","backend","audioNodes","analyserNode","createAnalyser","faderVolumeNode","eqHiFilterNode","createBiquadFilter","eqMidFilterNode","eqLowFilterNode","channelNodes","fftSize","type","frequency","setValueAtTime","low","currentTime","hi","mid","Q","setFilters","disconnect","setUpSampleBuffers","sampleBuffers","Float32Array","setGainValue","knobValue","nodeName","gain","channel","setTargetAtTime","parseFloat","setFilterValue","setGain","setEqHigh","setEqMid","setEqLow","setFader","value","faderVolumeNodeA","faderVolumeNodeB","audioCtxA","audioCtxB","Error","percent","volA","Math","cos","PI","volB","analyser","sampleBuffer","getAnalyserData","getFloatTimeDomainData","sumOfSquares","i","length","avgPowerDecibels","log10","peakPower","power","max","peakPowerDecibels","avgdB","peakdB"],"mappings":"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","sourcesContent":["import store from \"./../../../store\";\r\n\r\n\r\nexport default class Mixer{\r\n    constructor(channels){\r\n        this.config = store.getState().configuration.mixer;\r\n        \r\n        this.channels = channels;\r\n\r\n        this.createOutputChannel();\r\n        this.initChannelContainer('audioNodes');\r\n        this.initChannelContainer('sampleBuffers');\r\n    }\r\n\r\n    \r\n\r\n    initChannelContainer(containerName){\r\n        this[containerName] =   {\r\n            channels : {\r\n            }\r\n        }\r\n        for(let channelName of [...this.channels.getChannelNames(), \"master\"]){\r\n            this[containerName].channels = {\r\n                ...this[containerName].channels,\r\n                [channelName] : null\r\n            }\r\n        }\r\n    }\r\n\r\n    createOutputChannel(){\r\n        //main audio context with is share between wavesurfer objects\r\n        this.output = {\r\n            ac: new AudioContext()\r\n        }\r\n        this.output.gainNode = this.output.ac.createGain();\r\n        this.output.gainNode.connect(this.output.ac.destination);\r\n    }\r\n\r\n\r\n    getChannelInterface(channelName){\r\n        return {\r\n            getPeakMeter: () => this.getPeakMeter(channelName),\r\n        }\r\n    }\r\n\r\n\r\n\r\n    setUpAudioNodes(channelName){\r\n        //surfer - waveSurfer obj\r\n        let surfer = this.channels.getChannel(channelName)\r\n        let audioCtx = surfer.backend.ac;\r\n\r\n        //chained from up to down \r\n        this.audioNodes.channels[channelName] = {\r\n            analyserNode : audioCtx.createAnalyser(),\r\n            faderVolumeNode : audioCtx.createGain(),\r\n            gainNode : audioCtx.createGain(),\r\n            eqHiFilterNode : audioCtx.createBiquadFilter(),\r\n            eqMidFilterNode : audioCtx.createBiquadFilter(),\r\n            eqLowFilterNode : audioCtx.createBiquadFilter(),\r\n\r\n        }\r\n\r\n        ////-----------Confign\r\n        const channelNodes = this.audioNodes.channels[channelName];\r\n        //\r\n        channelNodes.analyserNode.fftSize = 256;\r\n        //\r\n        channelNodes.eqLowFilterNode.type = \"lowshelf\";\r\n        channelNodes.eqLowFilterNode.frequency.setValueAtTime(this.config.low.frequency, audioCtx.currentTime);\r\n\r\n        channelNodes.eqHiFilterNode.type = \"highshelf\";\r\n        channelNodes.eqHiFilterNode.frequency.setValueAtTime(this.config.hi.frequency, audioCtx.currentTime);\r\n\r\n        channelNodes.eqMidFilterNode.type = \"peaking\";\r\n        channelNodes.eqMidFilterNode.frequency.setValueAtTime(this.config.mid.frequency, audioCtx.currentTime);\r\n        channelNodes.eqMidFilterNode.Q.setValueAtTime(this.config.mid.Q, audioCtx.currentTime);  \r\n\r\n        //Assign in chain \r\n        this.channels.getChannel(channelName).backend.setFilters([\r\n            channelNodes.eqLowFilterNode, \r\n            channelNodes.eqMidFilterNode, \r\n            channelNodes.eqHiFilterNode, \r\n            channelNodes.gainNode,\r\n            channelNodes.analyserNode,\r\n            channelNodes.faderVolumeNode,\r\n\r\n         ])\r\n         //-Conect to main output mixer channel\r\n        surfer.backend.gainNode.disconnect();\r\n        surfer.backend.gainNode.connect(this.output.gainNode);\r\n\r\n        this.setUpSampleBuffers(channelName);\r\n    }\r\n    \r\n    setUpSampleBuffers(channelName){\r\n        let fftSize = this.audioNodes.channels[channelName].analyserNode.fftSize;\r\n        this.sampleBuffers.channels[channelName] = new Float32Array(fftSize);\r\n    }\r\n\r\n\r\n    setGainValue(channelName, knobValue, nodeName){\r\n        let gain = 1 + knobValue / 100 ;\r\n        let audioCtx = this.channels.getChannel(channelName).backend.ac;\r\n\r\n        let channel = this.audioNodes.channels[channelName];\r\n        channel[nodeName].gain.setTargetAtTime( parseFloat(gain) , audioCtx.currentTime, 0.01);\r\n    }\r\n\r\n    setFilterValue(channelName, knobValue, nodeName){\r\n        let audioCtx = this.channels.getChannel(channelName).backend.ac;\r\n\r\n        let channel = this.audioNodes.channels[channelName];\r\n        channel[nodeName].gain.setValueAtTime( knobValue , audioCtx.currentTime);\r\n    }\r\n\r\n\r\n    setGain(channelName, knobValue){\r\n        this.setGainValue(channelName, knobValue, 'gainNode');\r\n    }\r\n\r\n    setEqHigh(channelName, knobValue){\r\n        this.setFilterValue(channelName, knobValue, 'eqHiFilterNode');\r\n    }\r\n\r\n    setEqMid(channelName, knobValue){\r\n        this.setFilterValue(channelName, knobValue, 'eqMidFilterNode');\r\n    }\r\n\r\n    setEqLow(channelName, knobValue){\r\n        this.setFilterValue(channelName, knobValue, 'eqLowFilterNode');\r\n    }\r\n\r\n    setFader(value){//in procent from -50%  to + 50% (not 0.01) but 1\r\n        let faderVolumeNodeA = this.audioNodes.channels[\"A\"].faderVolumeNode;\r\n        let faderVolumeNodeB = this.audioNodes.channels[\"B\"].faderVolumeNode;\r\n        let audioCtxA = this.channels.getChannel(\"A\").backend.ac;\r\n        let audioCtxB = this.channels.getChannel(\"B\").backend.ac;\r\n        if(!faderVolumeNodeA || !faderVolumeNodeB || !audioCtxA || !audioCtxB){\r\n            throw new Error(\"Fased value not set checkout funtion setFader in mixer object\");\r\n        }\r\n\r\n        let percent = (value + 50)/100;\r\n        let volA = Math.cos(percent * 0.5 * Math.PI);\r\n        let volB = Math.cos((1 - percent) * 0.5 * Math.PI);\r\n\r\n        faderVolumeNodeA.gain.setTargetAtTime(volA, audioCtxA.currentTime, 0.01);\r\n        faderVolumeNodeB.gain.setTargetAtTime(volB, audioCtxB.currentTime, 0.01);\r\n    }\r\n\r\n    \r\n\r\n\r\n    getPeakMeter(channelName){\r\n        let analyser  = this.audioNodes?.channels[channelName]?.analyserNode\r\n        if(!analyser) {\r\n            return [];\r\n        }\r\n        let sampleBuffer = this.sampleBuffers.channels[channelName];\r\n        if(!sampleBuffer){\r\n            return [];\r\n        }\r\n        return this.getAnalyserData(analyser, sampleBuffer)\r\n    }\r\n\r\n    getAnalyserData(analyser, sampleBuffer){\r\n        analyser.getFloatTimeDomainData(sampleBuffer);\r\n       \r\n        //average \r\n        let sumOfSquares = 0;\r\n        for (let i = 0; i < sampleBuffer.length; i++) {\r\n          sumOfSquares += sampleBuffer[i] ** 2;\r\n        }\r\n\r\n        const avgPowerDecibels = 10 * Math.log10(sumOfSquares / sampleBuffer.length);\r\n\r\n        //peak \r\n\r\n        let peakPower = 0;\r\n        for (let i = 0; i < sampleBuffer.length; i++) {\r\n          const power = sampleBuffer[i] ** 2;\r\n          peakPower = Math.max(power, peakPower);\r\n        }\r\n        const peakPowerDecibels = 10 * Math.log10(peakPower);\r\n\r\n        return {\r\n            avgdB : avgPowerDecibels,\r\n            peakdB : peakPowerDecibels,\r\n        }\r\n    }\r\n    \r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}