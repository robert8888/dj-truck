{"ast":null,"code":"//const map = require('unist-util-map');\nconst vFile = require('vfile');\n\nmodule.exports = attacher;\n\nconst newFileFrom = (vfile, contents) => {\n  return vFile({ ...vfile,\n    contents: contents\n  });\n};\n\nfunction attacher() {\n  // console.log(\"the this\", this.Parser);\n  const pattern = /{\\.(\\w+)}/;\n  const processor = this;\n\n  function transformer(tree, file) {\n    let inlineMethods = processor.Parser.prototype.inlineMethods;\n    let blockMethods = processor.Parser.prototype.blockMethods; // console.log(\"before modification\", tree)\n\n    const modify = node => {\n      console.log(\"in modify\", node);\n      let parent = node;\n      if (!node.children) return node;\n      const children = node.children.map(node => {// if(node.type !== \"text\") return modify(node);\n        // console.log(\"node in\", node)\n        // let match = pattern.exec(node.value);\n        // if(!match) return node;\n        // const value = node.value.replace(match[0], \"\");\n        // const subNodes = processor.parse(newFileFrom(file, value))?.children;\n        // // console.log(\"parnet subnodes\", parent, subNodes)\n        // if(subNodes.some( subNode => subNode.type === \"thematicBreak\")\n        //     && parent.type === \"paragraph\"){\n        //     parent = subNodes.find( subNode => subNode.type === \"thematicBreak\");\n        //     parent.className = match[1];\n        //     parent.position = node.position;\n        //     parent.position.end.column-=match[0].length;\n        //     parent.position.end.offset-=match[0].length;\n        //\n        // }\n      }); //  node = parent;\n\n      node.children = children;\n      return node;\n    };\n\n    return modify(tree);\n  }\n\n  return transformer;\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/introduction/MarkDonwExtesnion/reamark-hclass.js"],"names":["vFile","require","module","exports","attacher","newFileFrom","vfile","contents","pattern","processor","transformer","tree","file","inlineMethods","Parser","prototype","blockMethods","modify","node","console","log","parent","children","map"],"mappings":"AAAA;AACA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AAGAC,MAAM,CAACC,OAAP,GAAiBC,QAAjB;;AAEA,MAAMC,WAAW,GAAG,CAACC,KAAD,EAAQC,QAAR,KAAqB;AACrC,SAAOP,KAAK,CAAC,EAAC,GAAGM,KAAJ;AAAWC,IAAAA,QAAQ,EAAEA;AAArB,GAAD,CAAZ;AACH,CAFD;;AAIA,SAASH,QAAT,GAAoB;AACjB;AACC,QAAMI,OAAO,GAAG,WAAhB;AACA,QAAMC,SAAS,GAAG,IAAlB;;AACA,WAASC,WAAT,CAAqBC,IAArB,EAA2BC,IAA3B,EAAiC;AAC7B,QAAIC,aAAa,GAAEJ,SAAS,CAACK,MAAV,CAAiBC,SAAjB,CAA2BF,aAA9C;AACA,QAAIG,YAAY,GAAGP,SAAS,CAACK,MAAV,CAAiBC,SAAjB,CAA2BC,YAA9C,CAF6B,CAI9B;;AAEC,UAAMC,MAAM,GAAGC,IAAI,IAAI;AACnBC,MAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyBF,IAAzB;AACA,UAAIG,MAAM,GAAGH,IAAb;AACA,UAAG,CAACA,IAAI,CAACI,QAAT,EAAmB,OAAOJ,IAAP;AACnB,YAAMI,QAAQ,GAAGJ,IAAI,CAACI,QAAL,CAAcC,GAAd,CAAmBL,IAAI,IAAI,CACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH,OAjBgB,CAAjB,CAJmB,CAsBrB;;AACEA,MAAAA,IAAI,CAACI,QAAL,GAAgBA,QAAhB;AACA,aAAOJ,IAAP;AACH,KAzBD;;AA2BA,WAAOD,MAAM,CAACN,IAAD,CAAb;AAGH;;AAED,SAAOD,WAAP;AACH","sourcesContent":["//const map = require('unist-util-map');\r\nconst vFile = require('vfile');\r\n\r\n\r\nmodule.exports = attacher\r\n\r\nconst newFileFrom = (vfile, contents) => {\r\n    return vFile({...vfile, contents: contents})\r\n}\r\n\r\nfunction attacher() {\r\n   // console.log(\"the this\", this.Parser);\r\n    const pattern = /{\\.(\\w+)}/;\r\n    const processor = this;\r\n    function transformer(tree, file) {\r\n        let inlineMethods =processor.Parser.prototype.inlineMethods;\r\n        let blockMethods = processor.Parser.prototype.blockMethods;\r\n\r\n       // console.log(\"before modification\", tree)\r\n\r\n        const modify = node => {\r\n            console.log(\"in modify\", node)\r\n            let parent = node;\r\n            if(!node.children) return node;\r\n            const children = node.children.map( node => {\r\n                // if(node.type !== \"text\") return modify(node);\r\n                // console.log(\"node in\", node)\r\n                // let match = pattern.exec(node.value);\r\n                // if(!match) return node;\r\n                // const value = node.value.replace(match[0], \"\");\r\n                // const subNodes = processor.parse(newFileFrom(file, value))?.children;\r\n                // // console.log(\"parnet subnodes\", parent, subNodes)\r\n                // if(subNodes.some( subNode => subNode.type === \"thematicBreak\")\r\n                //     && parent.type === \"paragraph\"){\r\n                //     parent = subNodes.find( subNode => subNode.type === \"thematicBreak\");\r\n                //     parent.className = match[1];\r\n                //     parent.position = node.position;\r\n                //     parent.position.end.column-=match[0].length;\r\n                //     parent.position.end.offset-=match[0].length;\r\n                //\r\n                // }\r\n            })\r\n          //  node = parent;\r\n            node.children = children;\r\n            return node;\r\n        }\r\n\r\n        return modify(tree);\r\n\r\n\r\n    }\r\n\r\n    return transformer\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}