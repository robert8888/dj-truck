{"ast":null,"code":"var peakMeters={setUpSampleBuffers:function setUpSampleBuffers(channelName){var fftSize=this.audioNodes.channels[channelName].analyserNode.fftSize;this.sampleBuffers.channels[channelName]=new Float32Array(fftSize);},getChannelPeakMeter:function getChannelPeakMeter(channelName){var _this$audioNodes,_this$audioNodes$chan;var analyser=(_this$audioNodes=this.audioNodes)===null||_this$audioNodes===void 0?void 0:(_this$audioNodes$chan=_this$audioNodes.channels[channelName])===null||_this$audioNodes$chan===void 0?void 0:_this$audioNodes$chan.analyserNode;if(!analyser){return[];}var sampleBuffer=this.sampleBuffers.channels[channelName];if(!sampleBuffer){return[];}return this.getPeakData(analyser,sampleBuffer);},getMasterPeakMetter:function getMasterPeakMetter(part){var main=this.audioNodes.channels['main'];var buffers=this.sampleBuffers.channels['main'];if(!buffers){buffers=this.sampleBuffers.channels[\"main\"]={};}if(part===\"pre\"){if(!buffers.pre){var fftSize=main.preAnalyserNode.fftSize;buffers.pre=new Float32Array(fftSize);}return this.getPeakData(main.preAnalyserNode,buffers.pre);}else if(part===\"post\"){if(!buffers.post){var _fftSize=main.preAnalyserNode.fftSize;buffers.post=new Float32Array(_fftSize);}var peak=this.getPeakDataComplex(main.postAnalyserNode,buffers.post);//store value to get possibility to consume it by recorder\nthis.currentPeakMinMax=peak.minMax;return peak;}},getPeakData:function getPeakData(analyser,sampleBuffer){analyser.getFloatTimeDomainData(sampleBuffer);var peakPower=0;for(var i=0;i<sampleBuffer.length;i++){var power=Math.pow(sampleBuffer[i],2);// if statement is a litlebit faster that Math.max\npeakPower=power>peakPower?power:peakPower;}var peakPowerDecibels=10*Math.log10(peakPower);return{peakdB:peakPowerDecibels};},getPeakDataComplex:function getPeakDataComplex(analyser,sampleBuffer){analyser.getFloatTimeDomainData(sampleBuffer);var minMax=[Infinity,-Infinity];// [min, max]\n//average \n// let sumOfSquares = 0;\n// for (let i = 0; i < sampleBuffer.length; i++) {\n//     sumOfSquares += sampleBuffer[i] ** 2;\n// }\n// const avgPowerDecibels = 10 * Math.log10(sumOfSquares / sampleBuffer.length);\n//peak \nvar peakPower=0;for(var i=0;i<sampleBuffer.length;i++){minMax[0]=Math.min(minMax[0],sampleBuffer[i]);minMax[1]=Math.max(minMax[1],sampleBuffer[i]);//-----------------------------------------------\nvar power=Math.pow(sampleBuffer[i],2);// if statement is a litlebit faster that Math.max\npeakPower=power>peakPower?power:peakPower;}var peakPowerDecibels=10*Math.log10(peakPower);return{//avgdB: avgPowerDecibels,\npeakdB:peakPowerDecibels,minMax:minMax};}};export default peakMeters;","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/console/core/console/mixer/peakMeters.js"],"names":["peakMeters","setUpSampleBuffers","channelName","fftSize","audioNodes","channels","analyserNode","sampleBuffers","Float32Array","getChannelPeakMeter","analyser","sampleBuffer","getPeakData","getMasterPeakMetter","part","main","buffers","pre","preAnalyserNode","post","peak","getPeakDataComplex","postAnalyserNode","currentPeakMinMax","minMax","getFloatTimeDomainData","peakPower","i","length","power","peakPowerDecibels","Math","log10","peakdB","Infinity","min","max"],"mappings":"AAAA,GAAMA,CAAAA,UAAU,CAAG,CAEfC,kBAFe,6BAEIC,WAFJ,CAEiB,CAC5B,GAAIC,CAAAA,OAAO,CAAG,KAAKC,UAAL,CAAgBC,QAAhB,CAAyBH,WAAzB,EAAsCI,YAAtC,CAAmDH,OAAjE,CACA,KAAKI,aAAL,CAAmBF,QAAnB,CAA4BH,WAA5B,EAA2C,GAAIM,CAAAA,YAAJ,CAAiBL,OAAjB,CAA3C,CACH,CALc,CAOfM,mBAPe,8BAOKP,WAPL,CAOkB,4CAC7B,GAAIQ,CAAAA,QAAQ,mBAAG,KAAKN,UAAR,kEAAG,iBAAiBC,QAAjB,CAA0BH,WAA1B,CAAH,gDAAG,sBAAwCI,YAAvD,CACA,GAAI,CAACI,QAAL,CAAe,CACX,MAAO,EAAP,CACH,CACD,GAAIC,CAAAA,YAAY,CAAG,KAAKJ,aAAL,CAAmBF,QAAnB,CAA4BH,WAA5B,CAAnB,CACA,GAAI,CAACS,YAAL,CAAmB,CACf,MAAO,EAAP,CACH,CACD,MAAO,MAAKC,WAAL,CAAiBF,QAAjB,CAA2BC,YAA3B,CAAP,CACH,CAjBc,CAmBfE,mBAnBe,8BAmBKC,IAnBL,CAmBU,CACrB,GAAMC,CAAAA,IAAI,CAAG,KAAKX,UAAL,CAAgBC,QAAhB,CAAyB,MAAzB,CAAb,CACA,GAAIW,CAAAA,OAAO,CAAG,KAAKT,aAAL,CAAmBF,QAAnB,CAA4B,MAA5B,CAAd,CACA,GAAG,CAACW,OAAJ,CAAY,CACRA,OAAO,CAAG,KAAKT,aAAL,CAAmBF,QAAnB,CAA4B,MAA5B,EAAsC,EAAhD,CACH,CACD,GAAGS,IAAI,GAAK,KAAZ,CAAkB,CACd,GAAG,CAACE,OAAO,CAACC,GAAZ,CAAgB,CACZ,GAAMd,CAAAA,OAAO,CAAGY,IAAI,CAACG,eAAL,CAAqBf,OAArC,CACAa,OAAO,CAACC,GAAR,CAAc,GAAIT,CAAAA,YAAJ,CAAiBL,OAAjB,CAAd,CACH,CACD,MAAO,MAAKS,WAAL,CAAiBG,IAAI,CAACG,eAAtB,CAAuCF,OAAO,CAACC,GAA/C,CAAP,CACH,CAND,IAMO,IAAGH,IAAI,GAAK,MAAZ,CAAmB,CACtB,GAAG,CAACE,OAAO,CAACG,IAAZ,CAAiB,CACb,GAAMhB,CAAAA,QAAO,CAAGY,IAAI,CAACG,eAAL,CAAqBf,OAArC,CACAa,OAAO,CAACG,IAAR,CAAe,GAAIX,CAAAA,YAAJ,CAAiBL,QAAjB,CAAf,CACH,CACD,GAAMiB,CAAAA,IAAI,CAAG,KAAKC,kBAAL,CAAwBN,IAAI,CAACO,gBAA7B,CAA+CN,OAAO,CAACG,IAAvD,CAAb,CACA;AACA,KAAKI,iBAAL,CAAyBH,IAAI,CAACI,MAA9B,CACA,MAAOJ,CAAAA,IAAP,CACH,CACJ,CAzCc,CA6CfR,WA7Ce,sBA6CHF,QA7CG,CA6COC,YA7CP,CA6CqB,CAChCD,QAAQ,CAACe,sBAAT,CAAgCd,YAAhC,EAEA,GAAIe,CAAAA,SAAS,CAAG,CAAhB,CACA,IAAK,GAAIC,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGhB,YAAY,CAACiB,MAAjC,CAAyCD,CAAC,EAA1C,CAA8C,CAC1C,GAAME,CAAAA,KAAK,UAAGlB,YAAY,CAACgB,CAAD,CAAf,CAAsB,CAAtB,CAAX,CACA;AACAD,SAAS,CAAIG,KAAK,CAAGH,SAAT,CAAsBG,KAAtB,CAA8BH,SAA1C,CACH,CACD,GAAMI,CAAAA,iBAAiB,CAAG,GAAKC,IAAI,CAACC,KAAL,CAAWN,SAAX,CAA/B,CAEA,MAAO,CACHO,MAAM,CAAEH,iBADL,CAAP,CAGH,CA3Dc,CA6DfT,kBA7De,6BA6DIX,QA7DJ,CA6DcC,YA7Dd,CA6D2B,CACtCD,QAAQ,CAACe,sBAAT,CAAgCd,YAAhC,EAGA,GAAIa,CAAAA,MAAM,CAAG,CAACU,QAAD,CAAW,CAACA,QAAZ,CAAb,CAAoC;AAEpC;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA,GAAIR,CAAAA,SAAS,CAAG,CAAhB,CACA,IAAK,GAAIC,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGhB,YAAY,CAACiB,MAAjC,CAAyCD,CAAC,EAA1C,CAA8C,CAC1CH,MAAM,CAAC,CAAD,CAAN,CAAYO,IAAI,CAACI,GAAL,CAASX,MAAM,CAAC,CAAD,CAAf,CAAoBb,YAAY,CAACgB,CAAD,CAAhC,CAAZ,CACAH,MAAM,CAAC,CAAD,CAAN,CAAYO,IAAI,CAACK,GAAL,CAASZ,MAAM,CAAC,CAAD,CAAf,CAAoBb,YAAY,CAACgB,CAAD,CAAhC,CAAZ,CACA;AACA,GAAME,CAAAA,KAAK,UAAGlB,YAAY,CAACgB,CAAD,CAAf,CAAsB,CAAtB,CAAX,CACA;AACAD,SAAS,CAAIG,KAAK,CAAGH,SAAT,CAAsBG,KAAtB,CAA8BH,SAA1C,CACH,CACD,GAAMI,CAAAA,iBAAiB,CAAG,GAAKC,IAAI,CAACC,KAAL,CAAWN,SAAX,CAA/B,CAEA,MAAO,CACF;AACDO,MAAM,CAAEH,iBAFL,CAGHN,MAAM,CAAEA,MAHL,CAAP,CAKH,CA7Fc,CAAnB,CAgGA,cAAexB,CAAAA,UAAf","sourcesContent":["const peakMeters = {\r\n\r\n    setUpSampleBuffers(channelName) {\r\n        let fftSize = this.audioNodes.channels[channelName].analyserNode.fftSize;\r\n        this.sampleBuffers.channels[channelName] = new Float32Array(fftSize);\r\n    },\r\n\r\n    getChannelPeakMeter(channelName) {\r\n        let analyser = this.audioNodes?.channels[channelName]?.analyserNode\r\n        if (!analyser) {\r\n            return [];\r\n        }\r\n        let sampleBuffer = this.sampleBuffers.channels[channelName];\r\n        if (!sampleBuffer) {\r\n            return [];\r\n        }\r\n        return this.getPeakData(analyser, sampleBuffer)\r\n    },\r\n\r\n    getMasterPeakMetter(part){\r\n        const main = this.audioNodes.channels['main'];\r\n        let buffers = this.sampleBuffers.channels['main'];\r\n        if(!buffers){\r\n            buffers = this.sampleBuffers.channels[\"main\"] = {};\r\n        }\r\n        if(part === \"pre\"){\r\n            if(!buffers.pre){\r\n                const fftSize = main.preAnalyserNode.fftSize;\r\n                buffers.pre = new Float32Array(fftSize);\r\n            }\r\n            return this.getPeakData(main.preAnalyserNode, buffers.pre);\r\n        } else if(part === \"post\"){\r\n            if(!buffers.post){\r\n                const fftSize = main.preAnalyserNode.fftSize;\r\n                buffers.post = new Float32Array(fftSize);\r\n            }\r\n            const peak = this.getPeakDataComplex(main.postAnalyserNode, buffers.post);\r\n            //store value to get possibility to consume it by recorder\r\n            this.currentPeakMinMax = peak.minMax;\r\n            return peak;\r\n        }\r\n    },\r\n\r\n    \r\n    \r\n    getPeakData(analyser, sampleBuffer) {\r\n        analyser.getFloatTimeDomainData(sampleBuffer);\r\n\r\n        let peakPower = 0;\r\n        for (let i = 0; i < sampleBuffer.length; i++) {\r\n            const power = sampleBuffer[i] ** 2;\r\n            // if statement is a litlebit faster that Math.max\r\n            peakPower = (power > peakPower) ? power : peakPower;\r\n        }\r\n        const peakPowerDecibels = 10 * Math.log10(peakPower);\r\n\r\n        return {\r\n            peakdB: peakPowerDecibels,\r\n        }\r\n    },\r\n\r\n    getPeakDataComplex(analyser, sampleBuffer){\r\n        analyser.getFloatTimeDomainData(sampleBuffer);\r\n\r\n        \r\n        let minMax = [Infinity, -Infinity]; // [min, max]\r\n\r\n        //average \r\n        // let sumOfSquares = 0;\r\n        // for (let i = 0; i < sampleBuffer.length; i++) {\r\n        //     sumOfSquares += sampleBuffer[i] ** 2;\r\n        // }\r\n\r\n        // const avgPowerDecibels = 10 * Math.log10(sumOfSquares / sampleBuffer.length);\r\n\r\n        //peak \r\n\r\n        let peakPower = 0;\r\n        for (let i = 0; i < sampleBuffer.length; i++) {\r\n            minMax[0] = Math.min(minMax[0], sampleBuffer[i]);\r\n            minMax[1] = Math.max(minMax[1], sampleBuffer[i]);\r\n            //-----------------------------------------------\r\n            const power = sampleBuffer[i] ** 2;\r\n            // if statement is a litlebit faster that Math.max\r\n            peakPower = (power > peakPower) ? power : peakPower;\r\n        }\r\n        const peakPowerDecibels = 10 * Math.log10(peakPower);\r\n\r\n        return {\r\n             //avgdB: avgPowerDecibels,\r\n            peakdB: peakPowerDecibels,\r\n            minMax: minMax,\r\n        }\r\n    }\r\n}\r\n\r\nexport default peakMeters;"]},"metadata":{},"sourceType":"module"}