{"ast":null,"code":"import store from \"./../../../../../store\";\nimport { recording, recordingRquestFail } from \"./../../../../../actions\";\nimport STATUS from \"./../observer/STATUS\";\nimport io from \"socket.io-client\";\nconst recorder_api_url = process.env.REACT_APP_RECORDER_API;\nexport default class Recorder {\n  constructor(mixer) {\n    this.mixer = mixer;\n    const streamDestination = this.mixer.audioNodes.channels['main'].recorderStremDestination;\n    this.mediaRecorder = new MediaRecorder(streamDestination.stream, {\n      mimeType: 'audio/webm;codecs=opus'\n    });\n    console.log(recorder_api_url);\n  }\n\n  action(status, param) {\n    switch (status) {\n      case STATUS.RECORD_START:\n        {\n          this.startRecording(param);\n          break;\n        }\n\n      case STATUS.RECORD_END:\n        {\n          this.endRecording();\n          break;\n        }\n    }\n  }\n\n  startRecording({\n    id,\n    recName\n  }) {\n    console.log(\"im start recording\");\n    const token = store.getState().user.token;\n\n    if (!token) {\n      return;\n    }\n\n    const socket = io.connect(recorder_api_url.replace('http', 'ws').replace('https', 'wss'));\n    socket.on(\"connect\", () => {\n      console.log(\"we have connection\");\n      socket.emit('authentication', {\n        token: token\n      });\n      socket.on('authenticated', () => {\n        console.log('auth');\n        socket.emit(\"record_details\", {\n          recId: id,\n          recName: recName\n        });\n      });\n      socket.on('recorder_ready', () => {\n        console.log('ready');\n\n        this.mediaRecorder.ondataavailable = e => {\n          console.log(e.data);\n          socket.emit('record_chunk', e.data);\n        };\n\n        this.mediaRecorder.addEventListener('stop', () => {\n          socket.close();\n        });\n        this.mediaRecorder.start(1000); //DISPATCH READY\n\n        store.dispatch(recording());\n      });\n      socket.on('connect_error', () => {\n        store.dispatch(recordingRquestFail());\n      });\n    });\n  }\n\n  endRecording() {\n    console.log(\"im finish recoriding\");\n\n    if (this.mediaRecorder.state !== 'inactive') {\n      this.mediaRecorder.stop();\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/console/core/console/mixer/recorder.js"],"names":["store","recording","recordingRquestFail","STATUS","io","recorder_api_url","process","env","REACT_APP_RECORDER_API","Recorder","constructor","mixer","streamDestination","audioNodes","channels","recorderStremDestination","mediaRecorder","MediaRecorder","stream","mimeType","console","log","action","status","param","RECORD_START","startRecording","RECORD_END","endRecording","id","recName","token","getState","user","socket","connect","replace","on","emit","recId","ondataavailable","e","data","addEventListener","close","start","dispatch","state","stop"],"mappings":"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","sourcesContent":["import store from \"./../../../../../store\";\r\nimport { recording, recordingRquestFail } from \"./../../../../../actions\"\r\nimport STATUS from \"./../observer/STATUS\";\r\nimport io from \"socket.io-client\";\r\nconst recorder_api_url = process.env.REACT_APP_RECORDER_API\r\n\r\n\r\nexport default class Recorder {\r\n    constructor(mixer) {\r\n        this.mixer = mixer;\r\n\r\n        const streamDestination = this.mixer.audioNodes.channels['main'].recorderStremDestination;\r\n        this.mediaRecorder = new MediaRecorder(streamDestination.stream, {\r\n            mimeType: 'audio/webm;codecs=opus',\r\n        });\r\n\r\n        console.log(recorder_api_url)\r\n    }\r\n\r\n\r\n\r\n    action(status, param) {\r\n        switch (status) {\r\n            case STATUS.RECORD_START: {\r\n                this.startRecording(param);\r\n                break;\r\n            }\r\n            case STATUS.RECORD_END: {\r\n                this.endRecording()\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    startRecording({id, recName}) {\r\n        console.log(\"im start recording\");\r\n        const token = store.getState().user.token;\r\n        if (!token) {\r\n            return;\r\n        }\r\n\r\n\r\n        const socket = io.connect(\r\n            recorder_api_url.replace('http', 'ws').replace('https', 'wss'));\r\n\r\n        socket.on(\"connect\", () => {\r\n            console.log(\"we have connection\")\r\n            socket.emit('authentication', { token: token });\r\n            socket.on('authenticated', () => {\r\n                console.log('auth')\r\n                socket.emit(\"record_details\", {\r\n                    recId: id,\r\n                    recName: recName,\r\n                })\r\n            })\r\n            socket.on('recorder_ready', () => {\r\n                console.log('ready')\r\n\r\n                this.mediaRecorder.ondataavailable = (e) => {\r\n                    console.log(e.data)\r\n                    socket.emit('record_chunk', e.data)\r\n                }\r\n\r\n                this.mediaRecorder.addEventListener('stop', () => {\r\n                    socket.close()\r\n                })\r\n\r\n                this.mediaRecorder.start(1000);\r\n                //DISPATCH READY\r\n                store.dispatch(recording());\r\n            })\r\n\r\n            socket.on('connect_error', () => {\r\n                store.dispatch(recordingRquestFail())\r\n            })\r\n        })\r\n    }\r\n\r\n    endRecording() {\r\n        console.log(\"im finish recoriding\")\r\n        if (this.mediaRecorder.state !== 'inactive') {\r\n            this.mediaRecorder.stop();\r\n        }\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}