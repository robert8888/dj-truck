{"ast":null,"code":"import { ACTIONS } from \"./../../actions\";\nimport { produce } from \"imer\";\nconst deck = {\n  track: {\n    title: \"\",\n    bpm: 0,\n    offset: 0,\n    quality: \"\",\n    duration: \"\",\n    source: \"\",\n    sourceId: \"\",\n    id: \"\",\n    thumbnail: {}\n  },\n  // \n  playBackState: {\n    ready: false,\n    loadingProgress: 0,\n    paused: true,\n    cuePoint: 0,\n    cueActive: false,\n    pitch: 0,\n    timeLeft: null,\n    offset: null,\n    // move this to track now is in both\n    sync: false,\n    loop: false\n  },\n  deckState: {\n    loopLength: -1\n  }\n};\nconst initState = {\n  master: null,\n  //A, B ....\n  channel: {\n    A: { ...deck\n    },\n    B: { ...deck\n    }\n  }\n};\n\nfunction nextState(part) {\n  return (state, destination, haveToBeReady, variables) => {\n    if (!state.channel[destination]) return state;\n    if (haveToBeReady && !state.channel[destination].playBackState.ready) return state;\n    const nextState = produce(state, draftState => {\n      for (let [variable, value] of Object.entries(variables)) {\n        switch (part) {\n          case \"playBackState\":\n            {\n              draftState.channel[destination].playBackState[variable] = value;\n              break;\n            }\n\n          case \"track\":\n            {\n              draftState.channel[destination].track[variable] = value;\n              break;\n            }\n\n          case \"deckState\":\n            {\n              draftState.channel[destination].deckState[variable] = value;\n              break;\n            }\n\n          default:\n            break;\n        }\n      }\n    });\n    return nextState;\n  };\n}\n\nconst nextPlayBackState = nextState('playBackState');\nconst nextTrackState = nextState('track');\nconst nextDeckState = nextState('deckState');\n\nfunction consoleReducer(state = initState, action) {\n  switch (action.type) {\n    case ACTIONS.LOAD_TRACK:\n      {\n        const nextTrack = action.track;\n\n        if (state.channel[action.destination].track.id === nextTrack.id) {\n          return state;\n        }\n\n        return produce(state, draftState => {\n          draftState.channel[action.destination].track = {\n            title: nextTrack.title,\n            bpm: nextTrack.bpm || 0,\n            offset: nextTrack.offset,\n            quality: nextTrack.quality,\n            duration: nextTrack.duration,\n            source: nextTrack.source,\n            id: nextTrack.id,\n            sourceId: nextTrack.sourceId,\n            thumbnail: nextTrack.thumbnail\n          }; //reseting  play back state\n\n          draftState.channel[action.destination].playBackState = { ...initState.channel[action.destination].playBackState,\n            offset: nextTrack.offset,\n            loopLength: state.channel[action.destination].playBackState.loopLength\n          };\n        });\n      }\n\n    case ACTIONS.SET_LOADING_PROGRESS:\n      {\n        return nextPlayBackState(state, action.destination, false, {\n          loadingProgress: action.value\n        });\n      }\n\n    case ACTIONS.SET_READY:\n      {\n        return nextPlayBackState(state, action.destination, false, {\n          ready: action.value\n        });\n      }\n\n    case ACTIONS.SET_PITCH:\n      {\n        return nextPlayBackState(state, action.destination, false, {\n          pitch: action.pitch\n        });\n      }\n\n    case ACTIONS.INCREASE_PITCH:\n      {\n        var _state$channel$action, _state$channel$action2;\n\n        let prevPitch = (_state$channel$action = state.channel[action.destination]) === null || _state$channel$action === void 0 ? void 0 : (_state$channel$action2 = _state$channel$action.playBackState) === null || _state$channel$action2 === void 0 ? void 0 : _state$channel$action2.pitch;\n        if (prevPitch === undefined) return state;\n        return nextPlayBackState(state, action.destination, false, {\n          pitch: prevPitch + action.amount\n        });\n      }\n\n    case ACTIONS.DECREASE_PITCH:\n      {\n        var _state$channel$action3, _state$channel$action4;\n\n        let prevPitch = (_state$channel$action3 = state.channel[action.destination]) === null || _state$channel$action3 === void 0 ? void 0 : (_state$channel$action4 = _state$channel$action3.playBackState) === null || _state$channel$action4 === void 0 ? void 0 : _state$channel$action4.pitch;\n        if (prevPitch === undefined) return state;\n        return nextPlayBackState(state, action.destination, false, {\n          pitch: prevPitch - action.amount\n        });\n      }\n\n    case ACTIONS.TOGGLE_PLAY:\n      {\n        var _state$channel$action5, _state$channel$action6;\n\n        let prevPause = (_state$channel$action5 = state.channel[action.destination]) === null || _state$channel$action5 === void 0 ? void 0 : (_state$channel$action6 = _state$channel$action5.playBackState) === null || _state$channel$action6 === void 0 ? void 0 : _state$channel$action6.paused;\n        prevPause = prevPause === undefined ? true : prevPause;\n        return nextPlayBackState(state, action.destination, true, {\n          paused: !prevPause\n        });\n      }\n\n    case ACTIONS.SET_TIME_LEFT:\n      {\n        return nextPlayBackState(state, action.destination, true, {\n          timeLeft: action.timeLeft\n        });\n      }\n\n    case ACTIONS.TOGGLE_CUE:\n      {\n        var _state$channel$action7, _state$channel$action8;\n\n        let prevCue = (_state$channel$action7 = state.channel[action.destination]) === null || _state$channel$action7 === void 0 ? void 0 : (_state$channel$action8 = _state$channel$action7.playBackState) === null || _state$channel$action8 === void 0 ? void 0 : _state$channel$action8.cueActive;\n        prevCue = prevCue === undefined ? false : prevCue;\n        return nextPlayBackState(state, action.destination, true, {\n          cueActive: !prevCue\n        });\n      }\n\n    case ACTIONS.CANCEL_CUE_AND_PLAY:\n      {\n        return nextPlayBackState(state, action.destination, true, {\n          cueActive: false,\n          paused: false\n        });\n      }\n\n    case ACTIONS.SET_CUE_POINT:\n      {\n        return nextPlayBackState(state, action.destination, true, {\n          cuePoint: action.position\n        });\n      }\n\n    case ACTIONS.SET_MASTER:\n      {\n        const nextMaster = action.destination === state.master ? \"\" : action.destination;\n        return produce(state, draftState => draftState.master = nextMaster);\n      }\n\n    case ACTIONS.TOGGLE_SYNC:\n      {\n        var _state$channel$action9, _state$channel$action10, _state$channel$action11, _state$channel$action12;\n\n        let prevSync = (_state$channel$action9 = state.channel[action.destination]) === null || _state$channel$action9 === void 0 ? void 0 : (_state$channel$action10 = _state$channel$action9.playBackState) === null || _state$channel$action10 === void 0 ? void 0 : _state$channel$action10.sync;\n        prevSync = prevSync === undefined ? false : prevSync;\n        let offset = (_state$channel$action11 = state.channel[action.destination]) === null || _state$channel$action11 === void 0 ? void 0 : (_state$channel$action12 = _state$channel$action11.playBackState) === null || _state$channel$action12 === void 0 ? void 0 : _state$channel$action12.offset;\n        if (!offset && !prevSync) return state; // can't turn on sync if offset is not calculated \n\n        return nextPlayBackState(state, action.destination, true, {\n          sync: !prevSync\n        });\n      }\n\n    case ACTIONS.SET_SYNC:\n      {\n        var _state$channel$action13, _state$channel$action14;\n\n        let offset = (_state$channel$action13 = state.channel[action.destination]) === null || _state$channel$action13 === void 0 ? void 0 : (_state$channel$action14 = _state$channel$action13.playBackState) === null || _state$channel$action14 === void 0 ? void 0 : _state$channel$action14.offset;\n        if (!offset) return state; // can't turn on sync if offset is not calculated \n\n        return nextPlayBackState(state, action.destination, true, {\n          sync: action.value\n        });\n      }\n\n    case ACTIONS.PL_SET_BPM_AND_OFFSET:\n      {\n        if (action.bpm === undefined || action.bpm === null || action.offset === undefined || action.offset === null) {\n          return state;\n        }\n\n        let channels = [];\n\n        for (let channelName of Object.keys(state.channel)) {\n          if (state.channel[channelName].track.id === action.id) {\n            channels.push(channelName);\n          }\n        }\n\n        if (channels.length === 0) return state;\n        return channels.reduce((prevState, channelName) => {\n          let trackState = nextTrackState(prevState, channelName, false, {\n            bpm: action.bpm,\n            offset: action.offset\n          });\n          return nextPlayBackState(trackState, channelName, false, {\n            offset: action.offset\n          });\n        }, state);\n      }\n\n    case ACTIONS.SET_LOOP:\n      {\n        const paused = state.channel[action.destination].playBackState.paused;\n        const bpm = state.channel[action.destination].track.bpm;\n        const offset = state.channel[action.destination].playBackState.offset;\n        let newValue = action.value;\n\n        if (paused || !bpm || offset === null) {\n          newValue = false;\n        }\n\n        return nextPlayBackState(state, action.destination, true, {\n          loop: newValue\n        });\n      }\n\n    case ACTIONS.SET_LOOP_LENGTH:\n      {\n        return nextDeckState(state, action.destination, false, {\n          loopLength: action.value\n        });\n      }\n\n    default:\n      return state;\n  }\n}\n\nexport default consoleReducer;","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/reducers/console/decksReducer.js"],"names":["ACTIONS","produce","deck","track","title","bpm","offset","quality","duration","source","sourceId","id","thumbnail","playBackState","ready","loadingProgress","paused","cuePoint","cueActive","pitch","timeLeft","sync","loop","deckState","loopLength","initState","master","channel","A","B","nextState","part","state","destination","haveToBeReady","variables","draftState","variable","value","Object","entries","nextPlayBackState","nextTrackState","nextDeckState","consoleReducer","action","type","LOAD_TRACK","nextTrack","SET_LOADING_PROGRESS","SET_READY","SET_PITCH","INCREASE_PITCH","prevPitch","undefined","amount","DECREASE_PITCH","TOGGLE_PLAY","prevPause","SET_TIME_LEFT","TOGGLE_CUE","prevCue","CANCEL_CUE_AND_PLAY","SET_CUE_POINT","position","SET_MASTER","nextMaster","TOGGLE_SYNC","prevSync","SET_SYNC","PL_SET_BPM_AND_OFFSET","channels","channelName","keys","push","length","reduce","prevState","trackState","SET_LOOP","newValue","SET_LOOP_LENGTH"],"mappings":"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","sourcesContent":["import { ACTIONS } from \"./../../actions\";\r\nimport { produce } from \"imer\";\r\n\r\nconst deck = {\r\n    track: {\r\n        title: \"\",\r\n        bpm: 0,\r\n        offset: 0,\r\n        quality: \"\",\r\n        duration: \"\",\r\n        source: \"\",\r\n        sourceId: \"\",\r\n        id: \"\",\r\n        thumbnail: {}\r\n    }, // \r\n    playBackState: {\r\n        ready: false,\r\n        loadingProgress: 0,\r\n        paused: true,\r\n        cuePoint: 0,\r\n        cueActive: false,\r\n        pitch: 0,\r\n        timeLeft: null,\r\n        offset: null, // move this to track now is in both\r\n        sync: false,\r\n        loop: false,\r\n    },\r\n    deckState: {\r\n        loopLength: -1,\r\n    }\r\n}\r\n\r\n\r\nconst initState = {\r\n    master: null,//A, B ....\r\n    channel: {\r\n        A: {\r\n            ...deck\r\n        },\r\n        B: {\r\n            ...deck\r\n        }\r\n    },\r\n}\r\n\r\nfunction nextState(part) {\r\n    return (state, destination, haveToBeReady, variables) => {\r\n\r\n        if (!state.channel[destination]) return state;\r\n        if (haveToBeReady && !state.channel[destination].playBackState.ready) return state;\r\n\r\n        const nextState = produce(state, (draftState) => {\r\n            for (let [variable, value] of Object.entries(variables)) {\r\n                switch (part) {\r\n                    case \"playBackState\": {\r\n                        draftState.channel[destination].playBackState[variable] = value;\r\n                        break;\r\n                    }\r\n                    case \"track\": {\r\n                        draftState.channel[destination].track[variable] = value;\r\n                        break;\r\n                    }\r\n                    case \"deckState\": {\r\n                        draftState.channel[destination].deckState[variable] = value;\r\n                        break;\r\n                    }\r\n                    default: break;\r\n                }\r\n            }\r\n        })\r\n\r\n        return nextState;\r\n    }\r\n}\r\n\r\nconst nextPlayBackState = nextState('playBackState');\r\nconst nextTrackState = nextState('track');\r\nconst nextDeckState = nextState('deckState');\r\n\r\n\r\n\r\nfunction consoleReducer(state = initState, action) {\r\n    switch (action.type) {\r\n        case ACTIONS.LOAD_TRACK: {\r\n\r\n            const nextTrack = action.track;\r\n            if (state.channel[action.destination].track.id === nextTrack.id) {\r\n                return state;\r\n            }\r\n            return produce(state, draftState => {\r\n                draftState.channel[action.destination].track = {\r\n                    title: nextTrack.title,\r\n                    bpm: nextTrack.bpm || 0,\r\n                    offset: nextTrack.offset,\r\n                    quality: nextTrack.quality,\r\n                    duration: nextTrack.duration,\r\n                    source: nextTrack.source,\r\n                    id: nextTrack.id,\r\n                    sourceId: nextTrack.sourceId,\r\n                    thumbnail: nextTrack.thumbnail,\r\n                }\r\n                //reseting  play back state\r\n                draftState.channel[action.destination].playBackState = {\r\n                    ...initState.channel[action.destination].playBackState,\r\n                    offset: nextTrack.offset,\r\n                    loopLength: state.channel[action.destination].playBackState.loopLength,\r\n                }\r\n            })\r\n        }\r\n\r\n        case ACTIONS.SET_LOADING_PROGRESS: {\r\n            return nextPlayBackState(state, action.destination, false, { loadingProgress: action.value })\r\n        }\r\n\r\n        case ACTIONS.SET_READY: {\r\n            return nextPlayBackState(state, action.destination, false, { ready: action.value })\r\n        }\r\n\r\n        case ACTIONS.SET_PITCH: {\r\n            return nextPlayBackState(state, action.destination, false, { pitch: action.pitch })\r\n        }\r\n\r\n        case ACTIONS.INCREASE_PITCH: {\r\n            let prevPitch = state.channel[action.destination]?.playBackState?.pitch;\r\n            if (prevPitch === undefined) return state;\r\n            return nextPlayBackState(state, action.destination, false, { pitch: prevPitch + action.amount })\r\n        }\r\n\r\n        case ACTIONS.DECREASE_PITCH: {\r\n            let prevPitch = state.channel[action.destination]?.playBackState?.pitch;\r\n            if (prevPitch === undefined) return state;\r\n            return nextPlayBackState(state, action.destination, false, { pitch: prevPitch - action.amount })\r\n        }\r\n\r\n\r\n        case ACTIONS.TOGGLE_PLAY: {\r\n            let prevPause = state.channel[action.destination]?.playBackState?.paused;\r\n            prevPause = (prevPause === undefined) ? true : prevPause;\r\n            return nextPlayBackState(state, action.destination, true, { paused: !prevPause })\r\n        }\r\n\r\n        case ACTIONS.SET_TIME_LEFT: {\r\n            return nextPlayBackState(state, action.destination, true, { timeLeft: action.timeLeft })\r\n        }\r\n\r\n        case ACTIONS.TOGGLE_CUE: {\r\n            let prevCue = state.channel[action.destination]?.playBackState?.cueActive;\r\n            prevCue = (prevCue === undefined) ? false : prevCue;\r\n            return nextPlayBackState(state, action.destination, true, { cueActive: !prevCue })\r\n        }\r\n\r\n        case ACTIONS.CANCEL_CUE_AND_PLAY: {\r\n            return nextPlayBackState(state, action.destination, true, {\r\n                cueActive: false,\r\n                paused: false,\r\n            })\r\n        }\r\n\r\n        case ACTIONS.SET_CUE_POINT: {\r\n            return nextPlayBackState(state, action.destination, true, { cuePoint: action.position })\r\n        }\r\n\r\n\r\n        case ACTIONS.SET_MASTER: {\r\n            const nextMaster = (action.destination === state.master)\r\n                ? \"\"\r\n                : action.destination;\r\n            return produce(state, draftState => draftState.master = nextMaster)\r\n        }\r\n\r\n        case ACTIONS.TOGGLE_SYNC: {\r\n            let prevSync = state.channel[action.destination]?.playBackState?.sync;\r\n            prevSync = (prevSync === undefined) ? false : prevSync;\r\n            let offset = state.channel[action.destination]?.playBackState?.offset;\r\n            if (!offset && !prevSync) return state// can't turn on sync if offset is not calculated \r\n            return nextPlayBackState(state, action.destination, true, { sync: !prevSync })\r\n        }\r\n\r\n        case ACTIONS.SET_SYNC: {\r\n            let offset = state.channel[action.destination]?.playBackState?.offset;\r\n            if (!offset) return state;// can't turn on sync if offset is not calculated \r\n            return nextPlayBackState(state, action.destination, true, { sync: action.value });\r\n        }\r\n\r\n\r\n        case ACTIONS.PL_SET_BPM_AND_OFFSET: {\r\n            if(action.bpm === undefined || action.bpm === null ||\r\n               action.offset === undefined || action.offset === null){\r\n                return state;\r\n            }\r\n            let channels = [];\r\n            for (let channelName of Object.keys(state.channel)) {\r\n                if (state.channel[channelName].track.id === action.id) {\r\n                    channels.push(channelName);\r\n                }\r\n            }\r\n            if (channels.length === 0) return state;\r\n\r\n            return channels.reduce((prevState, channelName) => {\r\n                let trackState = nextTrackState(prevState, channelName, false, { bpm: action.bpm, offset:action.offset });\r\n                return nextPlayBackState(trackState, channelName, false, { offset: action.offset })\r\n            }, state);\r\n        }\r\n\r\n        case ACTIONS.SET_LOOP: {\r\n            const paused = state.channel[action.destination].playBackState.paused;\r\n            const bpm = state.channel[action.destination].track.bpm;\r\n            const offset = state.channel[action.destination].playBackState.offset;\r\n\r\n            let newValue = action.value;\r\n            if (paused || !bpm || offset === null) {\r\n                newValue = false;\r\n            }\r\n            return nextPlayBackState(state, action.destination, true, { loop: newValue });\r\n        }\r\n\r\n\r\n        case ACTIONS.SET_LOOP_LENGTH: {\r\n            return nextDeckState(state, action.destination, false, { loopLength: action.value });\r\n        }\r\n\r\n\r\n        default: return state;\r\n    }\r\n}\r\n\r\nexport default consoleReducer;\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}