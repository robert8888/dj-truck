{"ast":null,"code":"export function throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  wait = toNumber(wait) || 0;\n\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time; // Start the timer for the trailing edge.\n\n    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.\n\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    var time = now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    } // Restart the timer.\n\n\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n\n    return result;\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/src/utils/functions/lodash.js"],"names":["throttle","func","wait","options","leading","trailing","TypeError","FUNC_ERROR_TEXT","isObject","debounce","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","maxing","toNumber","nativeMax","invokeFunc","time","args","thisArg","undefined","apply","leadingEdge","setTimeout","timerExpired","remainingWait","timeSinceLastCall","timeSinceLastInvoke","timeWaiting","nativeMin","shouldInvoke","now","trailingEdge","cancel","clearTimeout","flush","debounced","isInvoking","arguments"],"mappings":"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","sourcesContent":["export function throttle(func, wait, options) {\r\n  var leading = true,\r\n      trailing = true;\r\n\r\n  if (typeof func != 'function') {\r\n    throw new TypeError(FUNC_ERROR_TEXT);\r\n  }\r\n  if (isObject(options)) {\r\n    leading = 'leading' in options ? !!options.leading : leading;\r\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\r\n  }\r\n  return debounce(func, wait, {\r\n    'leading': leading,\r\n    'maxWait': wait,\r\n    'trailing': trailing\r\n  });\r\n}\r\n\r\n\r\nfunction debounce(func, wait, options) {\r\n  var lastArgs,\r\n      lastThis,\r\n      maxWait,\r\n      result,\r\n      timerId,\r\n      lastCallTime,\r\n      lastInvokeTime = 0,\r\n      leading = false,\r\n      maxing = false,\r\n      trailing = true;\r\n\r\n  if (typeof func != 'function') {\r\n    throw new TypeError(FUNC_ERROR_TEXT);\r\n  }\r\n  wait = toNumber(wait) || 0;\r\n  if (isObject(options)) {\r\n    leading = !!options.leading;\r\n    maxing = 'maxWait' in options;\r\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\r\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\r\n  }\r\n\r\n  function invokeFunc(time) {\r\n    var args = lastArgs,\r\n        thisArg = lastThis;\r\n\r\n    lastArgs = lastThis = undefined;\r\n    lastInvokeTime = time;\r\n    result = func.apply(thisArg, args);\r\n    return result;\r\n  }\r\n\r\n  function leadingEdge(time) {\r\n    // Reset any `maxWait` timer.\r\n    lastInvokeTime = time;\r\n    // Start the timer for the trailing edge.\r\n    timerId = setTimeout(timerExpired, wait);\r\n    // Invoke the leading edge.\r\n    return leading ? invokeFunc(time) : result;\r\n  }\r\n\r\n  function remainingWait(time) {\r\n    var timeSinceLastCall = time - lastCallTime,\r\n        timeSinceLastInvoke = time - lastInvokeTime,\r\n        timeWaiting = wait - timeSinceLastCall;\r\n\r\n    return maxing\r\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\r\n      : timeWaiting;\r\n  }\r\n\r\n  function shouldInvoke(time) {\r\n    var timeSinceLastCall = time - lastCallTime,\r\n        timeSinceLastInvoke = time - lastInvokeTime;\r\n\r\n    // Either this is the first call, activity has stopped and we're at the\r\n    // trailing edge, the system time has gone backwards and we're treating\r\n    // it as the trailing edge, or we've hit the `maxWait` limit.\r\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\r\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\r\n  }\r\n\r\n  function timerExpired() {\r\n    var time = now();\r\n    if (shouldInvoke(time)) {\r\n      return trailingEdge(time);\r\n    }\r\n    // Restart the timer.\r\n    timerId = setTimeout(timerExpired, remainingWait(time));\r\n  }\r\n\r\n  function trailingEdge(time) {\r\n    timerId = undefined;\r\n\r\n    // Only invoke if we have `lastArgs` which means `func` has been\r\n    // debounced at least once.\r\n    if (trailing && lastArgs) {\r\n      return invokeFunc(time);\r\n    }\r\n    lastArgs = lastThis = undefined;\r\n    return result;\r\n  }\r\n\r\n  function cancel() {\r\n    if (timerId !== undefined) {\r\n      clearTimeout(timerId);\r\n    }\r\n    lastInvokeTime = 0;\r\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\r\n  }\r\n\r\n  function flush() {\r\n    return timerId === undefined ? result : trailingEdge(now());\r\n  }\r\n\r\n  function debounced() {\r\n    var time = now(),\r\n        isInvoking = shouldInvoke(time);\r\n\r\n    lastArgs = arguments;\r\n    lastThis = this;\r\n    lastCallTime = time;\r\n\r\n    if (isInvoking) {\r\n      if (timerId === undefined) {\r\n        return leadingEdge(lastCallTime);\r\n      }\r\n      if (maxing) {\r\n        // Handle invocations in a tight loop.\r\n        clearTimeout(timerId);\r\n        timerId = setTimeout(timerExpired, wait);\r\n        return invokeFunc(lastCallTime);\r\n      }\r\n    }\r\n    if (timerId === undefined) {\r\n      timerId = setTimeout(timerExpired, wait);\r\n    }\r\n    return result;\r\n  }\r\n  debounced.cancel = cancel;\r\n  debounced.flush = flush;\r\n  return debounced;\r\n}"]},"metadata":{},"sourceType":"module"}