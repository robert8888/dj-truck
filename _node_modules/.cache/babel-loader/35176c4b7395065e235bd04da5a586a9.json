{"ast":null,"code":"const peakMeters = {\n  setUpSampleBuffers(channelName) {\n    let fftSize = this.audioNodes.channels[channelName].analyserNode.fftSize;\n    this.sampleBuffers.channels[channelName] = new Float32Array(fftSize);\n  },\n\n  getChannelPeakMeter(channelName) {\n    var _this$audioNodes, _this$audioNodes$chan;\n\n    let analyser = (_this$audioNodes = this.audioNodes) === null || _this$audioNodes === void 0 ? void 0 : (_this$audioNodes$chan = _this$audioNodes.channels[channelName]) === null || _this$audioNodes$chan === void 0 ? void 0 : _this$audioNodes$chan.analyserNode;\n\n    if (!analyser) {\n      return [];\n    }\n\n    let sampleBuffer = this.sampleBuffers.channels[channelName];\n\n    if (!sampleBuffer) {\n      return [];\n    }\n\n    return this.getPeakData(analyser, sampleBuffer);\n  },\n\n  getMasterPeakMetter(part) {\n    const main = this.audioNodes.channels['main'];\n    let buffers = this.sampleBuffers.channels['main'];\n\n    if (!buffers) {\n      buffers = this.sampleBuffers.channels[\"main\"] = {};\n    }\n\n    if (part === \"pre\") {\n      if (!buffers.pre) {\n        const fftSize = main.preAnalyserNode.fftSize;\n        buffers.pre = new Float32Array(fftSize);\n      }\n\n      return this.getPeakData(main.preAnalyserNode, buffers.pre);\n    } else if (part === \"post\") {\n      if (!buffers.post) {\n        const fftSize = main.preAnalyserNode.fftSize;\n        buffers.post = new Float32Array(fftSize);\n      }\n\n      const peak = this.getPeakData(main.postAnalyserNode, buffers.post); //store value to get possibility to consume it by recorder\n\n      this.currentMasterPeak = peak;\n      return peak;\n    }\n  },\n\n  getPeakData(analyser, sampleBuffer) {\n    analyser.getFloatTimeDomainData(sampleBuffer);\n    /*\r\n    //average \r\n    let sumOfSquares = 0;\r\n    for (let i = 0; i < sampleBuffer.length; i++) {\r\n        sumOfSquares += sampleBuffer[i] ** 2;\r\n    }\r\n      const avgPowerDecibels = 10 * Math.log10(sumOfSquares / sampleBuffer.length);\r\n    */\n    //peak \n\n    let peakPower = 0;\n\n    for (let i = 0; i < sampleBuffer.length; i++) {\n      const power = sampleBuffer[i] ** 2; // if statement is a litlebit faster that Math.max\n\n      peakPower = power > peakPower ? power : peakPower;\n    }\n\n    const peakPowerDecibels = 10 * Math.log10(peakPower);\n    return {\n      // avgdB: avgPowerDecibels,\n      peakdB: peakPowerDecibels\n    };\n  }\n\n};\nexport default peakMeters;","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/console/core/console/mixer/peakMeters.js"],"names":["peakMeters","setUpSampleBuffers","channelName","fftSize","audioNodes","channels","analyserNode","sampleBuffers","Float32Array","getChannelPeakMeter","analyser","sampleBuffer","getPeakData","getMasterPeakMetter","part","main","buffers","pre","preAnalyserNode","post","peak","postAnalyserNode","currentMasterPeak","getFloatTimeDomainData","peakPower","i","length","power","peakPowerDecibels","Math","log10","peakdB"],"mappings":"AAAA,MAAMA,UAAU,GAAG;AAEfC,EAAAA,kBAAkB,CAACC,WAAD,EAAc;AAC5B,QAAIC,OAAO,GAAG,KAAKC,UAAL,CAAgBC,QAAhB,CAAyBH,WAAzB,EAAsCI,YAAtC,CAAmDH,OAAjE;AACA,SAAKI,aAAL,CAAmBF,QAAnB,CAA4BH,WAA5B,IAA2C,IAAIM,YAAJ,CAAiBL,OAAjB,CAA3C;AACH,GALc;;AAOfM,EAAAA,mBAAmB,CAACP,WAAD,EAAc;AAAA;;AAC7B,QAAIQ,QAAQ,uBAAG,KAAKN,UAAR,8EAAG,iBAAiBC,QAAjB,CAA0BH,WAA1B,CAAH,0DAAG,sBAAwCI,YAAvD;;AACA,QAAI,CAACI,QAAL,EAAe;AACX,aAAO,EAAP;AACH;;AACD,QAAIC,YAAY,GAAG,KAAKJ,aAAL,CAAmBF,QAAnB,CAA4BH,WAA5B,CAAnB;;AACA,QAAI,CAACS,YAAL,EAAmB;AACf,aAAO,EAAP;AACH;;AACD,WAAO,KAAKC,WAAL,CAAiBF,QAAjB,EAA2BC,YAA3B,CAAP;AACH,GAjBc;;AAmBfE,EAAAA,mBAAmB,CAACC,IAAD,EAAM;AACrB,UAAMC,IAAI,GAAG,KAAKX,UAAL,CAAgBC,QAAhB,CAAyB,MAAzB,CAAb;AACA,QAAIW,OAAO,GAAG,KAAKT,aAAL,CAAmBF,QAAnB,CAA4B,MAA5B,CAAd;;AACA,QAAG,CAACW,OAAJ,EAAY;AACRA,MAAAA,OAAO,GAAG,KAAKT,aAAL,CAAmBF,QAAnB,CAA4B,MAA5B,IAAsC,EAAhD;AACH;;AACD,QAAGS,IAAI,KAAK,KAAZ,EAAkB;AACd,UAAG,CAACE,OAAO,CAACC,GAAZ,EAAgB;AACZ,cAAMd,OAAO,GAAGY,IAAI,CAACG,eAAL,CAAqBf,OAArC;AACAa,QAAAA,OAAO,CAACC,GAAR,GAAc,IAAIT,YAAJ,CAAiBL,OAAjB,CAAd;AACH;;AACD,aAAO,KAAKS,WAAL,CAAiBG,IAAI,CAACG,eAAtB,EAAuCF,OAAO,CAACC,GAA/C,CAAP;AACH,KAND,MAMO,IAAGH,IAAI,KAAK,MAAZ,EAAmB;AACtB,UAAG,CAACE,OAAO,CAACG,IAAZ,EAAiB;AACb,cAAMhB,OAAO,GAAGY,IAAI,CAACG,eAAL,CAAqBf,OAArC;AACAa,QAAAA,OAAO,CAACG,IAAR,GAAe,IAAIX,YAAJ,CAAiBL,OAAjB,CAAf;AACH;;AACD,YAAMiB,IAAI,GAAG,KAAKR,WAAL,CAAiBG,IAAI,CAACM,gBAAtB,EAAwCL,OAAO,CAACG,IAAhD,CAAb,CALsB,CAMtB;;AACA,WAAKG,iBAAL,GAAyBF,IAAzB;AACA,aAAOA,IAAP;AACH;AACJ,GAzCc;;AA4CfR,EAAAA,WAAW,CAACF,QAAD,EAAWC,YAAX,EAAyB;AAChCD,IAAAA,QAAQ,CAACa,sBAAT,CAAgCZ,YAAhC;AAEA;;;;;;;;AASA;;AAEA,QAAIa,SAAS,GAAG,CAAhB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,YAAY,CAACe,MAAjC,EAAyCD,CAAC,EAA1C,EAA8C;AAC1C,YAAME,KAAK,GAAGhB,YAAY,CAACc,CAAD,CAAZ,IAAmB,CAAjC,CAD0C,CAE1C;;AACAD,MAAAA,SAAS,GAAIG,KAAK,GAAGH,SAAT,GAAsBG,KAAtB,GAA8BH,SAA1C;AACH;;AACD,UAAMI,iBAAiB,GAAG,KAAKC,IAAI,CAACC,KAAL,CAAWN,SAAX,CAA/B;AAEA,WAAO;AACH;AACAO,MAAAA,MAAM,EAAEH;AAFL,KAAP;AAIH;;AAtEc,CAAnB;AAyEA,eAAe5B,UAAf","sourcesContent":["const peakMeters = {\r\n\r\n    setUpSampleBuffers(channelName) {\r\n        let fftSize = this.audioNodes.channels[channelName].analyserNode.fftSize;\r\n        this.sampleBuffers.channels[channelName] = new Float32Array(fftSize);\r\n    },\r\n\r\n    getChannelPeakMeter(channelName) {\r\n        let analyser = this.audioNodes?.channels[channelName]?.analyserNode\r\n        if (!analyser) {\r\n            return [];\r\n        }\r\n        let sampleBuffer = this.sampleBuffers.channels[channelName];\r\n        if (!sampleBuffer) {\r\n            return [];\r\n        }\r\n        return this.getPeakData(analyser, sampleBuffer)\r\n    },\r\n\r\n    getMasterPeakMetter(part){\r\n        const main = this.audioNodes.channels['main'];\r\n        let buffers = this.sampleBuffers.channels['main'];\r\n        if(!buffers){\r\n            buffers = this.sampleBuffers.channels[\"main\"] = {};\r\n        }\r\n        if(part === \"pre\"){\r\n            if(!buffers.pre){\r\n                const fftSize = main.preAnalyserNode.fftSize;\r\n                buffers.pre = new Float32Array(fftSize);\r\n            }\r\n            return this.getPeakData(main.preAnalyserNode, buffers.pre);\r\n        } else if(part === \"post\"){\r\n            if(!buffers.post){\r\n                const fftSize = main.preAnalyserNode.fftSize;\r\n                buffers.post = new Float32Array(fftSize);\r\n            }\r\n            const peak = this.getPeakData(main.postAnalyserNode, buffers.post);\r\n            //store value to get possibility to consume it by recorder\r\n            this.currentMasterPeak = peak;\r\n            return peak;\r\n        }\r\n    },\r\n\r\n    \r\n    getPeakData(analyser, sampleBuffer) {\r\n        analyser.getFloatTimeDomainData(sampleBuffer);\r\n\r\n        /*\r\n        //average \r\n        let sumOfSquares = 0;\r\n        for (let i = 0; i < sampleBuffer.length; i++) {\r\n            sumOfSquares += sampleBuffer[i] ** 2;\r\n        }\r\n\r\n        const avgPowerDecibels = 10 * Math.log10(sumOfSquares / sampleBuffer.length);\r\n*/\r\n        //peak \r\n\r\n        let peakPower = 0;\r\n        for (let i = 0; i < sampleBuffer.length; i++) {\r\n            const power = sampleBuffer[i] ** 2;\r\n            // if statement is a litlebit faster that Math.max\r\n            peakPower = (power > peakPower) ? power : peakPower;\r\n        }\r\n        const peakPowerDecibels = 10 * Math.log10(peakPower);\r\n\r\n        return {\r\n            // avgdB: avgPowerDecibels,\r\n            peakdB: peakPowerDecibels,\r\n        }\r\n    },\r\n}\r\n\r\nexport default peakMeters;"]},"metadata":{},"sourceType":"module"}