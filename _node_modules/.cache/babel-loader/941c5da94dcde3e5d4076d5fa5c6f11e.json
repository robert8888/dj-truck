{"ast":null,"code":"import store from \"./../../../../../../store\";\nimport { recording, recordingRquestFail, recordFinalUpdate, roolbackRecord } from \"./../../../../../../actions\";\nimport STATUS from \"./../../observer/STATUS\";\nimport io from \"socket.io-client\";\nimport { getApi } from \"./../../../../../../apis/apiProvider\";\nimport { Logger, Log } from \"./../../../../../../utils/logger/logger\";\nexport default class Recorder {\n  constructor(mixer) {\n    this.mixer = mixer;\n    const streamDestination = this.mixer.audioNodes.channels['main'].recorderStremDestination;\n    this.mediaRecorder = new MediaRecorder(streamDestination.stream, {\n      mimeType: 'audio/webm;codecs=opus'\n    });\n    const api = getApi(\"RecordsStore\");\n    this.wsUrl = api.getSocketUrl();\n    this.currentRec = Recorder.initRecState();\n    this.peaksUpdateIntervalHandle = null;\n    this.peaksUpdateIntervalTime = 100; //ms\n\n    this.peaksBoundary = {\n      min: 1000,\n      max: 2000\n    };\n  }\n\n  action(status, param) {\n    switch (status) {\n      case STATUS.RECORD_START:\n        {\n          this.startRecording(param);\n          break;\n        }\n\n      case STATUS.RECORD_END:\n        {\n          this.endRecording();\n          break;\n        }\n\n      default:\n        return;\n    }\n  }\n\n  startRecording({\n    recId,\n    recName\n  }) {\n    try {\n      const token = store.getState().user.token;\n\n      if (!token) {\n        Logger.push(Log.Error({\n          private: \"Attempt to start recordin not' authorized user\",\n          path: ['pages', 'console', 'core', 'mixxer', 'recorder', 'startRecording']\n        }));\n        return;\n      }\n\n      if (this.mediaRecorder.state === \"recording\") {\n        Logger.push(Log.Error({\n          private: \"Attempt to start recordin during active recording\",\n          path: ['pages', 'console', 'core', 'mixxer', 'recorder', 'startRecording']\n        }));\n        return;\n      }\n\n      const socket = io.connect(this.wsUrl);\n      socket.on(\"connect\", () => {\n        socket.emit('authentication', {\n          token: token\n        });\n        socket.on('authenticated', () => {\n          socket.emit(\"record_details\", {\n            recId,\n            recName\n          });\n        });\n        socket.on('recorder_ready', () => {\n          this.currentRec.id = recId;\n          this.currentRec.title = recName;\n\n          this.mediaRecorder.ondataavailable = e => {\n            socket.emit('record_chunk', e.data);\n          };\n\n          this.mediaRecorder.addEventListener('stop', () => {\n            socket.emit('record_stop');\n          });\n          this.mediaRecorder.start(1000);\n          this.currentRec.duration = new Date().getTime();\n          this.peaksUpdateIntervalHandle = setInterval(this.updatePeaks.bind(this), 100);\n          store.dispatch(recording());\n        });\n        socket.on('connect_error', () => {\n          store.dispatch(recordingRquestFail());\n          Logger.push(Log.Error({\n            private: \"Error durring connectio to recorder api\",\n            public: \"During porccess of connection to record database occured problem\",\n            path: ['pages', 'console', 'core', 'mixxer', 'recorder', 'record socket connecting record']\n          }));\n        });\n        socket.on('recording_finished', ({\n          fileSize\n        }) => {\n          this.currentRec.fileSize = fileSize;\n          const {\n            id,\n            duration,\n            peaks\n          } = this.currentRec;\n          this.updateRecord({\n            id,\n            duration,\n            fileSize,\n            peaks\n          });\n          socket.close();\n        });\n        socket.on(\"recording_error\", () => {\n          store.dispatch(roolbackRecord(this.currentRec.id));\n          Logger.push(Log.Error({\n            private: \"Rocording socket error. \",\n            public: \"During porccess of recording occured problem\",\n            path: ['pages', 'console', 'core', 'mixxer', 'recorder', 'record socket error']\n          }));\n        });\n      });\n    } catch (error) {\n      Logger.push(Log.Error({\n        private: \"Rocording error \" + error.message,\n        public: \"During porccess of recording occured problem\",\n        path: ['pages', 'console', 'core', 'mixxer', 'recorder', 'startRecording'],\n        error\n      }));\n    }\n  }\n\n  endRecording() {\n    if (this.mediaRecorder.state === \"inactive\") {\n      return;\n    }\n\n    clearInterval(this.peaksUpdateIntervalHandle);\n    this.mediaRecorder.stop();\n    this.currentRec.duration = new Date().getTime() - this.currentRec.duration;\n  }\n\n  updatePeaks() {\n    try {\n      const len = this.currentRec.peaks.length;\n      this.currentRec.peaks[len] = this.mixer.currentPeakMinMax[0];\n      this.currentRec.peaks[len + 1] = this.mixer.currentPeakMinMax[1];\n\n      if (this.currentRec.peaks.length > this.peaksBoundary.max) {\n        this.currentRec.peaks = this.reducePeaks(this.currentRec.peaks);\n        clearInterval(this.peaksUpdateIntervalHandle);\n        this.peaksUpdateIntervalTime *= 2;\n        this.peaksUpdateIntervalHandle = setInernval(this.updatePeaks.bind(this), this.peaksUpdateIntervalTime);\n      }\n    } catch (error) {\n      Logger.push(Log.Error({\n        private: \"Error during updating record peaks, Can't udpate record waveform\",\n        public: \"During porccess of recording occured problem\",\n        path: ['pages', 'console', 'core', 'mixxer', 'recorder', 'updatePeaks'],\n        error\n      }));\n    }\n  }\n\n  updateRecord(data) {\n    const {\n      id,\n      peaks,\n      duration,\n      fileSize\n    } = data;\n    store.dispatch(recordFinalUpdate(id, peaks, duration, fileSize));\n    this.currentRec = Recorder.initRecState();\n  }\n\n  reducePeaks(input, boundary = this.peaksBoundary) {\n    let output = [];\n    const targetBoundary = boundary || {\n      min: 1000,\n      max: 2000\n    };\n    const inputSize = input.length;\n\n    if (inputSize < targetBoundary.min) {\n      return input;\n    }\n\n    const ratio = Math.floor(inputSize / targetBoundary.max);\n    const outputSize = Math.ceil(inputSize / ratio);\n\n    for (let i = 0; i < outputSize / 2; i++) {\n      output[2 * i] = input[2 * (i * ratio)];\n      output[2 * i + 1] = input[2 * (i * ratio) + 1];\n    }\n\n    return output;\n  }\n\n}\n\nRecorder.initRecState = () => ({\n  id: null,\n  title: \"\",\n  peaks: [],\n  duration: 0\n});","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/console/core/console/mixer/recorder/recorder.js"],"names":["store","recording","recordingRquestFail","recordFinalUpdate","roolbackRecord","STATUS","io","getApi","Logger","Log","Recorder","constructor","mixer","streamDestination","audioNodes","channels","recorderStremDestination","mediaRecorder","MediaRecorder","stream","mimeType","api","wsUrl","getSocketUrl","currentRec","initRecState","peaksUpdateIntervalHandle","peaksUpdateIntervalTime","peaksBoundary","min","max","action","status","param","RECORD_START","startRecording","RECORD_END","endRecording","recId","recName","token","getState","user","push","Error","private","path","state","socket","connect","on","emit","id","title","ondataavailable","e","data","addEventListener","start","duration","Date","getTime","setInterval","updatePeaks","bind","dispatch","public","fileSize","peaks","updateRecord","close","error","message","clearInterval","stop","len","length","currentPeakMinMax","reducePeaks","setInernval","input","boundary","output","targetBoundary","inputSize","ratio","Math","floor","outputSize","ceil","i"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,2BAAlB;AACA,SAASC,SAAT,EAAoBC,mBAApB,EAAyCC,iBAAzC,EAA4DC,cAA5D,QAAkF,6BAAlF;AACA,OAAOC,MAAP,MAAmB,yBAAnB;AACA,OAAOC,EAAP,MAAe,kBAAf;AACA,SAASC,MAAT,QAAuB,sCAAvB;AACA,SAASC,MAAT,EAAiBC,GAAjB,QAA4B,yCAA5B;AAGA,eAAe,MAAMC,QAAN,CAAe;AAQ1BC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,SAAKA,KAAL,GAAaA,KAAb;AAEA,UAAMC,iBAAiB,GAAG,KAAKD,KAAL,CAAWE,UAAX,CAAsBC,QAAtB,CAA+B,MAA/B,EAAuCC,wBAAjE;AACA,SAAKC,aAAL,GAAqB,IAAIC,aAAJ,CAAkBL,iBAAiB,CAACM,MAApC,EAA4C;AAC7DC,MAAAA,QAAQ,EAAE;AADmD,KAA5C,CAArB;AAIA,UAAMC,GAAG,GAAGd,MAAM,CAAC,cAAD,CAAlB;AACA,SAAKe,KAAL,GAAaD,GAAG,CAACE,YAAJ,EAAb;AAEA,SAAKC,UAAL,GAAkBd,QAAQ,CAACe,YAAT,EAAlB;AAGA,SAAKC,yBAAL,GAAiC,IAAjC;AACA,SAAKC,uBAAL,GAA+B,GAA/B,CAfe,CAeqB;;AACpC,SAAKC,aAAL,GAAqB;AACjBC,MAAAA,GAAG,EAAE,IADY;AAEjBC,MAAAA,GAAG,EAAE;AAFY,KAArB;AAIH;;AAGDC,EAAAA,MAAM,CAACC,MAAD,EAASC,KAAT,EAAgB;AAClB,YAAQD,MAAR;AACI,WAAK3B,MAAM,CAAC6B,YAAZ;AAA0B;AACtB,eAAKC,cAAL,CAAoBF,KAApB;AACA;AACH;;AACD,WAAK5B,MAAM,CAAC+B,UAAZ;AAAwB;AACpB,eAAKC,YAAL;AACA;AACH;;AACD;AAAS;AATb;AAWH;;AAEDF,EAAAA,cAAc,CAAC;AAAEG,IAAAA,KAAF;AAASC,IAAAA;AAAT,GAAD,EAAqB;AACnC,QAAI;AACA,YAAMC,KAAK,GAAGxC,KAAK,CAACyC,QAAN,GAAiBC,IAAjB,CAAsBF,KAApC;;AACA,UAAI,CAACA,KAAL,EAAY;AACRhC,QAAAA,MAAM,CAACmC,IAAP,CAAYlC,GAAG,CAACmC,KAAJ,CACR;AACIC,UAAAA,OAAO,EAAE,gDADb;AAEIC,UAAAA,IAAI,EAAE,CAAC,OAAD,EAAU,SAAV,EAAqB,MAArB,EAA6B,QAA7B,EAAuC,UAAvC,EAAmD,gBAAnD;AAFV,SADQ,CAAZ;AAKA;AACH;;AACD,UAAI,KAAK7B,aAAL,CAAmB8B,KAAnB,KAA6B,WAAjC,EAA8C;AAC1CvC,QAAAA,MAAM,CAACmC,IAAP,CAAYlC,GAAG,CAACmC,KAAJ,CACR;AACIC,UAAAA,OAAO,EAAE,mDADb;AAEIC,UAAAA,IAAI,EAAE,CAAC,OAAD,EAAU,SAAV,EAAqB,MAArB,EAA6B,QAA7B,EAAuC,UAAvC,EAAmD,gBAAnD;AAFV,SADQ,CAAZ;AAKA;AACH;;AAED,YAAME,MAAM,GAAG1C,EAAE,CAAC2C,OAAH,CAAW,KAAK3B,KAAhB,CAAf;AAEA0B,MAAAA,MAAM,CAACE,EAAP,CAAU,SAAV,EAAqB,MAAM;AACvBF,QAAAA,MAAM,CAACG,IAAP,CAAY,gBAAZ,EAA8B;AAAEX,UAAAA,KAAK,EAAEA;AAAT,SAA9B;AACAQ,QAAAA,MAAM,CAACE,EAAP,CAAU,eAAV,EAA2B,MAAM;AAC7BF,UAAAA,MAAM,CAACG,IAAP,CAAY,gBAAZ,EAA8B;AAAEb,YAAAA,KAAF;AAASC,YAAAA;AAAT,WAA9B;AACH,SAFD;AAGAS,QAAAA,MAAM,CAACE,EAAP,CAAU,gBAAV,EAA4B,MAAM;AAC9B,eAAK1B,UAAL,CAAgB4B,EAAhB,GAAqBd,KAArB;AACA,eAAKd,UAAL,CAAgB6B,KAAhB,GAAwBd,OAAxB;;AAEA,eAAKtB,aAAL,CAAmBqC,eAAnB,GAAsCC,CAAD,IAAO;AACxCP,YAAAA,MAAM,CAACG,IAAP,CAAY,cAAZ,EAA4BI,CAAC,CAACC,IAA9B;AACH,WAFD;;AAIA,eAAKvC,aAAL,CAAmBwC,gBAAnB,CAAoC,MAApC,EAA4C,MAAM;AAC9CT,YAAAA,MAAM,CAACG,IAAP,CAAY,aAAZ;AACH,WAFD;AAIA,eAAKlC,aAAL,CAAmByC,KAAnB,CAAyB,IAAzB;AAEA,eAAKlC,UAAL,CAAgBmC,QAAhB,GAA2B,IAAIC,IAAJ,GAAWC,OAAX,EAA3B;AAEA,eAAKnC,yBAAL,GAAiCoC,WAAW,CAAC,KAAKC,WAAL,CAAiBC,IAAjB,CAAsB,IAAtB,CAAD,EAA8B,GAA9B,CAA5C;AAEAhE,UAAAA,KAAK,CAACiE,QAAN,CAAehE,SAAS,EAAxB;AACH,SAnBD;AAqBA+C,QAAAA,MAAM,CAACE,EAAP,CAAU,eAAV,EAA2B,MAAM;AAC7BlD,UAAAA,KAAK,CAACiE,QAAN,CAAe/D,mBAAmB,EAAlC;AACAM,UAAAA,MAAM,CAACmC,IAAP,CAAYlC,GAAG,CAACmC,KAAJ,CACR;AACIC,YAAAA,OAAO,EAAE,yCADb;AAEIqB,YAAAA,MAAM,EAAE,kEAFZ;AAGIpB,YAAAA,IAAI,EAAE,CAAC,OAAD,EAAU,SAAV,EAAqB,MAArB,EAA6B,QAA7B,EAAuC,UAAvC,EAAmD,iCAAnD;AAHV,WADQ,CAAZ;AAMH,SARD;AAUAE,QAAAA,MAAM,CAACE,EAAP,CAAU,oBAAV,EAAgC,CAAC;AAAEiB,UAAAA;AAAF,SAAD,KAAkB;AAC9C,eAAK3C,UAAL,CAAgB2C,QAAhB,GAA2BA,QAA3B;AACA,gBAAM;AAAEf,YAAAA,EAAF;AAAMO,YAAAA,QAAN;AAAgBS,YAAAA;AAAhB,cAA0B,KAAK5C,UAArC;AACA,eAAK6C,YAAL,CAAkB;AACdjB,YAAAA,EADc;AACVO,YAAAA,QADU;AACAQ,YAAAA,QADA;AACUC,YAAAA;AADV,WAAlB;AAGApB,UAAAA,MAAM,CAACsB,KAAP;AACH,SAPD;AASAtB,QAAAA,MAAM,CAACE,EAAP,CAAU,iBAAV,EAA6B,MAAM;AAC/BlD,UAAAA,KAAK,CAACiE,QAAN,CAAe7D,cAAc,CAAC,KAAKoB,UAAL,CAAgB4B,EAAjB,CAA7B;AACA5C,UAAAA,MAAM,CAACmC,IAAP,CAAYlC,GAAG,CAACmC,KAAJ,CACR;AACIC,YAAAA,OAAO,EAAE,0BADb;AAEIqB,YAAAA,MAAM,EAAE,8CAFZ;AAGIpB,YAAAA,IAAI,EAAE,CAAC,OAAD,EAAU,SAAV,EAAqB,MAArB,EAA6B,QAA7B,EAAuC,UAAvC,EAAmD,qBAAnD;AAHV,WADQ,CAAZ;AAMH,SARD;AASH,OAtDD;AAuDC,KA5EL,CA4EM,OAAMyB,KAAN,EAAY;AACV/D,MAAAA,MAAM,CAACmC,IAAP,CAAYlC,GAAG,CAACmC,KAAJ,CACR;AACIC,QAAAA,OAAO,EAAE,qBAAqB0B,KAAK,CAACC,OADxC;AAEIN,QAAAA,MAAM,EAAE,8CAFZ;AAGIpB,QAAAA,IAAI,EAAE,CAAC,OAAD,EAAU,SAAV,EAAqB,MAArB,EAA6B,QAA7B,EAAuC,UAAvC,EAAmD,gBAAnD,CAHV;AAIIyB,QAAAA;AAJJ,OADQ,CAAZ;AAOH;AACJ;;AAEDlC,EAAAA,YAAY,GAAG;AACX,QAAG,KAAKpB,aAAL,CAAmB8B,KAAnB,KAA6B,UAAhC,EAA2C;AACvC;AACH;;AAED0B,IAAAA,aAAa,CAAC,KAAK/C,yBAAN,CAAb;AACA,SAAKT,aAAL,CAAmByD,IAAnB;AACA,SAAKlD,UAAL,CAAgBmC,QAAhB,GAA2B,IAAIC,IAAJ,GAAWC,OAAX,KAAuB,KAAKrC,UAAL,CAAgBmC,QAAlE;AACH;;AAEDI,EAAAA,WAAW,GAAG;AACV,QAAI;AACA,YAAMY,GAAG,GAAG,KAAKnD,UAAL,CAAgB4C,KAAhB,CAAsBQ,MAAlC;AACA,WAAKpD,UAAL,CAAgB4C,KAAhB,CAAsBO,GAAtB,IAA6B,KAAK/D,KAAL,CAAWiE,iBAAX,CAA6B,CAA7B,CAA7B;AACA,WAAKrD,UAAL,CAAgB4C,KAAhB,CAAsBO,GAAG,GAAG,CAA5B,IAAiC,KAAK/D,KAAL,CAAWiE,iBAAX,CAA6B,CAA7B,CAAjC;;AACA,UAAI,KAAKrD,UAAL,CAAgB4C,KAAhB,CAAsBQ,MAAtB,GAA+B,KAAKhD,aAAL,CAAmBE,GAAtD,EAA2D;AACvD,aAAKN,UAAL,CAAgB4C,KAAhB,GAAwB,KAAKU,WAAL,CAAiB,KAAKtD,UAAL,CAAgB4C,KAAjC,CAAxB;AACAK,QAAAA,aAAa,CAAC,KAAK/C,yBAAN,CAAb;AACA,aAAKC,uBAAL,IAAgC,CAAhC;AACA,aAAKD,yBAAL,GAAiCqD,WAAW,CAAC,KAAKhB,WAAL,CAAiBC,IAAjB,CAAsB,IAAtB,CAAD,EAA8B,KAAKrC,uBAAnC,CAA5C;AACH;AACJ,KAVD,CAUE,OAAM4C,KAAN,EAAY;AACV/D,MAAAA,MAAM,CAACmC,IAAP,CAAYlC,GAAG,CAACmC,KAAJ,CACR;AACIC,QAAAA,OAAO,EAAE,kEADb;AAEIqB,QAAAA,MAAM,EAAE,8CAFZ;AAGIpB,QAAAA,IAAI,EAAE,CAAC,OAAD,EAAU,SAAV,EAAqB,MAArB,EAA6B,QAA7B,EAAuC,UAAvC,EAAmD,aAAnD,CAHV;AAIIyB,QAAAA;AAJJ,OADQ,CAAZ;AAOH;AACJ;;AAEDF,EAAAA,YAAY,CAACb,IAAD,EAAO;AACf,UAAM;AAAEJ,MAAAA,EAAF;AAAMgB,MAAAA,KAAN;AAAaT,MAAAA,QAAb;AAAuBQ,MAAAA;AAAvB,QAAoCX,IAA1C;AACAxD,IAAAA,KAAK,CAACiE,QAAN,CAAe9D,iBAAiB,CAC5BiD,EAD4B,EACxBgB,KADwB,EACjBT,QADiB,EACPQ,QADO,CAAhC;AAGA,SAAK3C,UAAL,GAAkBd,QAAQ,CAACe,YAAT,EAAlB;AACH;;AAEDqD,EAAAA,WAAW,CAACE,KAAD,EAAQC,QAAQ,GAAG,KAAKrD,aAAxB,EAAuC;AAC9C,QAAIsD,MAAM,GAAG,EAAb;AACA,UAAMC,cAAc,GAAGF,QAAQ,IAAI;AAC/BpD,MAAAA,GAAG,EAAE,IAD0B;AAE/BC,MAAAA,GAAG,EAAE;AAF0B,KAAnC;AAKA,UAAMsD,SAAS,GAAGJ,KAAK,CAACJ,MAAxB;;AAEA,QAAIQ,SAAS,GAAGD,cAAc,CAACtD,GAA/B,EAAoC;AAChC,aAAOmD,KAAP;AACH;;AAED,UAAMK,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWH,SAAS,GAAGD,cAAc,CAACrD,GAAtC,CAAd;AACA,UAAM0D,UAAU,GAAGF,IAAI,CAACG,IAAL,CAAUL,SAAS,GAAGC,KAAtB,CAAnB;;AAEA,SAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,UAAU,GAAG,CAAjC,EAAoCE,CAAC,EAArC,EAAyC;AACrCR,MAAAA,MAAM,CAAC,IAAIQ,CAAL,CAAN,GAAgBV,KAAK,CAAC,KAAKU,CAAC,GAAGL,KAAT,CAAD,CAArB;AACAH,MAAAA,MAAM,CAAC,IAAIQ,CAAJ,GAAQ,CAAT,CAAN,GAAoBV,KAAK,CAAE,KAAKU,CAAC,GAAGL,KAAT,CAAD,GAAoB,CAArB,CAAzB;AACH;;AAED,WAAOH,MAAP;AACH;;AAnMyB;;AAATxE,Q,CACVe,Y,GAAe,OAAO;AACzB2B,EAAAA,EAAE,EAAE,IADqB;AAEzBC,EAAAA,KAAK,EAAE,EAFkB;AAGzBe,EAAAA,KAAK,EAAE,EAHkB;AAIzBT,EAAAA,QAAQ,EAAE;AAJe,CAAP,C","sourcesContent":["import store from \"./../../../../../../store\";\r\nimport { recording, recordingRquestFail, recordFinalUpdate, roolbackRecord } from \"./../../../../../../actions\"\r\nimport STATUS from \"./../../observer/STATUS\";\r\nimport io from \"socket.io-client\";\r\nimport { getApi } from \"./../../../../../../apis/apiProvider\";\r\nimport { Logger, Log } from \"./../../../../../../utils/logger/logger\";\r\n\r\n\r\nexport default class Recorder {\r\n    static initRecState = () => ({\r\n        id: null,\r\n        title: \"\",\r\n        peaks: [],\r\n        duration: 0,\r\n    })\r\n\r\n    constructor(mixer) {\r\n        this.mixer = mixer;\r\n\r\n        const streamDestination = this.mixer.audioNodes.channels['main'].recorderStremDestination;\r\n        this.mediaRecorder = new MediaRecorder(streamDestination.stream, {\r\n            mimeType: 'audio/webm;codecs=opus',\r\n        });\r\n\r\n        const api = getApi(\"RecordsStore\");\r\n        this.wsUrl = api.getSocketUrl();\r\n\r\n        this.currentRec = Recorder.initRecState();\r\n\r\n\r\n        this.peaksUpdateIntervalHandle = null;\r\n        this.peaksUpdateIntervalTime = 100; //ms\r\n        this.peaksBoundary = {\r\n            min: 1000,\r\n            max: 2000,\r\n        }\r\n    }\r\n\r\n\r\n    action(status, param) {\r\n        switch (status) {\r\n            case STATUS.RECORD_START: {\r\n                this.startRecording(param);\r\n                break;\r\n            }\r\n            case STATUS.RECORD_END: {\r\n                this.endRecording()\r\n                break;\r\n            }\r\n            default: return;\r\n        }\r\n    }\r\n\r\n    startRecording({ recId, recName }) {\r\n    try {\r\n        const token = store.getState().user.token;\r\n        if (!token) {\r\n            Logger.push(Log.Error(\r\n                {\r\n                    private: \"Attempt to start recordin not' authorized user\",\r\n                    path: ['pages', 'console', 'core', 'mixxer', 'recorder', 'startRecording']\r\n                }))\r\n            return;\r\n        }\r\n        if (this.mediaRecorder.state === \"recording\") {\r\n            Logger.push(Log.Error(\r\n                {\r\n                    private: \"Attempt to start recordin during active recording\",\r\n                    path: ['pages', 'console', 'core', 'mixxer', 'recorder', 'startRecording']\r\n                }))\r\n            return;\r\n        }\r\n\r\n        const socket = io.connect(this.wsUrl);\r\n\r\n        socket.on(\"connect\", () => {\r\n            socket.emit('authentication', { token: token });\r\n            socket.on('authenticated', () => {\r\n                socket.emit(\"record_details\", { recId, recName })\r\n            })\r\n            socket.on('recorder_ready', () => {\r\n                this.currentRec.id = recId;\r\n                this.currentRec.title = recName;\r\n\r\n                this.mediaRecorder.ondataavailable = (e) => {\r\n                    socket.emit('record_chunk', e.data)\r\n                }\r\n\r\n                this.mediaRecorder.addEventListener('stop', () => {\r\n                    socket.emit('record_stop')\r\n                })\r\n\r\n                this.mediaRecorder.start(1000);\r\n\r\n                this.currentRec.duration = new Date().getTime();\r\n\r\n                this.peaksUpdateIntervalHandle = setInterval(this.updatePeaks.bind(this), 100);\r\n\r\n                store.dispatch(recording());\r\n            });\r\n\r\n            socket.on('connect_error', () => {\r\n                store.dispatch(recordingRquestFail())\r\n                Logger.push(Log.Error(\r\n                    {\r\n                        private: \"Error durring connectio to recorder api\",\r\n                        public: \"During porccess of connection to record database occured problem\",\r\n                        path: ['pages', 'console', 'core', 'mixxer', 'recorder', 'record socket connecting record'],\r\n                    }))\r\n            })\r\n\r\n            socket.on('recording_finished', ({ fileSize }) => {\r\n                this.currentRec.fileSize = fileSize;\r\n                const { id, duration, peaks } = this.currentRec;\r\n                this.updateRecord({\r\n                    id, duration, fileSize, peaks\r\n                })\r\n                socket.close();\r\n            })\r\n\r\n            socket.on(\"recording_error\", () => {\r\n                store.dispatch(roolbackRecord(this.currentRec.id))\r\n                Logger.push(Log.Error(\r\n                    {\r\n                        private: \"Rocording socket error. \",\r\n                        public: \"During porccess of recording occured problem\",\r\n                        path: ['pages', 'console', 'core', 'mixxer', 'recorder', 'record socket error'],\r\n                    }))\r\n            })\r\n        })\r\n        } catch(error){\r\n            Logger.push(Log.Error(\r\n                {\r\n                    private: \"Rocording error \" + error.message,\r\n                    public: \"During porccess of recording occured problem\",\r\n                    path: ['pages', 'console', 'core', 'mixxer', 'recorder', 'startRecording'],\r\n                    error,\r\n                }))\r\n        }\r\n    }\r\n\r\n    endRecording() {\r\n        if(this.mediaRecorder.state === \"inactive\"){\r\n            return;\r\n        }\r\n\r\n        clearInterval(this.peaksUpdateIntervalHandle);\r\n        this.mediaRecorder.stop();\r\n        this.currentRec.duration = new Date().getTime() - this.currentRec.duration;\r\n    }\r\n\r\n    updatePeaks() {\r\n        try {\r\n            const len = this.currentRec.peaks.length;\r\n            this.currentRec.peaks[len] = this.mixer.currentPeakMinMax[0];\r\n            this.currentRec.peaks[len + 1] = this.mixer.currentPeakMinMax[1];\r\n            if (this.currentRec.peaks.length > this.peaksBoundary.max) {\r\n                this.currentRec.peaks = this.reducePeaks(this.currentRec.peaks)\r\n                clearInterval(this.peaksUpdateIntervalHandle);\r\n                this.peaksUpdateIntervalTime *= 2;\r\n                this.peaksUpdateIntervalHandle = setInernval(this.updatePeaks.bind(this), this.peaksUpdateIntervalTime);\r\n            }\r\n        } catch(error){\r\n            Logger.push(Log.Error(\r\n                {\r\n                    private: \"Error during updating record peaks, Can't udpate record waveform\",\r\n                    public: \"During porccess of recording occured problem\",\r\n                    path: ['pages', 'console', 'core', 'mixxer', 'recorder', 'updatePeaks'],\r\n                    error\r\n                }))\r\n        }\r\n    }\r\n\r\n    updateRecord(data) {\r\n        const { id, peaks, duration, fileSize } = data;\r\n        store.dispatch(recordFinalUpdate(\r\n            id, peaks, duration, fileSize\r\n        ))\r\n        this.currentRec = Recorder.initRecState();\r\n    }\r\n\r\n    reducePeaks(input, boundary = this.peaksBoundary) {\r\n        let output = [];\r\n        const targetBoundary = boundary || {\r\n            min: 1000,\r\n            max: 2000,\r\n        }\r\n\r\n        const inputSize = input.length;\r\n\r\n        if (inputSize < targetBoundary.min) {\r\n            return input;\r\n        }\r\n\r\n        const ratio = Math.floor(inputSize / targetBoundary.max);\r\n        const outputSize = Math.ceil(inputSize / ratio);\r\n\r\n        for (let i = 0; i < outputSize / 2; i++) {\r\n            output[2 * i] = input[2 * (i * ratio)];\r\n            output[2 * i + 1] = input[(2 * (i * ratio)) + 1];\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n}"]},"metadata":{},"sourceType":"module"}