{"ast":null,"code":"//const map = require('unist-util-map');\nconst vFile = require('vfile');\n\nconst flatMap = require('unist-util-flatmap');\n\nmodule.exports = attacher;\n\nconst newFileFrom = (vfile, contents) => {\n  return vFile({ ...vfile,\n    contents: contents\n  });\n};\n\nfunction attacher() {\n  // console.log(\"the this\", this.Parser);\n  const pattern = /{\\.(\\w+)}/;\n  const processor = this;\n\n  function transformer(tree, file) {\n    let inlineMethods = processor.Parser.prototype.inlineMethods;\n    let blockMethods = processor.Parser.prototype.blockMethods;\n    console.log(\"before modification\", tree);\n\n    const modify = node => {\n      console.log(\"in modify\", node);\n      let parent = node;\n      const children = node.children.map(node => {\n        var _processor$parse;\n\n        if (node.type !== \"text\") return modify(node);\n        if (!node.children) node;\n        console.log(\"node in\", node);\n        let match = pattern.exec(node.value);\n        if (!match) return node;\n        const value = node.value.replace(match[0], \"\");\n        const subNodes = (_processor$parse = processor.parse(newFileFrom(file, value))) === null || _processor$parse === void 0 ? void 0 : _processor$parse.children; // console.log(\"parnet subnodes\", parent, subNodes)\n\n        if (subNodes.some(subNode => subNode.type === \"thematicBreak\") && parent.type === \"paragraph\") {\n          parent = subNodes.find(subNode => subNode.type === \"thematicBreak\");\n          parent.className = match[1];\n          parent.position = node.position;\n          parent.position.end.column -= match[0].length;\n          parent.position.end.offset -= match[0].length;\n        }\n      });\n      node = parent;\n      node.children = children;\n      return node;\n    };\n\n    return modify(tree); // //   console.log(file);\n    //  //  console.log(inlineMethods)\n    //    //console.log(tree);\n    //    const next = m(tree, (node , index, parent)=> {\n    //        if(node.type === \"text\" || !node.children) return node;\n    //        const _node = node;\n    //        parent = node;\n    //        let children = node.children.map( node => {\n    //\n    //            if(node.type !== \"text\") return node;\n    //            console.log(\"node in\", node)\n    //            let match = pattern.exec(node.value);\n    //            if(!match) return node;\n    //            const value = node.value.replace(match[0], \"\");\n    //            const subNodes = processor.parse(newFileFrom(file, value))?.children;\n    //           // console.log(\"parnet subnodes\", parent, subNodes)\n    //            if(subNodes.some( subNode => subNode.type === \"thematicBreak\")\n    //                && parent.type === \"paragraph\"){\n    //                parent = subNodes.find( subNode => subNode.type === \"thematicBreak\");\n    //                parent.className = match[1];\n    //                parent.position = _node.position;\n    //                parent.position.end.column-=match[0].length;\n    //                parent.position.end.offset-=match[0].length;\n    //\n    //            }\n    //        })\n    //        node = parent;\n    //   //     node.children = [...children];\n    //        if(node.type === \"thematicBreak\" || node.type=== \"text\"){\n    //            console.log(\"before dlelet\", node)\n    //            delete node.children;\n    //\n    //            console.log(\"after delete\", node)\n    //        }\n    //\n    //        console.log(\"node before modification\", _node)\n    //        console.log(\"node before return\", node)\n    //        return node;\n    //    })\n    //\n    //    console.log(\"mod tree\", next)\n    //    return next;\n  }\n\n  return transformer;\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/introduction/MarkDonwExtesnion/reamark-hclass.js"],"names":["vFile","require","flatMap","module","exports","attacher","newFileFrom","vfile","contents","pattern","processor","transformer","tree","file","inlineMethods","Parser","prototype","blockMethods","console","log","modify","node","parent","children","map","type","match","exec","value","replace","subNodes","parse","some","subNode","find","className","position","end","column","length","offset"],"mappings":"AAAA;AACA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,oBAAD,CAAvB;;AAEAE,MAAM,CAACC,OAAP,GAAiBC,QAAjB;;AAEA,MAAMC,WAAW,GAAG,CAACC,KAAD,EAAQC,QAAR,KAAqB;AACrC,SAAOR,KAAK,CAAC,EAAC,GAAGO,KAAJ;AAAWC,IAAAA,QAAQ,EAAEA;AAArB,GAAD,CAAZ;AACH,CAFD;;AAIA,SAASH,QAAT,GAAoB;AACjB;AACC,QAAMI,OAAO,GAAG,WAAhB;AACA,QAAMC,SAAS,GAAG,IAAlB;;AACA,WAASC,WAAT,CAAqBC,IAArB,EAA2BC,IAA3B,EAAiC;AAC7B,QAAIC,aAAa,GAAEJ,SAAS,CAACK,MAAV,CAAiBC,SAAjB,CAA2BF,aAA9C;AACA,QAAIG,YAAY,GAAGP,SAAS,CAACK,MAAV,CAAiBC,SAAjB,CAA2BC,YAA9C;AAEAC,IAAAA,OAAO,CAACC,GAAR,CAAY,qBAAZ,EAAmCP,IAAnC;;AAEA,UAAMQ,MAAM,GAAGC,IAAI,IAAI;AACnBH,MAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyBE,IAAzB;AACA,UAAIC,MAAM,GAAGD,IAAb;AACA,YAAME,QAAQ,GAAGF,IAAI,CAACE,QAAL,CAAcC,GAAd,CAAmBH,IAAI,IAAI;AAAA;;AACxC,YAAGA,IAAI,CAACI,IAAL,KAAc,MAAjB,EAAyB,OAAOL,MAAM,CAACC,IAAD,CAAb;AACzB,YAAG,CAACA,IAAI,CAACE,QAAT,EAAmBF,IAAI;AACvBH,QAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuBE,IAAvB;AACA,YAAIK,KAAK,GAAGjB,OAAO,CAACkB,IAAR,CAAaN,IAAI,CAACO,KAAlB,CAAZ;AACA,YAAG,CAACF,KAAJ,EAAW,OAAOL,IAAP;AACX,cAAMO,KAAK,GAAGP,IAAI,CAACO,KAAL,CAAWC,OAAX,CAAmBH,KAAK,CAAC,CAAD,CAAxB,EAA6B,EAA7B,CAAd;AACA,cAAMI,QAAQ,uBAAGpB,SAAS,CAACqB,KAAV,CAAgBzB,WAAW,CAACO,IAAD,EAAOe,KAAP,CAA3B,CAAH,qDAAG,iBAA2CL,QAA5D,CAPwC,CAQxC;;AACA,YAAGO,QAAQ,CAACE,IAAT,CAAeC,OAAO,IAAIA,OAAO,CAACR,IAAR,KAAiB,eAA3C,KACIH,MAAM,CAACG,IAAP,KAAgB,WADvB,EACmC;AAC/BH,UAAAA,MAAM,GAAGQ,QAAQ,CAACI,IAAT,CAAeD,OAAO,IAAIA,OAAO,CAACR,IAAR,KAAiB,eAA3C,CAAT;AACAH,UAAAA,MAAM,CAACa,SAAP,GAAmBT,KAAK,CAAC,CAAD,CAAxB;AACAJ,UAAAA,MAAM,CAACc,QAAP,GAAkBf,IAAI,CAACe,QAAvB;AACAd,UAAAA,MAAM,CAACc,QAAP,CAAgBC,GAAhB,CAAoBC,MAApB,IAA4BZ,KAAK,CAAC,CAAD,CAAL,CAASa,MAArC;AACAjB,UAAAA,MAAM,CAACc,QAAP,CAAgBC,GAAhB,CAAoBG,MAApB,IAA4Bd,KAAK,CAAC,CAAD,CAAL,CAASa,MAArC;AAEH;AACJ,OAlBgB,CAAjB;AAmBAlB,MAAAA,IAAI,GAAGC,MAAP;AACAD,MAAAA,IAAI,CAACE,QAAL,GAAgBA,QAAhB;AACA,aAAOF,IAAP;AACH,KAzBD;;AA2BA,WAAOD,MAAM,CAACR,IAAD,CAAb,CAjC6B,CAmChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAED,SAAOD,WAAP;AACH","sourcesContent":["//const map = require('unist-util-map');\r\nconst vFile = require('vfile');\r\nconst flatMap = require('unist-util-flatmap')\r\n\r\nmodule.exports = attacher\r\n\r\nconst newFileFrom = (vfile, contents) => {\r\n    return vFile({...vfile, contents: contents})\r\n}\r\n\r\nfunction attacher() {\r\n   // console.log(\"the this\", this.Parser);\r\n    const pattern = /{\\.(\\w+)}/;\r\n    const processor = this;\r\n    function transformer(tree, file) {\r\n        let inlineMethods =processor.Parser.prototype.inlineMethods;\r\n        let blockMethods = processor.Parser.prototype.blockMethods;\r\n\r\n        console.log(\"before modification\", tree)\r\n\r\n        const modify = node => {\r\n            console.log(\"in modify\", node)\r\n            let parent = node;\r\n            const children = node.children.map( node => {\r\n                if(node.type !== \"text\") return modify(node);\r\n                if(!node.children) node;\r\n                console.log(\"node in\", node)\r\n                let match = pattern.exec(node.value);\r\n                if(!match) return node;\r\n                const value = node.value.replace(match[0], \"\");\r\n                const subNodes = processor.parse(newFileFrom(file, value))?.children;\r\n                // console.log(\"parnet subnodes\", parent, subNodes)\r\n                if(subNodes.some( subNode => subNode.type === \"thematicBreak\")\r\n                    && parent.type === \"paragraph\"){\r\n                    parent = subNodes.find( subNode => subNode.type === \"thematicBreak\");\r\n                    parent.className = match[1];\r\n                    parent.position = node.position;\r\n                    parent.position.end.column-=match[0].length;\r\n                    parent.position.end.offset-=match[0].length;\r\n\r\n                }\r\n            })\r\n            node = parent;\r\n            node.children = children;\r\n            return node;\r\n        }\r\n\r\n        return modify(tree);\r\n\r\n     // //   console.log(file);\r\n     //  //  console.log(inlineMethods)\r\n     //    //console.log(tree);\r\n     //    const next = m(tree, (node , index, parent)=> {\r\n     //        if(node.type === \"text\" || !node.children) return node;\r\n     //        const _node = node;\r\n     //        parent = node;\r\n     //        let children = node.children.map( node => {\r\n     //\r\n     //            if(node.type !== \"text\") return node;\r\n     //            console.log(\"node in\", node)\r\n     //            let match = pattern.exec(node.value);\r\n     //            if(!match) return node;\r\n     //            const value = node.value.replace(match[0], \"\");\r\n     //            const subNodes = processor.parse(newFileFrom(file, value))?.children;\r\n     //           // console.log(\"parnet subnodes\", parent, subNodes)\r\n     //            if(subNodes.some( subNode => subNode.type === \"thematicBreak\")\r\n     //                && parent.type === \"paragraph\"){\r\n     //                parent = subNodes.find( subNode => subNode.type === \"thematicBreak\");\r\n     //                parent.className = match[1];\r\n     //                parent.position = _node.position;\r\n     //                parent.position.end.column-=match[0].length;\r\n     //                parent.position.end.offset-=match[0].length;\r\n     //\r\n     //            }\r\n     //        })\r\n     //        node = parent;\r\n     //   //     node.children = [...children];\r\n     //        if(node.type === \"thematicBreak\" || node.type=== \"text\"){\r\n     //            console.log(\"before dlelet\", node)\r\n     //            delete node.children;\r\n     //\r\n     //            console.log(\"after delete\", node)\r\n     //        }\r\n     //\r\n     //        console.log(\"node before modification\", _node)\r\n     //        console.log(\"node before return\", node)\r\n     //        return node;\r\n     //    })\r\n     //\r\n     //    console.log(\"mod tree\", next)\r\n     //    return next;\r\n    }\r\n\r\n    return transformer\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}