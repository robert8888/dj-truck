{"ast":null,"code":"import store from \"./../../../../../store\";\nimport { equalPowerFader } from \"./../../../../../utils/sound/converter\";\nimport { nodeChain as audioNodeChain } from \"./../../../../../utils/sound/audioNodes\";\nimport Mastering from \"./mastering\";\nexport default class Mixer {\n  constructor(channels) {\n    console.log(\"create mixer\");\n    this.config = store.getState().configuration.mixer;\n    this.channels = channels;\n    this.mastering = new Mastering(this);\n    this.initChannelContainer('audioNodes');\n    this.initChannelContainer('sampleBuffers');\n    this.createMainChannel();\n  }\n\n  connect(external) {\n    this.external = external;\n  }\n\n  initChannelContainer(containerName) {\n    this[containerName] = {\n      channels: {}\n    };\n\n    for (let channelName of [...this.channels.getChannelNames(), \"main\"]) {\n      this[containerName].channels = { ...this[containerName].channels,\n        [channelName]: null\n      };\n    }\n  }\n\n  createMainChannel() {\n    //main audio context with is share between wavesurfer objects\n    this.mainAudioContext = new AudioContext();\n    let ac = this.mainAudioContext;\n    let main = this.audioNodes.channels['main'] = {};\n    main.preGainNode = ac.createGain();\n    main.preAnalyserNode = ac.createAnalyser();\n    main.compressorNode = ac.createDynamicsCompressor();\n    main.postAnalyserNode = ac.createAnalyser();\n    main.postGainNode = ac.createGain();\n    this.mastering.configCompressor(); //wiring in chain\n\n    audioNodeChain([main.preGainNode, main.preAnalyserNode, main.compressorNode, main.postAnalyserNode, main.postGainNode, ac.destination]);\n  }\n\n  getChannelInterface(channelName) {\n    return {\n      getPeakMeter: () => this.getChannelPeakMeter(channelName)\n    };\n  }\n\n  getMasteringInterface() {\n    return {\n      getPrePeakMeter: this.getMasterPeakMetter.bind(null, \"pre\"),\n      getPostPeakMeter: this.getMasterPeakMetter.bind(null, \"post\")\n    };\n  }\n\n  setUpChannelsAudioNodes(channelName) {\n    console.log(\"set up audio channel nodes\"); //surfer - waveSurfer obj\n\n    let surfer = this.channels.getChannel(channelName);\n    let audioCtx = surfer.backend.ac; //chained from up to down \n\n    this.audioNodes.channels[channelName] = {\n      eqHiFilterNode: audioCtx.createBiquadFilter(),\n      eqMidFilterNode: audioCtx.createBiquadFilter(),\n      eqLowFilterNode: audioCtx.createBiquadFilter(),\n      lowPassFilterNode: audioCtx.createBiquadFilter(),\n      highPassFilterNode: audioCtx.createBiquadFilter(),\n      //\n      sendNode: audioCtx.createGain(),\n      sendAndReturns: Array(this.config.externalChannels).fill(1).map(() => ({\n        send: audioCtx.createGain(),\n        return: null\n      })),\n      //\n      bypassNode: audioCtx.createGain(),\n      mainGainNode: audioCtx.createGain(),\n      analyserNode: audioCtx.createAnalyser(),\n      faderVolumeNode: audioCtx.createGain()\n    }; //--Confign\n\n    const channelNodes = this.audioNodes.channels[channelName]; //\n\n    channelNodes.analyserNode.fftSize = 256; //--EQ filters\n\n    channelNodes.eqLowFilterNode.type = \"lowshelf\";\n    channelNodes.eqLowFilterNode.frequency.setValueAtTime(this.config.low.frequency, audioCtx.currentTime);\n    channelNodes.eqHiFilterNode.type = \"highshelf\";\n    channelNodes.eqHiFilterNode.frequency.setValueAtTime(this.config.hi.frequency, audioCtx.currentTime);\n    channelNodes.eqMidFilterNode.type = \"peaking\";\n    channelNodes.eqMidFilterNode.frequency.setValueAtTime(this.config.mid.frequency, audioCtx.currentTime);\n    channelNodes.eqMidFilterNode.Q.setValueAtTime(this.config.mid.Q, audioCtx.currentTime); //--Filters\n\n    channelNodes.lowPassFilterNode.type = \"lowpass\";\n    channelNodes.lowPassFilterNode.frequency.setValueAtTime(24000, audioCtx.currentTime);\n    channelNodes.highPassFilterNode.type = \"highpass\";\n    channelNodes.highPassFilterNode.frequency.setValueAtTime(0, audioCtx.currentTime); //--Send and return\n\n    channelNodes.sendAndReturns.forEach(channel => {\n      channelNodes.sendNode.connect(channel.send); //mute on start\n\n      channel.send.gain.value = 0;\n    });\n    const sends = channelNodes.sendAndReturns.map(channel => channel.send);\n\n    if (this.external && this.external.connect) {\n      const returns = this.external.connect(sends);\n      returns.forEach((returnNode, index) => {\n        returnNode.gain.value = 0;\n        channelNodes.sendAndReturns[index].return = returnNode;\n        returnNode.connect(channelNodes.mainGainNode);\n      });\n    } //Assign in chain \n\n\n    this.channels.getChannel(channelName).backend.setFilters([channelNodes.eqLowFilterNode, channelNodes.eqHiFilterNode, channelNodes.eqMidFilterNode, channelNodes.lowPassFilterNode, channelNodes.highPassFilterNode, channelNodes.sendNode, channelNodes.bypassNode, channelNodes.mainGainNode, channelNodes.analyserNode, channelNodes.faderVolumeNode]); //-Conect to main output mixer channel\n\n    surfer.backend.gainNode.disconnect(); //surfer.backend.gainNode.connect(this.mainAudioContext.destination);\n\n    console.log(this.audioNodes.channels);\n    surfer.backend.gainNode.connect(this.audioNodes.channels['main'].preGainNode);\n    this.setUpSampleBuffers(channelName);\n  }\n\n  setGainValue(channelName, knobValue, nodeName) {\n    let gain = 1 + knobValue / 100;\n    let audioCtx = this.channels.getChannel(channelName).backend.ac;\n    let channel = this.audioNodes.channels[channelName];\n    channel[nodeName].gain.setTargetAtTime(parseFloat(gain), audioCtx.currentTime, 0.01);\n  }\n\n  setFilterValue(channelName, knobValue, nodeName) {\n    let audioCtx = this.channels.getChannel(channelName).backend.ac;\n    let channel = this.audioNodes.channels[channelName];\n    channel[nodeName].gain.setValueAtTime(knobValue, audioCtx.currentTime);\n  }\n\n  setGain(channelName, knobValue) {\n    this.setGainValue(channelName, knobValue, 'mainGainNode');\n  }\n\n  setEqHigh(channelName, knobValue) {\n    this.setFilterValue(channelName, knobValue, 'eqHiFilterNode');\n  }\n\n  setEqMid(channelName, knobValue) {\n    this.setFilterValue(channelName, knobValue, 'eqMidFilterNode');\n  }\n\n  setEqLow(channelName, knobValue) {\n    this.setFilterValue(channelName, knobValue, 'eqLowFilterNode');\n  }\n\n  setFilterFreq(channelName, knobValue) {\n    const channel = this.audioNodes.channels[channelName];\n\n    if (knobValue < 0) {\n      //low pass\n      channel.lowPassFilterNode.frequency.setValueAtTime(8000 + knobValue, this.mainAudioContext.currentTime);\n      channel.highPassFilterNode.frequency.setValueAtTime(0, this.mainAudioContext.currentTime);\n      setFilterRes.call(this, channel, channel._fitlerResonasValue);\n    } else if (knobValue > 0) {\n      // high pass filter\n      channel.lowPassFilterNode.frequency.setValueAtTime(24000, this.mainAudioContext.currentTime);\n      channel.highPassFilterNode.frequency.setValueAtTime(knobValue, this.mainAudioContext.currentTime);\n      setFilterRes.call(this, channel, channel._fitlerResonasValue);\n    } else {\n      //0 turn of all\n      channel.lowPassFilterNode.frequency.setValueAtTime(24000, this.mainAudioContext.currentTime);\n      channel.highPassFilterNode.frequency.setValueAtTime(0, this.mainAudioContext.currentTime);\n      setFilterRes.call(this, channel, 0);\n    }\n\n    function setFilterRes(channel, value = 0) {\n      channel.lowPassFilterNode.Q.setValueAtTime(value, this.mainAudioContext.currentTime);\n      channel.highPassFilterNode.Q.setValueAtTime(value, this.mainAudioContext.currentTime);\n    }\n  }\n\n  setFiterResonas(channelName, knobValue) {\n    const channel = this.audioNodes.channels[channelName];\n    channel._fitlerResonasValue = knobValue;\n  }\n\n  setSend(channelName, sendNumber, value) {\n    const sendAndReturns = this.audioNodes.channels[channelName].sendAndReturns;\n\n    if (value === 1) {\n      sendAndReturns._currentSends = sendAndReturns._currentSends ? sendAndReturns._currentSends.add(sendNumber) : new Set([sendNumber]);\n    } else if (value === 0 && sendAndReturns._currentSends) {\n      sendAndReturns._currentSends.delete(sendNumber);\n    }\n\n    let gain = 1;\n\n    if (sendAndReturns._currentSends && sendAndReturns._currentSends.size > 1) {\n      gain *= 0.71 ** (sendAndReturns._currentSends.size - 1);\n    }\n\n    sendAndReturns.forEach((channel, index) => {\n      console.log(\"for channek \" + channelName, \" gain \" + gain, \"send nubmer \" + sendNumber);\n      const {\n        send,\n        return: returns\n      } = channel; //current sending\n\n      if (sendAndReturns._currentSends.has(index)) {\n        send.gain.setTargetAtTime(gain, this.mainAudioContext.currentTime, 0.01);\n        returns.gain.setTargetAtTime(gain, this.mainAudioContext.currentTime, 0.01);\n      } else {\n        send.gain.setTargetAtTime(0, this.mainAudioContext.currentTime, 0.01);\n        returns.gain.setTargetAtTime(0, this.mainAudioContext.currentTime, 0.01);\n      }\n    }); //turn on/off bypass\n\n    const bypass = +!sendAndReturns._currentSends.size;\n    this.audioNodes.channels[channelName].bypassNode.gain.setTargetAtTime(bypass, this.mainAudioContext.currentTime, 0.01);\n  }\n\n  setFader(value) {\n    //in procent from -50%  to + 50% (not 0.01) but 1\n    let faderVolumeNodeA = this.audioNodes.channels[\"A\"].faderVolumeNode;\n    let faderVolumeNodeB = this.audioNodes.channels[\"B\"].faderVolumeNode;\n    let audioCtxA = this.channels.getChannel(\"A\").backend.ac;\n    let audioCtxB = this.channels.getChannel(\"B\").backend.ac;\n\n    if (!faderVolumeNodeA || !faderVolumeNodeB || !audioCtxA || !audioCtxB) {\n      throw new Error(`Fader value not set. Mising auiodContext or AudioNode ref\n                            .Checkout funtion setFader in mixer object`);\n    }\n\n    const {\n      a: volA,\n      b: volB\n    } = equalPowerFader(value);\n    faderVolumeNodeA.gain.setTargetAtTime(volA, audioCtxA.currentTime, 0.01);\n    faderVolumeNodeB.gain.setTargetAtTime(volB, audioCtxB.currentTime, 0.01);\n  } ///-----------------------------\n\n\n  setUpSampleBuffers(channelName) {\n    let fftSize = this.audioNodes.channels[channelName].analyserNode.fftSize;\n    this.sampleBuffers.channels[channelName] = new Float32Array(fftSize);\n  }\n\n  getChannelPeakMeter(channelName) {\n    var _this$audioNodes, _this$audioNodes$chan;\n\n    let analyser = (_this$audioNodes = this.audioNodes) === null || _this$audioNodes === void 0 ? void 0 : (_this$audioNodes$chan = _this$audioNodes.channels[channelName]) === null || _this$audioNodes$chan === void 0 ? void 0 : _this$audioNodes$chan.analyserNode;\n\n    if (!analyser) {\n      return [];\n    }\n\n    let sampleBuffer = this.sampleBuffers.channels[channelName];\n\n    if (!sampleBuffer) {\n      return [];\n    }\n\n    return this.getPeakData(analyser, sampleBuffer);\n  }\n\n  getMasterPeakMetter() {\n    const main = this.audioNodes.channels['main'];\n    const buffers = this.sampleBuffer.channels[main];\n\n    if (!buffers.pre || !buffers.post) {\n      let fftSize = main.preAnalyserNode.fftSize;\n      buffers.pre = new Float32Array(fftSize);\n      fftSize = main.postAnalyserNode.fftSize;\n      buffers.post = new Float32Array(fftSize);\n    }\n\n    return {\n      prePeak: this.getPeakData(main.preAnalyserNode, buffers.pre),\n      postPeak: this.getPeakData(main.postAnalyserNode, buffers.post)\n    };\n  }\n\n  getPeakData(analyser, sampleBuffer) {\n    analyser.getFloatTimeDomainData(sampleBuffer);\n    /*\r\n    //average \r\n    let sumOfSquares = 0;\r\n    for (let i = 0; i < sampleBuffer.length; i++) {\r\n        sumOfSquares += sampleBuffer[i] ** 2;\r\n    }\r\n      const avgPowerDecibels = 10 * Math.log10(sumOfSquares / sampleBuffer.length);\r\n    */\n    //peak \n\n    let peakPower = 0;\n\n    for (let i = 0; i < sampleBuffer.length; i++) {\n      const power = sampleBuffer[i] ** 2; // if statement is a litlebit faster that Math.max\n\n      peakPower = power > peakPower ? power : peakPower;\n    }\n\n    const peakPowerDecibels = 10 * Math.log10(peakPower);\n    return {\n      // avgdB: avgPowerDecibels,\n      peakdB: peakPowerDecibels\n    };\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/src/pages/app/core/console/mixer/mixer.js"],"names":["store","equalPowerFader","nodeChain","audioNodeChain","Mastering","Mixer","constructor","channels","console","log","config","getState","configuration","mixer","mastering","initChannelContainer","createMainChannel","connect","external","containerName","channelName","getChannelNames","mainAudioContext","AudioContext","ac","main","audioNodes","preGainNode","createGain","preAnalyserNode","createAnalyser","compressorNode","createDynamicsCompressor","postAnalyserNode","postGainNode","configCompressor","destination","getChannelInterface","getPeakMeter","getChannelPeakMeter","getMasteringInterface","getPrePeakMeter","getMasterPeakMetter","bind","getPostPeakMeter","setUpChannelsAudioNodes","surfer","getChannel","audioCtx","backend","eqHiFilterNode","createBiquadFilter","eqMidFilterNode","eqLowFilterNode","lowPassFilterNode","highPassFilterNode","sendNode","sendAndReturns","Array","externalChannels","fill","map","send","return","bypassNode","mainGainNode","analyserNode","faderVolumeNode","channelNodes","fftSize","type","frequency","setValueAtTime","low","currentTime","hi","mid","Q","forEach","channel","gain","value","sends","returns","returnNode","index","setFilters","gainNode","disconnect","setUpSampleBuffers","setGainValue","knobValue","nodeName","setTargetAtTime","parseFloat","setFilterValue","setGain","setEqHigh","setEqMid","setEqLow","setFilterFreq","setFilterRes","call","_fitlerResonasValue","setFiterResonas","setSend","sendNumber","_currentSends","add","Set","delete","size","has","bypass","setFader","faderVolumeNodeA","faderVolumeNodeB","audioCtxA","audioCtxB","Error","a","volA","b","volB","sampleBuffers","Float32Array","analyser","sampleBuffer","getPeakData","buffers","pre","post","prePeak","postPeak","getFloatTimeDomainData","peakPower","i","length","power","peakPowerDecibels","Math","log10","peakdB"],"mappings":"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","sourcesContent":["import store from \"./../../../../../store\";\r\nimport { equalPowerFader } from \"./../../../../../utils/sound/converter\"\r\nimport { nodeChain as audioNodeChain } from \"./../../../../../utils/sound/audioNodes\";\r\nimport Mastering from \"./mastering\";\r\n\r\nexport default class Mixer {\r\n    constructor(channels) {\r\n        console.log(\"create mixer\")\r\n        this.config = store.getState().configuration.mixer;\r\n\r\n        this.channels = channels;\r\n        this.mastering = new Mastering(this);\r\n\r\n        this.initChannelContainer('audioNodes');\r\n        this.initChannelContainer('sampleBuffers');\r\n        this.createMainChannel();\r\n    }\r\n\r\n\r\n    connect(external) {\r\n        this.external = external;\r\n    }\r\n\r\n    initChannelContainer(containerName) {\r\n        this[containerName] = {\r\n            channels: {\r\n            }\r\n        }\r\n        for (let channelName of [...this.channels.getChannelNames(), \"main\"]) {\r\n            this[containerName].channels = {\r\n                ...this[containerName].channels,\r\n                [channelName]: null\r\n            }\r\n        }\r\n    }\r\n\r\n    createMainChannel() {\r\n        //main audio context with is share between wavesurfer objects\r\n        this.mainAudioContext = new AudioContext();\r\n\r\n        let ac = this.mainAudioContext;\r\n        let main = this.audioNodes.channels['main'] = {};\r\n\r\n\r\n        main.preGainNode = ac.createGain();\r\n        main.preAnalyserNode = ac.createAnalyser();\r\n        main.compressorNode = ac.createDynamicsCompressor();\r\n        main.postAnalyserNode = ac.createAnalyser();\r\n        main.postGainNode = ac.createGain();\r\n\r\n        this.mastering.configCompressor();\r\n\r\n        //wiring in chain\r\n         audioNodeChain([\r\n         main.preGainNode,\r\n         main.preAnalyserNode, \r\n         main.compressorNode, \r\n         main.postAnalyserNode, \r\n         main.postGainNode,\r\n         ac.destination])\r\n    }\r\n\r\n\r\n    getChannelInterface(channelName) {\r\n        return {\r\n            getPeakMeter: () => this.getChannelPeakMeter(channelName),\r\n        }\r\n    }\r\n\r\n    getMasteringInterface(){\r\n        return {\r\n            getPrePeakMeter: this.getMasterPeakMetter.bind(null, \"pre\"),\r\n            getPostPeakMeter: this.getMasterPeakMetter.bind(null, \"post\"),\r\n        }\r\n    }\r\n\r\n    setUpChannelsAudioNodes(channelName) {\r\n        console.log(\"set up audio channel nodes\")\r\n        //surfer - waveSurfer obj\r\n        let surfer = this.channels.getChannel(channelName)\r\n        let audioCtx = surfer.backend.ac;\r\n\r\n        //chained from up to down \r\n        this.audioNodes.channels[channelName] = {\r\n            eqHiFilterNode: audioCtx.createBiquadFilter(),\r\n            eqMidFilterNode: audioCtx.createBiquadFilter(),\r\n            eqLowFilterNode: audioCtx.createBiquadFilter(),\r\n            lowPassFilterNode: audioCtx.createBiquadFilter(),\r\n            highPassFilterNode: audioCtx.createBiquadFilter(),\r\n            //\r\n            sendNode: audioCtx.createGain(),\r\n            sendAndReturns: Array(this.config.externalChannels).fill(1).map(() => ({\r\n                send: audioCtx.createGain(),\r\n                return: null\r\n            })),\r\n            //\r\n            bypassNode: audioCtx.createGain(),\r\n            mainGainNode: audioCtx.createGain(),\r\n            analyserNode: audioCtx.createAnalyser(),\r\n            faderVolumeNode: audioCtx.createGain(),\r\n        }\r\n\r\n        //--Confign\r\n        const channelNodes = this.audioNodes.channels[channelName];\r\n        //\r\n        channelNodes.analyserNode.fftSize = 256;\r\n        //--EQ filters\r\n        channelNodes.eqLowFilterNode.type = \"lowshelf\";\r\n        channelNodes.eqLowFilterNode.frequency.setValueAtTime(this.config.low.frequency, audioCtx.currentTime);\r\n\r\n        channelNodes.eqHiFilterNode.type = \"highshelf\";\r\n        channelNodes.eqHiFilterNode.frequency.setValueAtTime(this.config.hi.frequency, audioCtx.currentTime);\r\n\r\n        channelNodes.eqMidFilterNode.type = \"peaking\";\r\n        channelNodes.eqMidFilterNode.frequency.setValueAtTime(this.config.mid.frequency, audioCtx.currentTime);\r\n        channelNodes.eqMidFilterNode.Q.setValueAtTime(this.config.mid.Q, audioCtx.currentTime);\r\n        //--Filters\r\n        channelNodes.lowPassFilterNode.type = \"lowpass\";\r\n        channelNodes.lowPassFilterNode.frequency.setValueAtTime(24000, audioCtx.currentTime);\r\n\r\n        channelNodes.highPassFilterNode.type = \"highpass\";\r\n        channelNodes.highPassFilterNode.frequency.setValueAtTime(0, audioCtx.currentTime);\r\n        //--Send and return\r\n        channelNodes.sendAndReturns.forEach((channel) => {\r\n            channelNodes.sendNode.connect(channel.send);\r\n            //mute on start\r\n            channel.send.gain.value = 0;\r\n        });\r\n        const sends = channelNodes.sendAndReturns.map(channel => channel.send);\r\n        if (this.external && this.external.connect) {\r\n            const returns = this.external.connect(sends);\r\n            returns.forEach((returnNode, index) => {\r\n                returnNode.gain.value = 0;\r\n                channelNodes.sendAndReturns[index].return = returnNode;\r\n                returnNode.connect(channelNodes.mainGainNode);\r\n            })\r\n        }\r\n\r\n        //Assign in chain \r\n        this.channels.getChannel(channelName).backend.setFilters([\r\n            channelNodes.eqLowFilterNode,\r\n            channelNodes.eqHiFilterNode,\r\n            channelNodes.eqMidFilterNode,\r\n            channelNodes.lowPassFilterNode,\r\n            channelNodes.highPassFilterNode,\r\n            channelNodes.sendNode,\r\n            channelNodes.bypassNode,\r\n            channelNodes.mainGainNode,\r\n            channelNodes.analyserNode,\r\n            channelNodes.faderVolumeNode,\r\n        ])\r\n\r\n        //-Conect to main output mixer channel\r\n        surfer.backend.gainNode.disconnect();\r\n        //surfer.backend.gainNode.connect(this.mainAudioContext.destination);\r\n        console.log(this.audioNodes.channels)\r\n        surfer.backend.gainNode.connect(this.audioNodes.channels['main'].preGainNode);\r\n        this.setUpSampleBuffers(channelName);\r\n    }\r\n\r\n\r\n\r\n    setGainValue(channelName, knobValue, nodeName) {\r\n        let gain = 1 + knobValue / 100;\r\n        let audioCtx = this.channels.getChannel(channelName).backend.ac;\r\n\r\n        let channel = this.audioNodes.channels[channelName];\r\n        channel[nodeName].gain.setTargetAtTime(parseFloat(gain), audioCtx.currentTime, 0.01);\r\n    }\r\n\r\n    setFilterValue(channelName, knobValue, nodeName) {\r\n        let audioCtx = this.channels.getChannel(channelName).backend.ac;\r\n\r\n        let channel = this.audioNodes.channels[channelName];\r\n        channel[nodeName].gain.setValueAtTime(knobValue, audioCtx.currentTime);\r\n    }\r\n\r\n    setGain(channelName, knobValue) {\r\n        this.setGainValue(channelName, knobValue, 'mainGainNode');\r\n    }\r\n\r\n    setEqHigh(channelName, knobValue) {\r\n        this.setFilterValue(channelName, knobValue, 'eqHiFilterNode');\r\n    }\r\n\r\n    setEqMid(channelName, knobValue) {\r\n        this.setFilterValue(channelName, knobValue, 'eqMidFilterNode');\r\n    }\r\n\r\n    setEqLow(channelName, knobValue) {\r\n        this.setFilterValue(channelName, knobValue, 'eqLowFilterNode');\r\n    }\r\n\r\n    setFilterFreq(channelName, knobValue) {\r\n        const channel = this.audioNodes.channels[channelName];\r\n        if (knobValue < 0) {\r\n            //low pass\r\n            channel.lowPassFilterNode.frequency\r\n                .setValueAtTime(8000 + knobValue, this.mainAudioContext.currentTime);\r\n\r\n            channel.highPassFilterNode.frequency\r\n                .setValueAtTime(0, this.mainAudioContext.currentTime);\r\n            setFilterRes.call(this, channel, channel._fitlerResonasValue);\r\n        } else if (knobValue > 0) {\r\n            // high pass filter\r\n            channel.lowPassFilterNode.frequency\r\n                .setValueAtTime(24000, this.mainAudioContext.currentTime);\r\n\r\n            channel.highPassFilterNode.frequency\r\n                .setValueAtTime(knobValue, this.mainAudioContext.currentTime);\r\n            setFilterRes.call(this, channel, channel._fitlerResonasValue);\r\n        } else {\r\n            //0 turn of all\r\n            channel.lowPassFilterNode.frequency\r\n                .setValueAtTime(24000, this.mainAudioContext.currentTime);\r\n\r\n            channel.highPassFilterNode.frequency\r\n                .setValueAtTime(0, this.mainAudioContext.currentTime);\r\n                \r\n            setFilterRes.call(this, channel, 0);\r\n        }\r\n\r\n        function setFilterRes(channel, value = 0) {\r\n            channel.lowPassFilterNode.Q\r\n                .setValueAtTime(value, this.mainAudioContext.currentTime);\r\n\r\n            channel.highPassFilterNode.Q\r\n                .setValueAtTime(value, this.mainAudioContext.currentTime);\r\n        }\r\n    }\r\n\r\n    setFiterResonas(channelName, knobValue) {\r\n        const channel = this.audioNodes.channels[channelName];\r\n        channel._fitlerResonasValue = knobValue;\r\n    }\r\n\r\n\r\n    setSend(channelName, sendNumber, value) {\r\n        const sendAndReturns = this.audioNodes.channels[channelName].sendAndReturns;\r\n        if (value === 1) {\r\n            sendAndReturns._currentSends =\r\n                (sendAndReturns._currentSends) ? sendAndReturns._currentSends.add(sendNumber) : new Set([sendNumber]);\r\n        } else if (value === 0 && sendAndReturns._currentSends) {\r\n            sendAndReturns._currentSends.delete(sendNumber);\r\n        }\r\n\r\n        let gain = 1;\r\n        if (sendAndReturns._currentSends && sendAndReturns._currentSends.size > 1) {\r\n            gain *= 0.71 ** (sendAndReturns._currentSends.size - 1);\r\n        }\r\n\r\n        sendAndReturns.forEach((channel, index) => {\r\n            console.log(\"for channek \" + channelName, \" gain \" + gain, \"send nubmer \" + sendNumber)\r\n            const { send, return: returns } = channel;\r\n            //current sending\r\n            if (sendAndReturns._currentSends.has(index)) {\r\n                send.gain.setTargetAtTime(gain, this.mainAudioContext.currentTime, 0.01);\r\n                returns.gain.setTargetAtTime(gain, this.mainAudioContext.currentTime, 0.01);\r\n            } else {\r\n                send.gain.setTargetAtTime(0, this.mainAudioContext.currentTime, 0.01);\r\n                returns.gain.setTargetAtTime(0, this.mainAudioContext.currentTime, 0.01);\r\n            }\r\n        })\r\n\r\n        //turn on/off bypass\r\n        const bypass = +!sendAndReturns._currentSends.size;\r\n        this.audioNodes.channels[channelName].bypassNode\r\n            .gain.setTargetAtTime(bypass, this.mainAudioContext.currentTime, 0.01);\r\n    }\r\n\r\n\r\n    setFader(value) {//in procent from -50%  to + 50% (not 0.01) but 1\r\n        let faderVolumeNodeA = this.audioNodes.channels[\"A\"].faderVolumeNode;\r\n        let faderVolumeNodeB = this.audioNodes.channels[\"B\"].faderVolumeNode;\r\n        let audioCtxA = this.channels.getChannel(\"A\").backend.ac;\r\n        let audioCtxB = this.channels.getChannel(\"B\").backend.ac;\r\n\r\n        if (!faderVolumeNodeA || !faderVolumeNodeB || !audioCtxA || !audioCtxB) {\r\n            throw new Error(`Fader value not set. Mising auiodContext or AudioNode ref\r\n                            .Checkout funtion setFader in mixer object`);\r\n        }\r\n\r\n        const { a: volA, b: volB } = equalPowerFader(value)\r\n\r\n        faderVolumeNodeA.gain.setTargetAtTime(volA, audioCtxA.currentTime, 0.01);\r\n        faderVolumeNodeB.gain.setTargetAtTime(volB, audioCtxB.currentTime, 0.01);\r\n    }\r\n\r\n    ///-----------------------------\r\n\r\n    setUpSampleBuffers(channelName) {\r\n        let fftSize = this.audioNodes.channels[channelName].analyserNode.fftSize;\r\n        this.sampleBuffers.channels[channelName] = new Float32Array(fftSize);\r\n    }\r\n\r\n    getChannelPeakMeter(channelName) {\r\n        let analyser = this.audioNodes?.channels[channelName]?.analyserNode\r\n        if (!analyser) {\r\n            return [];\r\n        }\r\n        let sampleBuffer = this.sampleBuffers.channels[channelName];\r\n        if (!sampleBuffer) {\r\n            return [];\r\n        }\r\n        return this.getPeakData(analyser, sampleBuffer)\r\n    }\r\n\r\n    getMasterPeakMetter(){\r\n        const main = this.audioNodes.channels['main'];\r\n        const buffers = this.sampleBuffer.channels[main];\r\n        if(!buffers.pre || !buffers.post){\r\n            let fftSize = main.preAnalyserNode.fftSize;\r\n            buffers.pre = new Float32Array(fftSize);\r\n            fftSize = main.postAnalyserNode.fftSize;\r\n            buffers.post = new Float32Array(fftSize);\r\n        }\r\n\r\n        return {\r\n            prePeak : this.getPeakData(main.preAnalyserNode, buffers.pre),\r\n            postPeak : this.getPeakData(main.postAnalyserNode, buffers.post),\r\n        }\r\n    }\r\n\r\n    \r\n    getPeakData(analyser, sampleBuffer) {\r\n        analyser.getFloatTimeDomainData(sampleBuffer);\r\n\r\n        /*\r\n        //average \r\n        let sumOfSquares = 0;\r\n        for (let i = 0; i < sampleBuffer.length; i++) {\r\n            sumOfSquares += sampleBuffer[i] ** 2;\r\n        }\r\n\r\n        const avgPowerDecibels = 10 * Math.log10(sumOfSquares / sampleBuffer.length);\r\n*/\r\n        //peak \r\n\r\n        let peakPower = 0;\r\n        for (let i = 0; i < sampleBuffer.length; i++) {\r\n            const power = sampleBuffer[i] ** 2;\r\n            // if statement is a litlebit faster that Math.max\r\n            peakPower = (power > peakPower) ? power : peakPower;\r\n        }\r\n        const peakPowerDecibels = 10 * Math.log10(peakPower);\r\n\r\n        return {\r\n            // avgdB: avgPowerDecibels,\r\n            peakdB: peakPowerDecibels,\r\n        }\r\n    }\r\n\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}