{"ast":null,"code":"//const map = require('unist-util-map');\nconst filter = require('unist-util-filter');\n\nconst vFile = require('vfile');\n\nmodule.exports = attacher;\n\nconst newFileFrom = (vfile, contents) => {\n  return vFile({ ...vfile,\n    contents: contents\n  });\n};\n\nfunction attacher() {\n  // console.log(\"the this\", this.Parser);\n  const pattern = /{\\.(\\w+)}/;\n  const processor = this;\n\n  function transformer(tree, file) {\n    let inlineMethods = processor.Parser.prototype.inlineMethods;\n    let blockMethods = processor.Parser.prototype.blockMethods;\n    console.log(tree);\n\n    const modify = node => {\n      if (node.children && node.children.find(child => child.type === \"cssClass\")) {}\n\n      return node;\n    };\n\n    return tree;\n  }\n\n  return transformer;\n} // console.log(\"before modification\", tree)\n//\n// const modify = node => {\n//     console.log(\"in modify\", node)\n//     if(!node.children) return node;\n//     node.children = node.children.map( node => {\n//         // //\n//         // if(node.type === \"text\"){\n//         //     let match = pattern.exec(node.value);\n//         //     if(!match) return node;\n//         //     const value = node.value.replace(match[0], \"\");\n//         //     const subNodes = processor.parse(newFileFrom(file, value))?.children;\n//         //     // if(subNodes.some( subNode => blockMethods.includes(subNode.type)\n//         //     //     && [\"paragraph\", \"heading\"].includes(parent.type))){\n//         //     //     console.log(\"yeas it is\", subNodes[0]);\n//         //     //     parent = subNodes[0];\n//         //     //     parent.className = match[1];\n//         //     //     return;\n//         //     // }\n//         //     let newNode = subNodes[0];\n//         //     newNode.className = match[1];\n//         //     return newNode;\n//         // }\n//\n//         //\n//         if(!node.children) return node;\n//         let parent = node;\n//         const children = node.children.map( node => {\n//             console.log(\"visted\", node, parent)\n//             if(node.children){\n//                 node = modify(node);\n//             }\n//             if(node.type === \"text\"){\n//                 let match = pattern.exec(node.value);\n//                 if(!match) return node;\n//                 const value = node.value.replace(match[0], \"\");\n//                 const subNodes = processor.parse(newFileFrom(file, value))?.children;\n//                 if(subNodes.some( subNode => blockMethods.includes(subNode.type)\n//                     && [\"paragraph\", \"heading\"].includes(parent.type))){\n//                     console.log(\"yeas it is\", subNodes[0]);\n//                     parent = subNodes[0];\n//                     parent.className = match[1];\n//                     return;\n//                 }\n//                 let newNode = subNodes[0];\n//                 newNode.className = match[1];\n//                 return newNode;\n//                 console.log(\"subnodes\", subNodes)\n//             }\n//             return node;\n//         }).filter( node => !!node);\n//         if(children.length){\n//             parent.children = children;\n//         }\n//         return parent;\n//         // let match = pattern.exec(node.value);\n//         // if(!match) return node;\n//         // const value = node.value.replace(match[0], \"\");\n//         // const subNodes = processor.parse(newFileFrom(file, value))?.children;\n//         // console.log(\"sub nodes\" , subNodes);\n//         // return node;\n//\n//     })\n//     return node;\n// }\n//\n// // if(node.type !== \"text\") return modify(node);\n// // console.log(\"node in\", node)\n// // let match = pattern.exec(node.value);\n// // if(!match) return node;\n// // const value = node.value.replace(match[0], \"\");\n// // const subNodes = processor.parse(newFileFrom(file, value))?.children;\n// // // console.log(\"parnet subnodes\", parent, subNodes)\n// // if(subNodes.some( subNode => subNode.type === \"thematicBreak\")\n// //     && parent.type === \"paragraph\"){\n// //     parent = subNodes.find( subNode => subNode.type === \"thematicBreak\");\n// //     parent.className = match[1];\n// //     parent.position = node.position;\n// //     parent.position.end.column-=match[0].length;\n// //     parent.position.end.offset-=match[0].length;\n// //\n// // }\n// const next =  modify(tree);\n// console.log(\"after modyfication\", next);\n// return next;","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/introduction/MarkDonwExtesnion/reamark-hclass.js"],"names":["filter","require","vFile","module","exports","attacher","newFileFrom","vfile","contents","pattern","processor","transformer","tree","file","inlineMethods","Parser","prototype","blockMethods","console","log","modify","node","children","find","child","type"],"mappings":"AAAA;AACA,MAAMA,MAAM,GAAGC,OAAO,CAAC,mBAAD,CAAtB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AAGAE,MAAM,CAACC,OAAP,GAAiBC,QAAjB;;AAEA,MAAMC,WAAW,GAAG,CAACC,KAAD,EAAQC,QAAR,KAAqB;AACrC,SAAON,KAAK,CAAC,EAAC,GAAGK,KAAJ;AAAWC,IAAAA,QAAQ,EAAEA;AAArB,GAAD,CAAZ;AACH,CAFD;;AAIA,SAASH,QAAT,GAAoB;AACjB;AACC,QAAMI,OAAO,GAAG,WAAhB;AACA,QAAMC,SAAS,GAAG,IAAlB;;AACA,WAASC,WAAT,CAAqBC,IAArB,EAA2BC,IAA3B,EAAiC;AAC7B,QAAIC,aAAa,GAAEJ,SAAS,CAACK,MAAV,CAAiBC,SAAjB,CAA2BF,aAA9C;AACA,QAAIG,YAAY,GAAGP,SAAS,CAACK,MAAV,CAAiBC,SAAjB,CAA2BC,YAA9C;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAYP,IAAZ;;AACA,UAAMQ,MAAM,GAAGC,IAAI,IAAI;AAEnB,UAAGA,IAAI,CAACC,QAAL,IACCD,IAAI,CAACC,QAAL,CAAcC,IAAd,CAAoBC,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAe,UAA5C,CADJ,EAC4D,CAE3D;;AACD,aAAOJ,IAAP;AACH,KAPD;;AAQA,WAAOT,IAAP;AACH;;AAED,SAAOD,WAAP;AACH,C,CAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["//const map = require('unist-util-map');\r\nconst filter = require('unist-util-filter')\r\nconst vFile = require('vfile');\r\n\r\n\r\nmodule.exports = attacher\r\n\r\nconst newFileFrom = (vfile, contents) => {\r\n    return vFile({...vfile, contents: contents})\r\n}\r\n\r\nfunction attacher() {\r\n   // console.log(\"the this\", this.Parser);\r\n    const pattern = /{\\.(\\w+)}/;\r\n    const processor = this;\r\n    function transformer(tree, file) {\r\n        let inlineMethods =processor.Parser.prototype.inlineMethods;\r\n        let blockMethods = processor.Parser.prototype.blockMethods;\r\n        console.log(tree)\r\n        const modify = node => {\r\n\r\n            if(node.children &&\r\n                node.children.find( child => child.type === \"cssClass\")){\r\n\r\n            }\r\n            return node;\r\n        }\r\n        return tree;\r\n    }\r\n\r\n    return transformer\r\n}\r\n\r\n\r\n// console.log(\"before modification\", tree)\r\n//\r\n// const modify = node => {\r\n//     console.log(\"in modify\", node)\r\n//     if(!node.children) return node;\r\n//     node.children = node.children.map( node => {\r\n//         // //\r\n//         // if(node.type === \"text\"){\r\n//         //     let match = pattern.exec(node.value);\r\n//         //     if(!match) return node;\r\n//         //     const value = node.value.replace(match[0], \"\");\r\n//         //     const subNodes = processor.parse(newFileFrom(file, value))?.children;\r\n//         //     // if(subNodes.some( subNode => blockMethods.includes(subNode.type)\r\n//         //     //     && [\"paragraph\", \"heading\"].includes(parent.type))){\r\n//         //     //     console.log(\"yeas it is\", subNodes[0]);\r\n//         //     //     parent = subNodes[0];\r\n//         //     //     parent.className = match[1];\r\n//         //     //     return;\r\n//         //     // }\r\n//         //     let newNode = subNodes[0];\r\n//         //     newNode.className = match[1];\r\n//         //     return newNode;\r\n//         // }\r\n//\r\n//         //\r\n//         if(!node.children) return node;\r\n//         let parent = node;\r\n//         const children = node.children.map( node => {\r\n//             console.log(\"visted\", node, parent)\r\n//             if(node.children){\r\n//                 node = modify(node);\r\n//             }\r\n//             if(node.type === \"text\"){\r\n//                 let match = pattern.exec(node.value);\r\n//                 if(!match) return node;\r\n//                 const value = node.value.replace(match[0], \"\");\r\n//                 const subNodes = processor.parse(newFileFrom(file, value))?.children;\r\n//                 if(subNodes.some( subNode => blockMethods.includes(subNode.type)\r\n//                     && [\"paragraph\", \"heading\"].includes(parent.type))){\r\n//                     console.log(\"yeas it is\", subNodes[0]);\r\n//                     parent = subNodes[0];\r\n//                     parent.className = match[1];\r\n//                     return;\r\n//                 }\r\n//                 let newNode = subNodes[0];\r\n//                 newNode.className = match[1];\r\n//                 return newNode;\r\n//                 console.log(\"subnodes\", subNodes)\r\n//             }\r\n//             return node;\r\n//         }).filter( node => !!node);\r\n//         if(children.length){\r\n//             parent.children = children;\r\n//         }\r\n//         return parent;\r\n//         // let match = pattern.exec(node.value);\r\n//         // if(!match) return node;\r\n//         // const value = node.value.replace(match[0], \"\");\r\n//         // const subNodes = processor.parse(newFileFrom(file, value))?.children;\r\n//         // console.log(\"sub nodes\" , subNodes);\r\n//         // return node;\r\n//\r\n//     })\r\n//     return node;\r\n// }\r\n//\r\n// // if(node.type !== \"text\") return modify(node);\r\n// // console.log(\"node in\", node)\r\n// // let match = pattern.exec(node.value);\r\n// // if(!match) return node;\r\n// // const value = node.value.replace(match[0], \"\");\r\n// // const subNodes = processor.parse(newFileFrom(file, value))?.children;\r\n// // // console.log(\"parnet subnodes\", parent, subNodes)\r\n// // if(subNodes.some( subNode => subNode.type === \"thematicBreak\")\r\n// //     && parent.type === \"paragraph\"){\r\n// //     parent = subNodes.find( subNode => subNode.type === \"thematicBreak\");\r\n// //     parent.className = match[1];\r\n// //     parent.position = node.position;\r\n// //     parent.position.end.column-=match[0].length;\r\n// //     parent.position.end.offset-=match[0].length;\r\n// //\r\n// // }\r\n// const next =  modify(tree);\r\n// console.log(\"after modyfication\", next);\r\n// return next;\r\n"]},"metadata":{},"sourceType":"module"}