{"ast":null,"code":"import store from \"./../../../../../store\";\nimport { setAvailableEffects } from \"./../../../../../actions\";\nimport { equalPower } from \"./../../../../../utils/sound/converter\"; //import { throttel } from \"./../../../../../utils/functions/lodash\";\n\nimport Reverb from \"./effects/reverb/reverb\";\nimport Delay from \"./effects/delay/delay\";\nexport default class Effector {\n  constructor(audioContext) {\n    this.config = store.getState().configuration.effector;\n    this.mainAC = audioContext;\n    this.buildChannels(this.config.channels);\n    this.effects = {\n      \"reverb\": {\n        create: Reverb,\n        params: Reverb.defaultParams().params\n      },\n      \"delay\": {\n        create: Delay,\n        params: Delay.defaultParams().params\n      }\n    };\n    const exportEffects = {};\n    Object.entries(this.effects).forEach(([key, element]) => exportEffects[key] = element.params);\n    store.dispatch(setAvailableEffects(exportEffects));\n  }\n\n  buildChannels(channelNumber) {\n    this.channels = Array.from({\n      length: channelNumber\n    }, (_, index) => ({\n      channelNumber: index\n    }));\n\n    for (let chNum = 0; chNum < channelNumber; chNum++) {\n      const channel = this.channels[chNum];\n      channel.inputNode = this.mainAC.createGain();\n      channel.dryNode = this.mainAC.createGain();\n      ;\n      channel.wetNode = this.mainAC.createGain();\n      channel.outputNode = this.mainAC.createGain();\n      channel.inputNode.connect(channel.dryNode);\n      channel.inputNode.connect(channel.wetNode);\n      channel.dryNode.connect(channel.outputNode);\n      channel.wetNode.connect(channel.outputNode);\n      channel.wetNode.gain.setValueAtTime(0, 0);\n    }\n  }\n\n  connect(inputs) {\n    const outputs = [];\n    inputs.forEach((inputNode, chNum) => {\n      inputNode.connect(this.channels[chNum].inputNode);\n      const output = this.mainAC.createGain();\n      this.channels[chNum].outputNode.connect(output);\n      outputs.push(output);\n    });\n    return outputs;\n  }\n\n  setDryWet(channelNumber, value) {\n    channelNumber--;\n    const channel = this.channels[channelNumber];\n    const {\n      a: dry,\n      b: wet\n    } = equalPower(value / 100);\n    console.log(\"dry \" + dry, \"Wet \" + wet);\n    channel.dryNode.gain.setTargetAtTime(dry, this.mainAC.currentTime, 0.01);\n    channel.wetNode.gain.setTargetAtTime(wet, this.mainAC.currentTime, 0.01);\n  }\n\n  setEffect(channelNumber, effectName) {\n    channelNumber--; //array index\n\n    const channel = this.channels[channelNumber];\n\n    if (effectName) {\n      this.disconectCurrent(channel);\n      let params = this.assingDefaultParams({}, effectName);\n      const effectorChannel = store.getState().effector.channels;\n\n      if (effectorChannel && effectorChannel[channelNumber]) {\n        params = { ...effectorChannel[channelNumber].effects[effectName]\n        };\n      }\n\n      const effect = new this.effects[effectName].create(this.mainAC, params);\n      channel.currentEffect = effect;\n      channel.inputNode.connect(channel.dryNode);\n      effect.connect(channel.inputNode, channel.wetNode);\n    } else {\n      this.disconectCurrent(channel);\n    }\n  }\n\n  assingDefaultParams(obj, effect) {\n    Object.entries(this.effects[effect].params).forEach(([key, value]) => {\n      obj[key] = value.defaultValue;\n    });\n    return obj;\n  }\n\n  setParam(channelNumber, effect, param) {\n    channelNumber--;\n    const channel = this.channels[channelNumber];\n\n    if (channel.currentEffect && channel.currentEffect.name === effect) {\n      Object.entries(param).forEach(([key, value]) => {\n        channel.currentEffect[key] = value;\n      });\n    }\n  }\n\n  disconectCurrent(channel) {\n    if (channel.currentEffect) {\n      channel.inputNode.disconnect();\n      channel.inputNode.connect(channel.dryNode);\n      channel.inputNode.connect(channel.wetNode);\n      channel.currentEffect.disconnect();\n      channel.currentEffect = null;\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/src/pages/app/core/console/effector/effector.js"],"names":["store","setAvailableEffects","equalPower","Reverb","Delay","Effector","constructor","audioContext","config","getState","configuration","effector","mainAC","buildChannels","channels","effects","create","params","defaultParams","exportEffects","Object","entries","forEach","key","element","dispatch","channelNumber","Array","from","length","_","index","chNum","channel","inputNode","createGain","dryNode","wetNode","outputNode","connect","gain","setValueAtTime","inputs","outputs","output","push","setDryWet","value","a","dry","b","wet","console","log","setTargetAtTime","currentTime","setEffect","effectName","disconectCurrent","assingDefaultParams","effectorChannel","effect","currentEffect","obj","defaultValue","setParam","param","name","disconnect"],"mappings":"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","sourcesContent":["\r\nimport store from \"./../../../../../store\";\r\nimport { setAvailableEffects } from \"./../../../../../actions\";\r\nimport { equalPower } from \"./../../../../../utils/sound/converter\"\r\n//import { throttel } from \"./../../../../../utils/functions/lodash\";\r\nimport Reverb from \"./effects/reverb/reverb\";\r\nimport Delay from \"./effects/delay/delay\";\r\n\r\n\r\n\r\nexport default class Effector {\r\n    constructor(audioContext) {\r\n        this.config = store.getState().configuration.effector;\r\n        this.mainAC = audioContext;\r\n\r\n        this.buildChannels(this.config.channels);\r\n\r\n\r\n        this.effects = {\r\n            \"reverb\": {\r\n                create: Reverb,\r\n                params: Reverb.defaultParams().params,\r\n            },\r\n            \"delay\": {\r\n                create: Delay,\r\n                params: Delay.defaultParams().params\r\n            }\r\n        }\r\n\r\n        const exportEffects = {};\r\n        Object.entries(this.effects).forEach(([key, element]) =>\r\n            exportEffects[key] = element.params\r\n        );\r\n        store.dispatch(setAvailableEffects(exportEffects));\r\n    }\r\n\r\n    buildChannels(channelNumber) {\r\n        this.channels =\r\n            Array.from({ length: channelNumber }, ( _ , index) => ({ channelNumber: index }));\r\n\r\n        for (let chNum = 0; chNum < channelNumber; chNum++) {\r\n            const channel = this.channels[chNum];\r\n\r\n            channel.inputNode = this.mainAC.createGain();\r\n            channel.dryNode = this.mainAC.createGain();;\r\n            channel.wetNode = this.mainAC.createGain();\r\n            channel.outputNode = this.mainAC.createGain();\r\n\r\n            channel.inputNode.connect(channel.dryNode);\r\n            channel.inputNode.connect(channel.wetNode);\r\n            channel.dryNode.connect(channel.outputNode);\r\n            channel.wetNode.connect(channel.outputNode);\r\n\r\n            channel.wetNode.gain.setValueAtTime(0,0)\r\n        }\r\n    }\r\n\r\n    connect(inputs) {   \r\n        const outputs = [];\r\n        \r\n        inputs.forEach((inputNode, chNum) => {\r\n            inputNode.connect(this.channels[chNum].inputNode);\r\n            \r\n            const output = this.mainAC.createGain();\r\n            this.channels[chNum].outputNode.connect(output);\r\n            outputs.push(output)\r\n        });\r\n    \r\n        return outputs;\r\n    }\r\n\r\n\r\n    setDryWet(channelNumber, value) {\r\n        channelNumber--;\r\n        const channel = this.channels[channelNumber];\r\n\r\n        const {a: dry, b: wet} = equalPower(value / 100);\r\n\r\n        console.log(\"dry \" + dry, \"Wet \"+ wet )\r\n\r\n        channel.dryNode.gain.setTargetAtTime(dry, this.mainAC.currentTime, 0.01);\r\n        channel.wetNode.gain.setTargetAtTime(wet, this.mainAC.currentTime, 0.01);\r\n    }\r\n\r\n    setEffect(channelNumber, effectName) {\r\n        channelNumber--;//array index\r\n        const channel = this.channels[channelNumber];\r\n\r\n        if (effectName) {\r\n            this.disconectCurrent(channel);\r\n\r\n            let params = this.assingDefaultParams({}, effectName);\r\n\r\n            const effectorChannel = store.getState().effector.channels;\r\n\r\n            if (effectorChannel && effectorChannel[channelNumber]) {\r\n                params = { ...effectorChannel[channelNumber].effects[effectName] }\r\n            }\r\n\r\n            const effect = new this.effects[effectName].create(this.mainAC, params);\r\n\r\n            channel.currentEffect = effect;\r\n            channel.inputNode.connect(channel.dryNode)\r\n\r\n            effect.connect(channel.inputNode, channel.wetNode)\r\n\r\n        } else {\r\n            this.disconectCurrent(channel);\r\n        }\r\n\r\n    }\r\n\r\n    assingDefaultParams(obj, effect) {\r\n        Object.entries(this.effects[effect].params).forEach(([key, value]) => {\r\n            obj[key] = value.defaultValue;\r\n        })\r\n        return obj;\r\n    }\r\n\r\n    setParam(channelNumber, effect, param) {\r\n        channelNumber--;\r\n        const channel = this.channels[channelNumber];\r\n        if (channel.currentEffect && channel.currentEffect.name === effect) {\r\n            Object.entries(param).forEach(([key, value]) => {\r\n                channel.currentEffect[key] = value;\r\n            })\r\n        }\r\n    }\r\n\r\n\r\n    disconectCurrent(channel) {\r\n        if (channel.currentEffect) {\r\n            channel.inputNode.disconnect();\r\n            channel.inputNode.connect(channel.dryNode);\r\n            channel.inputNode.connect(channel.wetNode);\r\n            channel.currentEffect.disconnect();\r\n            channel.currentEffect = null;\r\n        }\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}