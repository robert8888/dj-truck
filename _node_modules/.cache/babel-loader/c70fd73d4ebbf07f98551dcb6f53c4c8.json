{"ast":null,"code":"import store from \"./../../../../../store/\";\nimport ChannelBuilder from \"./channelBuilder/channelBuilder\";\nimport Synchronizer from \"./sync/synchronizer\";\nimport { getApi } from \"./../../../../../apis/apiProvider\";\nimport { setCuePoint, setChannelReady, setLoop } from \"./../../../../../actions\";\nimport Looper from \"./looper/looper\";\nexport default class Channels {\n  constructor() {\n    this.channelBuilder = new ChannelBuilder();\n    this.synchronizer = new Synchronizer(this);\n    this.looper = new Looper();\n    this.dispatch = store.dispatch;\n    this.channels = {\n      A: null,\n      B: null\n    };\n    this.stdDivceDiff = {};\n  }\n\n  getChannelNames() {\n    return Object.keys(this.channels);\n  }\n\n  createChannel(channelName, ...args) {\n    this.channels[channelName] = this.channelBuilder.create(channelName, ...args);\n  }\n\n  createBars(channelName, values) {\n    this.channelBuilder.createBars(this.getFullChannel(channelName), values);\n  }\n\n  getChannel(channelName) {\n    return this.channels[channelName].master;\n  }\n\n  getFullChannel(channelName) {\n    return this.channels[channelName];\n  }\n\n  getChannelInterface(channelName) {\n    const channel = this.getChannel(channelName);\n    return {\n      getSyncBarPosition: () => this.synchronizer.getSyncBarPostion.call(this.synchronizer, channelName),\n      getCurrentTime: () => ({\n        time: channel.getCurrentTime(),\n        left: channel.getDuration() - channel.getCurrentTime()\n      })\n    };\n  } //--------------------------------------------\n\n\n  loadTrack(channelName, track) {\n    if (!track || !track.source || !track.sourceId) return;\n    let api = getApi(track.source);\n    let url = api && api.getUrl(track.sourceId) || null;\n    this.dispatch(setChannelReady(false, channelName));\n    let channel = this.getChannel(channelName);\n\n    if (channel.loadWithEvent) {\n      channel.loadWithEvent(url);\n    } else {\n      channel.load(url);\n    }\n  }\n\n  togglePlay(channelName, currentValue) {\n    if (currentValue) {\n      this.getChannel(channelName).pause();\n      this.dispatch(setLoop(channelName, false));\n    } else {\n      this.getChannel(channelName).play();\n    }\n  }\n\n  toggleCue(channelName, currentValue) {\n    const player = this.getChannel(channelName);\n    const isPaused = store.getState().console.channel[channelName].playBackState.paused;\n\n    if (!currentValue && isPaused) {\n      // back to cue point and pause\n      let cuePoint = store.getState().console.channel[channelName].playBackState.cuePoint; //in seconds\n      //seek to\n\n      player.pause();\n      player.backend.seekTo(cuePoint);\n      player.drawer.progress(cuePoint / player.getDuration());\n      player.drawer.recenter(cuePoint / player.getDuration());\n    } else if (!currentValue) {\n      //Cancel cue and play\n      if (!player.isPlaying()) {\n        player.play();\n      }\n    } else {\n      const cuePoint = this.getChannel(channelName).getCurrentTime();\n      this.getChannel(channelName).play();\n      this.dispatch(setCuePoint(channelName, cuePoint)); // in float seconds\n    }\n  }\n\n  adjustPitch(channelName, currentValue) {\n    let waveSurfer = this.getChannel(channelName);\n    waveSurfer.setPlaybackRate(1 + currentValue / 100);\n    waveSurfer.fireEvent(\"interaction\");\n    /*\r\n    if(channel?.backend?.source instanceof AudioBufferSourceNode){\r\n        const rate = 1 + currentValue / 100\r\n        channel.backend.source.playbackRate.value = rate; \r\n        channel.backend.playbackRate = rate;\r\n    }*/\n  }\n\n  sync(channelName) {\n    this.synchronizer.sync(channelName);\n  }\n\n  makeLoop(channelName, {\n    loopLength\n  }) {\n    try {\n      this.looper.makeLoop(this.getFullChannel(channelName), loopLength);\n    } catch {\n      this.dispatch(setLoop(channelName, false));\n    }\n  }\n\n  endLoop(channelName) {\n    this.looper.endLoop(this.getFullChannel(channelName));\n  }\n\n  updateLoop(channelName, {\n    loopLength\n  }) {\n    this.looper.updateLoop(this.getFullChannel(channelName), loopLength);\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/console/core/console/channels/channels.js"],"names":["store","ChannelBuilder","Synchronizer","getApi","setCuePoint","setChannelReady","setLoop","Looper","Channels","constructor","channelBuilder","synchronizer","looper","dispatch","channels","A","B","stdDivceDiff","getChannelNames","Object","keys","createChannel","channelName","args","create","createBars","values","getFullChannel","getChannel","master","getChannelInterface","channel","getSyncBarPosition","getSyncBarPostion","call","getCurrentTime","time","left","getDuration","loadTrack","track","source","sourceId","api","url","getUrl","loadWithEvent","load","togglePlay","currentValue","pause","play","toggleCue","player","isPaused","getState","console","playBackState","paused","cuePoint","backend","seekTo","drawer","progress","recenter","isPlaying","adjustPitch","waveSurfer","setPlaybackRate","fireEvent","sync","makeLoop","loopLength","endLoop","updateLoop"],"mappings":"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","sourcesContent":["import store from \"./../../../../../store/\";\r\nimport ChannelBuilder from \"./channelBuilder/channelBuilder\";\r\nimport Synchronizer from \"./sync/synchronizer\";\r\nimport {getApi} from \"./../../../../../apis/apiProvider\";\r\nimport {setCuePoint, \r\n        setChannelReady, \r\n        setLoop,\r\n      } from \"./../../../../../actions\";\r\nimport Looper from \"./looper/looper\";\r\n\r\n\r\nexport default class Channels {\r\n  constructor() {\r\n    this.channelBuilder = new ChannelBuilder();\r\n    this.synchronizer = new Synchronizer(this);\r\n    this.looper = new Looper();\r\n    this.dispatch = store.dispatch;\r\n    this.channels = {\r\n      A: null,\r\n      B: null\r\n    };\r\n\r\n    this.stdDivceDiff = {};\r\n  }\r\n\r\n  getChannelNames() {\r\n    return Object.keys(this.channels);\r\n  }\r\n\r\n  createChannel( channelName, ...args ){\r\n      this.channels[channelName] = this.channelBuilder.create( channelName, ...args);\r\n  }\r\n\r\n  createBars( channelName, values ){\r\n    this.channelBuilder.createBars( this.getFullChannel(channelName), values);\r\n  }\r\n\r\n  getChannel(channelName) {\r\n    return this.channels[channelName].master;\r\n  }\r\n\r\n  getFullChannel(channelName){\r\n    return this.channels[channelName];\r\n  }\r\n\r\n  getChannelInterface(channelName) {\r\n    const channel = this.getChannel(channelName);\r\n    return {\r\n      getSyncBarPosition: () => \r\n        this.synchronizer.getSyncBarPostion.call(this.synchronizer,channelName), \r\n      getCurrentTime: () => ({\r\n        time: channel.getCurrentTime(),\r\n        left: channel.getDuration() - channel.getCurrentTime(),\r\n      })\r\n    };\r\n  }\r\n\r\n  //--------------------------------------------\r\n\r\n  loadTrack(channelName, track) {\r\n    if(!track || !track.source || !track.sourceId) return;\r\n\r\n    let api = getApi(track.source);\r\n    let url = (api && api.getUrl(track.sourceId)) || null;\r\n\r\n    this.dispatch(setChannelReady(false, channelName));\r\n\r\n    let channel = this.getChannel(channelName);\r\n\r\n    if (channel.loadWithEvent) {\r\n      channel.loadWithEvent(url);\r\n    } else {\r\n      channel.load(url);\r\n    }\r\n  }\r\n\r\n  togglePlay(channelName, currentValue) {\r\n    if (currentValue) {\r\n      this.getChannel(channelName).pause();\r\n      this.dispatch(setLoop(channelName, false))\r\n    } else {\r\n      this.getChannel(channelName).play();\r\n    }\r\n  }\r\n\r\n  toggleCue(channelName, currentValue) {\r\n    const player = this.getChannel(channelName);\r\n    const isPaused = store.getState().console.channel[channelName]\r\n                    .playBackState.paused;\r\n    if (!currentValue && isPaused) {\r\n      // back to cue point and pause\r\n      let cuePoint = store.getState().console.channel[channelName]\r\n                    .playBackState.cuePoint; //in seconds\r\n      //seek to\r\n      player.pause();\r\n      player.backend.seekTo(cuePoint);\r\n      player.drawer.progress(cuePoint / player.getDuration());\r\n      player.drawer.recenter(cuePoint / player.getDuration());\r\n    } else if (!currentValue) {\r\n      //Cancel cue and play\r\n      if (!player.isPlaying()) {\r\n        player.play();\r\n      }\r\n    } else {\r\n      const cuePoint = this.getChannel(channelName).getCurrentTime();\r\n      this.getChannel(channelName).play();\r\n      this.dispatch(setCuePoint(channelName, cuePoint)); // in float seconds\r\n    }\r\n  }\r\n\r\n  adjustPitch(channelName, currentValue) {\r\n    let waveSurfer= this.getChannel(channelName); \r\n    waveSurfer.setPlaybackRate(1 + currentValue / 100);\r\n    waveSurfer.fireEvent(\"interaction\");\r\n\r\n    /*\r\n    if(channel?.backend?.source instanceof AudioBufferSourceNode){\r\n        const rate = 1 + currentValue / 100\r\n        channel.backend.source.playbackRate.value = rate; \r\n        channel.backend.playbackRate = rate;\r\n    }*/\r\n  }\r\n\r\n  sync(channelName){\r\n    this.synchronizer.sync(channelName);\r\n  }\r\n\r\n  makeLoop(channelName, {loopLength}){\r\n    try{\r\n      this.looper.makeLoop(this.getFullChannel(channelName), loopLength)\r\n    }\r\n    catch{\r\n      this.dispatch(setLoop(channelName, false))\r\n    }\r\n  }\r\n\r\n  endLoop(channelName){\r\n    this.looper.endLoop(this.getFullChannel(channelName));\r\n  }\r\n\r\n  updateLoop(channelName, {loopLength}){\r\n    this.looper.updateLoop(this.getFullChannel(channelName), loopLength);\r\n  }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}