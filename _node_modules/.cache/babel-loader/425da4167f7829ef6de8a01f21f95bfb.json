{"ast":null,"code":"import store from \"./../../../store/\";\nimport getApi from \"./../../../apis/apiProvider\";\nimport { getBeatLength, calcBpm } from \"./../../../utils/bpm/converter\";\nimport { setCuePoint, setChannelReady, setTimeLeft, setPitch, setSync } from \"./../../../actions\";\nexport default class Channels {\n  constructor() {\n    this.synchronizer = new Synchronizer(this);\n    this.dispatch = store.dispatch;\n    this.channels = {\n      A: null,\n      B: null\n    };\n    this.stdDivceDiff = {};\n  }\n\n  getChannelNames() {\n    return Object.keys(this.channels);\n  }\n\n  setChannel(channelName, player) {\n    this.channels[channelName] = player;\n  }\n\n  getChannel(channelName) {\n    return this.channels[channelName];\n  }\n\n  getChannelInterface(channelName) {\n    return {\n      getSyncBarPosition: () => this.getSyncBarPostion.call(this, channelName)\n    };\n  } //--------------------------------------------\n\n\n  loadTrack(channelName, track) {\n    let api = getApi(track.source);\n    let url = api && api.getUrl(track.id) || null;\n    this.dispatch(setChannelReady(false, channelName));\n    let player = this.channels[channelName];\n\n    if (player.loadWithEvent) {\n      player.loadWithEvent(url);\n    } else {\n      player.load(url);\n    }\n  }\n\n  updatePosition(channelName) {\n    this.updateTimeLeft(channelName);\n  }\n\n  updateTimeLeft(channelName) {\n    let channel = this.channels[channelName];\n    this.dispatch(setTimeLeft(channelName, parseInt(channel.getDuration() - channel.getCurrentTime())));\n  }\n\n  togglePlay(channelName, currentValue) {\n    if (currentValue) {\n      this.channels[channelName].pause();\n    } else {\n      this.channels[channelName].play();\n    }\n  }\n\n  toggleCue(channelName, currentValue) {\n    const player = this.channels[channelName];\n    const isPaused = store.getState().console.channel[channelName].playBackState.paused;\n\n    if (!currentValue && isPaused) {\n      // back to cue point and pause\n      let cuePoint = store.getState().console.channel[channelName].playBackState.cuePoint; //in seconds\n      //seek to\n\n      player.pause();\n      player.backend.seekTo(cuePoint);\n      player.drawer.progress(cuePoint / player.getDuration());\n      player.drawer.recenter(cuePoint / player.getDuration());\n    } else if (!currentValue) {\n      //Cancel cue and play\n      if (!player.isPlaying()) {\n        player.play();\n      }\n    } else {\n      const cuePoint = this.channels[channelName].getCurrentTime();\n      this.channels[channelName].play();\n      this.dispatch(setCuePoint(channelName, cuePoint)); // in float seconds\n    }\n  }\n\n  adjustPitch(channelName, currentValue) {\n    this.channels[channelName].setPlaybackRate(1 + currentValue / 100);\n  } //---------------------\n\n\n  getSyncBarPostion(channelName) {\n    const data = this.getSyncData(channelName);\n\n    if (data != null) {\n      const {\n        diff,\n        masterBeatLength\n      } = data;\n      return diff / masterBeatLength;\n    }\n\n    return null;\n  }\n\n  sync(channelName) {\n    console.log(\"sync channel\", channelName);\n    const state = store.getState();\n\n    if (channelName === state.console.master) {\n      //you can't sync master to master\n      this.dispatch(setSync(channelName, false));\n      return;\n    }\n\n    const slaveChannel = this.channels[channelName];\n    const syncData = this.getSyncData(channelName);\n\n    if (!syncData) {\n      this.dispatch(setSync(channelName, false));\n      return;\n    }\n\n    const masterBpm = state.console.channel[state.console.master].track.bpm;\n    const currentMasterPitch = state.console.channel[state.console.master].playBackState.pitch;\n    const slaveBpm = state.console.channel[channelName].track.bpm;\n    const newSlavePitch = (calcBpm(masterBpm, currentMasterPitch) / slaveBpm - 1) * 100;\n    this.dispatch(setPitch(newSlavePitch, channelName));\n    slaveChannel.backend.seekTo(slaveChannel.getCurrentTime() + syncData.diff);\n    slaveChannel.drawer.progress(slaveChannel.backend.getPlayedPercents());\n    slaveChannel.play();\n    this.dispatch(setSync(channelName, false));\n  }\n\n  getSyncData(channelName) {\n    let state = store.getState();\n    if (!state.console.master) return null;\n    const masterChannel = this.channels[state.console.master];\n    const slaveChannel = this.channels[channelName];\n    if (!masterChannel.isPlaying() || !slaveChannel.isPlaying()) return null; // --- stabilization - beacuase :\n    // masterChannel.getCurrentTime() - slaveChannel.getCurrentTime() is not stable as should be\n    // cause of this is calculated average diff and diviation from this diff.\n\n    if (!this.stdDivceDiff[channelName]) {\n      //craete\n      this.stdDivceDiff = { ...this.stdDivceDiff,\n        [channelName]: null\n      }; //set\n\n      this.stdDivceDiff[channelName] = masterChannel.backend.ac.currentTime - slaveChannel.backend.ac.currentTime;\n    }\n\n    const currentDdff = masterChannel.backend.ac.currentTime - slaveChannel.backend.ac.currentTime;\n    this.stdDivceDiff[channelName] = (this.stdDivceDiff[channelName] + currentDdff) / 2;\n    const deviation = this.stdDivceDiff[channelName] - currentDdff; //----------------------\n\n    let masterPosition = masterChannel.getCurrentTime();\n    let slavePosition = slaveChannel.getCurrentTime() + deviation; // console.log(deviation)\n\n    const masterBpm = state.console.channel[state.console.master].track.bpm;\n    const masterBeatLength = getBeatLength(masterBpm);\n    const masterOffset = state.console.channel[state.console.master].playBackState.offset;\n    const slaveBpm = state.console.channel[channelName].track.bpm;\n    const slaveBeatLength = getBeatLength(slaveBpm);\n    const slaveOffset = state.console.channel[channelName].playBackState.offset;\n    const masterBeatPosition = (masterPosition - masterOffset) % masterBeatLength;\n    const slaveBeatPosition = (slavePosition - slaveOffset) % slaveBeatLength;\n    const beatDiff = masterBeatPosition - slaveBeatPosition; //when master track is in the current beat but slave is in the next one \n    //and in invers situation \n\n    const beatDiffEdgeNegative = masterBeatLength - masterBeatPosition + slaveBeatPosition; // slave is overtaking\n\n    const beatDiffEdgePositive = slaveBeatLength + masterBeatPosition - slaveBeatPosition; // slave is delayed\n\n    const min = Math.min(Math.abs(beatDiff), Math.abs(beatDiffEdgeNegative), Math.abs(beatDiffEdgePositive));\n    let diff;\n\n    switch (min) {\n      case Math.abs(beatDiff):\n        {\n          diff = beatDiff;\n          break;\n        }\n\n      case Math.abs(beatDiffEdgeNegative):\n        {\n          diff = -Math.abs(beatDiffEdgeNegative);\n          break;\n        }\n\n      case Math.abs(beatDiffEdgePositive):\n        {\n          diff = Math.abs(beatDiffEdgePositive);\n          break;\n        }\n\n      default:\n        diff = min;\n    }\n\n    return {\n      diff,\n      masterBeatLength\n    };\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/src/core/console/channels/channels.js"],"names":["store","getApi","getBeatLength","calcBpm","setCuePoint","setChannelReady","setTimeLeft","setPitch","setSync","Channels","constructor","synchronizer","Synchronizer","dispatch","channels","A","B","stdDivceDiff","getChannelNames","Object","keys","setChannel","channelName","player","getChannel","getChannelInterface","getSyncBarPosition","getSyncBarPostion","call","loadTrack","track","api","source","url","getUrl","id","loadWithEvent","load","updatePosition","updateTimeLeft","channel","parseInt","getDuration","getCurrentTime","togglePlay","currentValue","pause","play","toggleCue","isPaused","getState","console","playBackState","paused","cuePoint","backend","seekTo","drawer","progress","recenter","isPlaying","adjustPitch","setPlaybackRate","data","getSyncData","diff","masterBeatLength","sync","log","state","master","slaveChannel","syncData","masterBpm","bpm","currentMasterPitch","pitch","slaveBpm","newSlavePitch","getPlayedPercents","masterChannel","ac","currentTime","currentDdff","deviation","masterPosition","slavePosition","masterOffset","offset","slaveBeatLength","slaveOffset","masterBeatPosition","slaveBeatPosition","beatDiff","beatDiffEdgeNegative","beatDiffEdgePositive","min","Math","abs"],"mappings":"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","sourcesContent":["import store from \"./../../../store/\";\r\nimport getApi from \"./../../../apis/apiProvider\";\r\nimport { getBeatLength, calcBpm } from \"./../../../utils/bpm/converter\";\r\nimport { setCuePoint, \r\n        setChannelReady, \r\n        setTimeLeft, \r\n        setPitch , \r\n        setSync } from \"./../../../actions\";\r\n\r\nexport default class Channels {\r\n  constructor() {\r\n    this.synchronizer = new Synchronizer(this);\r\n    this.dispatch = store.dispatch;\r\n    this.channels = {\r\n      A: null,\r\n      B: null\r\n    };\r\n\r\n    this.stdDivceDiff = {};\r\n  }\r\n\r\n  getChannelNames() {\r\n    return Object.keys(this.channels);\r\n  }\r\n\r\n  setChannel(channelName, player) {\r\n    this.channels[channelName] = player;\r\n  }\r\n\r\n  getChannel(channelName) {\r\n    return this.channels[channelName];\r\n  }\r\n\r\n  getChannelInterface(channelName) {\r\n    return {\r\n      getSyncBarPosition: () => this.getSyncBarPostion.call(this,channelName)\r\n    };\r\n  }\r\n\r\n  //--------------------------------------------\r\n\r\n  loadTrack(channelName, track) {\r\n    let api = getApi(track.source);\r\n    let url = (api && api.getUrl(track.id)) || null;\r\n\r\n    this.dispatch(setChannelReady(false, channelName));\r\n\r\n    let player = this.channels[channelName];\r\n\r\n    if (player.loadWithEvent) {\r\n      player.loadWithEvent(url);\r\n    } else {\r\n      player.load(url);\r\n    }\r\n  }\r\n\r\n  updatePosition(channelName) {\r\n    this.updateTimeLeft(channelName);\r\n  }\r\n\r\n  updateTimeLeft(channelName) {\r\n    let channel = this.channels[channelName];\r\n    this.dispatch(\r\n      setTimeLeft(\r\n        channelName,\r\n        parseInt(channel.getDuration() - channel.getCurrentTime())\r\n      )\r\n    );\r\n  }\r\n\r\n  togglePlay(channelName, currentValue) {\r\n    if (currentValue) {\r\n      this.channels[channelName].pause();\r\n    } else {\r\n      this.channels[channelName].play();\r\n    }\r\n  }\r\n\r\n  toggleCue(channelName, currentValue) {\r\n    const player = this.channels[channelName];\r\n    const isPaused = store.getState().console.channel[channelName]\r\n                    .playBackState.paused;\r\n    if (!currentValue && isPaused) {\r\n      // back to cue point and pause\r\n      let cuePoint = store.getState().console.channel[channelName]\r\n                    .playBackState.cuePoint; //in seconds\r\n      //seek to\r\n      player.pause();\r\n      player.backend.seekTo(cuePoint);\r\n      player.drawer.progress(cuePoint / player.getDuration());\r\n      player.drawer.recenter(cuePoint / player.getDuration());\r\n    } else if (!currentValue) {\r\n      //Cancel cue and play\r\n      if (!player.isPlaying()) {\r\n        player.play();\r\n      }\r\n    } else {\r\n      const cuePoint = this.channels[channelName].getCurrentTime();\r\n      this.channels[channelName].play();\r\n      this.dispatch(setCuePoint(channelName, cuePoint)); // in float seconds\r\n    }\r\n  }\r\n\r\n  adjustPitch(channelName, currentValue) {\r\n    this.channels[channelName].setPlaybackRate(1 + currentValue / 100);\r\n  }\r\n\r\n  //---------------------\r\n  getSyncBarPostion(channelName) {\r\n    const data = this.getSyncData(channelName);\r\n    if(data != null){\r\n      const {diff, masterBeatLength} = data;\r\n      return diff/masterBeatLength;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  sync(channelName){\r\n    console.log(\"sync channel\", channelName);\r\n    const state = store.getState();\r\n    if(channelName === state.console.master) { //you can't sync master to master\r\n      this.dispatch(setSync(channelName, false));\r\n      return;\r\n    }\r\n    \r\n    const slaveChannel = this.channels[channelName];\r\n\r\n    \r\n\r\n    const syncData = this.getSyncData(channelName);\r\n    if(!syncData){\r\n      this.dispatch(setSync(channelName, false));\r\n      return;\r\n    }\r\n    const masterBpm = state.console.channel[state.console.master].track.bpm;\r\n    const currentMasterPitch = state.console.channel[state.console.master].playBackState.pitch;\r\n    const slaveBpm = state.console.channel[channelName].track.bpm;\r\n    const newSlavePitch = ((calcBpm(masterBpm, currentMasterPitch) / slaveBpm) - 1) * 100;\r\n    this.dispatch(setPitch(newSlavePitch, channelName));\r\n\r\n    slaveChannel.backend.seekTo(slaveChannel.getCurrentTime() + syncData.diff);\r\n    slaveChannel.drawer.progress(slaveChannel.backend.getPlayedPercents());\r\n    slaveChannel.play();\r\n\r\n    this.dispatch(setSync(channelName, false));\r\n  }\r\n\r\n  getSyncData(channelName) {\r\n    let state = store.getState();\r\n    if (!state.console.master) return null;\r\n\r\n    const masterChannel = this.channels[state.console.master];\r\n    const slaveChannel = this.channels[channelName];\r\n    if (!masterChannel.isPlaying() || !slaveChannel.isPlaying()) return null;\r\n\r\n    // --- stabilization - beacuase :\r\n    // masterChannel.getCurrentTime() - slaveChannel.getCurrentTime() is not stable as should be\r\n    // cause of this is calculated average diff and diviation from this diff.\r\n    if(!this.stdDivceDiff[channelName]){\r\n        //craete\r\n        this.stdDivceDiff = {...this.stdDivceDiff, [channelName] : null}\r\n        //set\r\n        this.stdDivceDiff[channelName] = masterChannel.backend.ac.currentTime \r\n                                       - slaveChannel.backend.ac.currentTime;\r\n    }\r\n\r\n    const currentDdff = masterChannel.backend.ac.currentTime \r\n                      - slaveChannel.backend.ac.currentTime;\r\n\r\n    this.stdDivceDiff[channelName] = ( this.stdDivceDiff[channelName] + currentDdff )  / 2; \r\n\r\n    const deviation = this.stdDivceDiff[channelName] - currentDdff;\r\n    //----------------------\r\n\r\n    let masterPosition = masterChannel.getCurrentTime();\r\n    let slavePosition = slaveChannel.getCurrentTime() + deviation;\r\n   // console.log(deviation)\r\n\r\n    const masterBpm = state.console.channel[state.console.master].track.bpm;\r\n    const masterBeatLength = getBeatLength(masterBpm);\r\n    const masterOffset = state.console.channel[state.console.master].playBackState.offset;\r\n\r\n    const slaveBpm = state.console.channel[channelName].track.bpm;\r\n    const slaveBeatLength = getBeatLength(slaveBpm);\r\n    const slaveOffset = state.console.channel[channelName].playBackState.offset;\r\n\r\n    const masterBeatPosition = (masterPosition - masterOffset) % masterBeatLength ;\r\n    const slaveBeatPosition = (slavePosition - slaveOffset) % slaveBeatLength ;\r\n\r\n    const beatDiff = masterBeatPosition - slaveBeatPosition;\r\n    \r\n    //when master track is in the current beat but slave is in the next one \r\n    //and in invers situation \r\n    const beatDiffEdgeNegative = masterBeatLength \r\n                               - masterBeatPosition \r\n                               + slaveBeatPosition; // slave is overtaking\r\n    const beatDiffEdgePositive = slaveBeatLength \r\n                               + masterBeatPosition \r\n                               - slaveBeatPosition ; // slave is delayed\r\n\r\n    const min = Math.min(Math.abs(beatDiff), \r\n                         Math.abs(beatDiffEdgeNegative), \r\n                         Math.abs(beatDiffEdgePositive))\r\n\r\n    let diff;\r\n    switch(min){\r\n        case Math.abs(beatDiff): {\r\n            diff =  beatDiff;\r\n            break;\r\n        }\r\n        case Math.abs(beatDiffEdgeNegative): {\r\n            diff = - Math.abs(beatDiffEdgeNegative);\r\n            break;\r\n        }\r\n        case Math.abs(beatDiffEdgePositive): {\r\n            diff = Math.abs(beatDiffEdgePositive);\r\n            break;\r\n        }\r\n        default : diff = min;\r\n    }\r\n\r\n    return {\r\n      diff,\r\n      masterBeatLength,\r\n    }\r\n  }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}