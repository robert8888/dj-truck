{"ast":null,"code":"import store from \"./../../../../../store\";\nimport { setAvailableEffects } from \"./../../../../../actions\";\nimport { equalPowerFader } from \"./../../../../../utils/sound/converter\"; //import { throttel } from \"./../../../../../utils/functions/lodash\";\n\nimport Reverb from \"./effects/reverb/reverb\";\nimport Delay from \"./effects/delay/delay\";\nexport default class Effector {\n  constructor(audioContext) {\n    this.config = store.getState().configuration.effector;\n    this.mainAC = audioContext;\n    this.buildChannels(this.config.channels);\n    this.effects = {\n      \"reverb\": {\n        create: Reverb,\n        params: Reverb.defaultParams().params\n      },\n      \"delay\": {\n        create: Delay,\n        params: Delay.defaultParams().params\n      }\n    };\n    const exportEffects = {};\n    Object.entries(this.effects).forEach(([key, element]) => exportEffects[key] = element.params);\n    store.dispatch(setAvailableEffects(exportEffects));\n  }\n\n  buildChannels(channelNumber) {\n    this.channels = Array.from({\n      length: channelNumber\n    }, index => ({\n      channelNumber: index\n    }));\n\n    for (let chNum = 0; chNum < channelNumber; chNum++) {\n      const channel = this.channels[chNum];\n      channel.inputNode = this.mainAC.createGain();\n      channel.dryNode = this.mainAC.createGain();\n      ;\n      channel.wetNode = this.mainAC.createGain();\n      channel.outputNode = this.mainAC.createGain();\n      channel.inputNode.connect(channel.dryNode);\n      channel.inputNode.connect(channel.wetNode);\n      channel.dryNode.connect(channel.outputNode);\n      channel.wetNode.connect(channel.outputNode);\n      channel.wetNode.gain.setValueAtTime(0, 0);\n    }\n  }\n\n  connect(inputs) {\n    const outputs = [];\n    inputs.forEach((inputNode, chNum) => {\n      inputNode.connect(this.channels[chNum].inputNode);\n      const output = this.mainAC.createGain();\n      this.channels[chNum].outputNode.connect(output);\n      outputs.push(output);\n    });\n    return outputs;\n  }\n\n  setDryWet(channelNumber, value) {\n    channelNumber--;\n    const channel = this.channels[channelNumber];\n    const {\n      a: dry,\n      b: wet\n    } = equalPowerFader(value);\n    channel.dryNode.gain.setTargetAtTime(dry, this.mainAC.currentTime, 0.01);\n    channel.wetNode.gain.setTargetAtTime(wet, this.mainAC.currentTime, 0.01);\n  }\n\n  setEffect(channelNumber, effectName) {\n    channelNumber--; //array index\n\n    const channel = this.channels[channelNumber];\n\n    if (effectName) {\n      this.disconectCurrent(channel);\n      let params = this.assingDefaultParams({}, effectName);\n      const effectorChannel = store.getState().effector.channels;\n\n      if (effectorChannel && effectorChannel[channelNumber]) {\n        params = { ...effectorChannel[channelNumber].effects[effectName]\n        };\n      }\n\n      const effect = new this.effects[effectName].create(this.mainAC, params);\n      channel.currentEffect = effect;\n      channel.inputNode.connect(channel.dryNode);\n      effect.connect(channel.inputNode, channel.wetNode);\n    } else {\n      this.disconectCurrent(channel);\n    }\n  }\n\n  assingDefaultParams(obj, effect) {\n    Object.entries(this.effects[effect].params).forEach(([key, value]) => {\n      obj[key] = value.defaultValue;\n    });\n    return obj;\n  }\n\n  setParam(channelNumber, effect, param) {\n    channelNumber--;\n    const channel = this.channels[channelNumber];\n\n    if (channel.currentEffect && channel.currentEffect.name === effect) {\n      Object.entries(param).forEach(([key, value]) => {\n        channel.currentEffect[key] = value;\n      });\n    }\n  }\n\n  disconectCurrent(channel) {\n    if (channel.currentEffect) {\n      console.log(channel);\n      channel.inputNode.disconect();\n      channel.inputNode.connect(channel.dryNode);\n      channel.inputNode.connect(channel.wetNode);\n      channel.currentEffect.disconect();\n      channel.currentEffect = null;\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/src/pages/app/core/console/effector/effector.js"],"names":["store","setAvailableEffects","equalPowerFader","Reverb","Delay","Effector","constructor","audioContext","config","getState","configuration","effector","mainAC","buildChannels","channels","effects","create","params","defaultParams","exportEffects","Object","entries","forEach","key","element","dispatch","channelNumber","Array","from","length","index","chNum","channel","inputNode","createGain","dryNode","wetNode","outputNode","connect","gain","setValueAtTime","inputs","outputs","output","push","setDryWet","value","a","dry","b","wet","setTargetAtTime","currentTime","setEffect","effectName","disconectCurrent","assingDefaultParams","effectorChannel","effect","currentEffect","obj","defaultValue","setParam","param","name","console","log","disconect"],"mappings":"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","sourcesContent":["\r\nimport store from \"./../../../../../store\";\r\nimport { setAvailableEffects } from \"./../../../../../actions\";\r\nimport { equalPowerFader } from \"./../../../../../utils/sound/converter\"\r\n//import { throttel } from \"./../../../../../utils/functions/lodash\";\r\nimport Reverb from \"./effects/reverb/reverb\";\r\nimport Delay from \"./effects/delay/delay\";\r\n\r\n\r\n\r\nexport default class Effector {\r\n    constructor(audioContext) {\r\n        this.config = store.getState().configuration.effector;\r\n        this.mainAC = audioContext;\r\n\r\n        this.buildChannels(this.config.channels);\r\n\r\n\r\n        this.effects = {\r\n            \"reverb\": {\r\n                create: Reverb,\r\n                params: Reverb.defaultParams().params,\r\n            },\r\n            \"delay\": {\r\n                create: Delay,\r\n                params: Delay.defaultParams().params\r\n            }\r\n        }\r\n\r\n        const exportEffects = {};\r\n        Object.entries(this.effects).forEach(([key, element]) =>\r\n            exportEffects[key] = element.params\r\n        );\r\n        store.dispatch(setAvailableEffects(exportEffects));\r\n    }\r\n\r\n    buildChannels(channelNumber) {\r\n        this.channels =\r\n            Array.from({ length: channelNumber }, (index) => ({ channelNumber: index }));\r\n\r\n        for (let chNum = 0; chNum < channelNumber; chNum++) {\r\n            const channel = this.channels[chNum];\r\n\r\n            channel.inputNode = this.mainAC.createGain();\r\n            channel.dryNode = this.mainAC.createGain();;\r\n            channel.wetNode = this.mainAC.createGain();\r\n            channel.outputNode = this.mainAC.createGain();\r\n\r\n            channel.inputNode.connect(channel.dryNode);\r\n            channel.inputNode.connect(channel.wetNode);\r\n            channel.dryNode.connect(channel.outputNode);\r\n            channel.wetNode.connect(channel.outputNode);\r\n\r\n            channel.wetNode.gain.setValueAtTime(0,0)\r\n        }\r\n    }\r\n\r\n    connect(inputs) {   \r\n        const outputs = [];\r\n        \r\n        inputs.forEach((inputNode, chNum) => {\r\n            inputNode.connect(this.channels[chNum].inputNode);\r\n            \r\n            const output = this.mainAC.createGain();\r\n            this.channels[chNum].outputNode.connect(output);\r\n            outputs.push(output)\r\n        });\r\n    \r\n        return outputs;\r\n    }\r\n\r\n\r\n    setDryWet(channelNumber, value) {\r\n        channelNumber--;\r\n        const channel = this.channels[channelNumber];\r\n\r\n        const {a: dry, b: wet} = equalPowerFader(value);\r\n\r\n        channel.dryNode.gain.setTargetAtTime(dry, this.mainAC.currentTime, 0.01);\r\n        channel.wetNode.gain.setTargetAtTime(wet, this.mainAC.currentTime, 0.01);\r\n    }\r\n\r\n    setEffect(channelNumber, effectName) {\r\n        channelNumber--;//array index\r\n        const channel = this.channels[channelNumber];\r\n\r\n        if (effectName) {\r\n            this.disconectCurrent(channel);\r\n\r\n            let params = this.assingDefaultParams({}, effectName);\r\n\r\n            const effectorChannel = store.getState().effector.channels;\r\n\r\n            if (effectorChannel && effectorChannel[channelNumber]) {\r\n                params = { ...effectorChannel[channelNumber].effects[effectName] }\r\n            }\r\n\r\n            const effect = new this.effects[effectName].create(this.mainAC, params);\r\n\r\n            channel.currentEffect = effect;\r\n            channel.inputNode.connect(channel.dryNode)\r\n\r\n            effect.connect(channel.inputNode, channel.wetNode)\r\n\r\n        } else {\r\n            this.disconectCurrent(channel);\r\n        }\r\n\r\n    }\r\n\r\n    assingDefaultParams(obj, effect) {\r\n        Object.entries(this.effects[effect].params).forEach(([key, value]) => {\r\n            obj[key] = value.defaultValue;\r\n        })\r\n        return obj;\r\n    }\r\n\r\n    setParam(channelNumber, effect, param) {\r\n        channelNumber--;\r\n        const channel = this.channels[channelNumber];\r\n        if (channel.currentEffect && channel.currentEffect.name === effect) {\r\n            Object.entries(param).forEach(([key, value]) => {\r\n                channel.currentEffect[key] = value;\r\n            })\r\n        }\r\n    }\r\n\r\n\r\n    disconectCurrent(channel) {\r\n        if (channel.currentEffect) {\r\n            console.log(channel)\r\n            channel.inputNode.disconect();\r\n            channel.inputNode.connect(channel.dryNode);\r\n            channel.inputNode.connect(channel.wetNode);\r\n            channel.currentEffect.disconect();\r\n            channel.currentEffect = null;\r\n        }\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}