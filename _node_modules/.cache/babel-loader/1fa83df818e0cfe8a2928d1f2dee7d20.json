{"ast":null,"code":"import store from \"./../../../../../store\";\nimport { recording, recordingRquestFail, recordFinalUpdate, rollbackRecrod } from \"./../../../../../actions\";\nimport STATUS from \"./../observer/STATUS\";\nimport io from \"socket.io-client\";\nimport { getApi } from \"./../../../../../apis/apiProvider\";\nexport default class Recorder {\n  constructor(mixer) {\n    this.mixer = mixer;\n    const streamDestination = this.mixer.audioNodes.channels['main'].recorderStremDestination;\n    this.mediaRecorder = new MediaRecorder(streamDestination.stream, {\n      mimeType: 'audio/webm;codecs=opus'\n    });\n    const api = getApi(\"RecordsStore\");\n    this.wsUrl = api.getSocketUrl();\n    this.currentRec = Recorder.initRecState();\n  }\n\n  action(status, param) {\n    switch (status) {\n      case STATUS.RECORD_START:\n        {\n          this.startRecording(param);\n          break;\n        }\n\n      case STATUS.RECORD_END:\n        {\n          this.endRecording();\n          break;\n        }\n    }\n  }\n\n  startRecording({\n    recId,\n    recName\n  }) {\n    //console.log(\"im start recording\", recId, recName);\n    const token = store.getState().user.token;\n\n    if (!token) {\n      return;\n    }\n\n    const socket = io.connect(this.wsUrl);\n    socket.on(\"connect\", () => {\n      //console.log(\"we have connection\")\n      socket.emit('authentication', {\n        token: token\n      });\n      socket.on('authenticated', () => {\n        // console.log('auth')\n        socket.emit(\"record_details\", {\n          recId,\n          recName\n        });\n      });\n      socket.on('recorder_ready', () => {\n        this.currentRec.id = recId;\n        this.currentRec.title = recName;\n\n        this.mediaRecorder.ondataavailable = e => {\n          // console.log(e.data)\n          socket.emit('record_chunk', e.data);\n        };\n\n        this.mediaRecorder.addEventListener('stop', () => {\n          // socket.close()\n          socket.emit('record_stop');\n        });\n        this.mediaRecorder.start(1000);\n        this.currentRec.duration = new Date().getTime();\n        this.updateInterval = setInterval(this._updatePeaks.bind(this), 100);\n        store.dispatch(recording());\n      });\n      socket.on('connect_error', () => {\n        store.dispatch(recordingRquestFail());\n      });\n      socket.on('recording_finished', ({\n        fileSize\n      }) => {\n        console.log(\"recording finishe event from socekt\");\n        const {\n          id,\n          duration,\n          peaks\n        } = this.currentRec;\n        store.dispatch(recordFinalUpdate(id, peaks, duration, fileSize));\n        this.currentRec = Recorder.initRecState();\n        socket.close();\n      });\n      socket.on(\"recording_error\", () => {\n        store.dispatch(roolbackRecord(this.currentRec.id));\n      });\n    });\n  }\n\n  endRecording() {\n    //  console.log(\"im finish recoriding\")\n    if (this.mediaRecorder.state !== 'inactive') {\n      this.mediaRecorder.stop();\n      clearInterval(this.updateInterval);\n      this.currentRec.duration = new Date().getTime() - this.currentRec.duration;\n    }\n  }\n\n  _updatePeaks() {\n    const len = this.currentRec.peaks.length;\n    this.currentRec.peaks[len] = this.mixer.currentPeakMinMax[0];\n    this.currentRec.peaks[len + 1] = this.mixer.currentPeakMinMax[1];\n  }\n\n}\n\nRecorder.initRecState = () => ({\n  id: null,\n  title: \"\",\n  peaks: [],\n  duration: 0\n});","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/console/core/console/mixer/recorder.js"],"names":["store","recording","recordingRquestFail","recordFinalUpdate","rollbackRecrod","STATUS","io","getApi","Recorder","constructor","mixer","streamDestination","audioNodes","channels","recorderStremDestination","mediaRecorder","MediaRecorder","stream","mimeType","api","wsUrl","getSocketUrl","currentRec","initRecState","action","status","param","RECORD_START","startRecording","RECORD_END","endRecording","recId","recName","token","getState","user","socket","connect","on","emit","id","title","ondataavailable","e","data","addEventListener","start","duration","Date","getTime","updateInterval","setInterval","_updatePeaks","bind","dispatch","fileSize","console","log","peaks","close","roolbackRecord","state","stop","clearInterval","len","length","currentPeakMinMax"],"mappings":"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","sourcesContent":["import store from \"./../../../../../store\";\r\nimport { recording, recordingRquestFail, recordFinalUpdate, rollbackRecrod } from \"./../../../../../actions\"\r\nimport STATUS from \"./../observer/STATUS\";\r\nimport io from \"socket.io-client\";\r\nimport {getApi} from \"./../../../../../apis/apiProvider\";\r\n\r\n\r\n\r\nexport default class Recorder {\r\n    static initRecState = () => ({\r\n            id : null,\r\n            title :\"\",\r\n            peaks : [],\r\n            duration : 0,\r\n    })\r\n\r\n    constructor(mixer) {\r\n        this.mixer = mixer;\r\n\r\n        const streamDestination = this.mixer.audioNodes.channels['main'].recorderStremDestination;\r\n        this.mediaRecorder = new MediaRecorder(streamDestination.stream, {\r\n            mimeType: 'audio/webm;codecs=opus',\r\n        });\r\n\r\n        const api = getApi(\"RecordsStore\");\r\n        this.wsUrl = api.getSocketUrl();\r\n\r\n        this.currentRec = Recorder.initRecState();\r\n    }\r\n\r\n\r\n    action(status, param) {\r\n        switch (status) {\r\n            case STATUS.RECORD_START: {\r\n                this.startRecording(param);\r\n                break;\r\n            }\r\n            case STATUS.RECORD_END: {\r\n                this.endRecording()\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    startRecording({recId, recName}) {\r\n        //console.log(\"im start recording\", recId, recName);\r\n        const token = store.getState().user.token;\r\n        if (!token) {\r\n            return;\r\n        }\r\n\r\n        const socket = io.connect(this.wsUrl);\r\n\r\n        socket.on(\"connect\", () => {\r\n            //console.log(\"we have connection\")\r\n            socket.emit('authentication', { token: token });\r\n            socket.on('authenticated', () => {\r\n               // console.log('auth')\r\n                socket.emit(\"record_details\", { recId, recName })\r\n            })\r\n            socket.on('recorder_ready', () => {\r\n                this.currentRec.id = recId;\r\n                this.currentRec.title = recName;\r\n\r\n                this.mediaRecorder.ondataavailable = (e) => {\r\n                   // console.log(e.data)\r\n                    socket.emit('record_chunk', e.data)\r\n                }\r\n\r\n                this.mediaRecorder.addEventListener('stop', () => {\r\n                   // socket.close()\r\n                   socket.emit('record_stop')\r\n                })\r\n\r\n                this.mediaRecorder.start(1000);\r\n      \r\n                this.currentRec.duration = new Date().getTime();\r\n\r\n                this.updateInterval = setInterval(this._updatePeaks.bind(this), 100);\r\n\r\n                store.dispatch(recording());\r\n            });\r\n\r\n            socket.on('connect_error', () => {\r\n                store.dispatch(recordingRquestFail())\r\n            })\r\n\r\n            socket.on('recording_finished', ({fileSize}) =>{\r\n                console.log(\"recording finishe event from socekt\")\r\n                const {id, duration, peaks} = this.currentRec;\r\n                store.dispatch(recordFinalUpdate(\r\n                    id, peaks, duration, fileSize\r\n                ))\r\n\r\n                this.currentRec = Recorder.initRecState();\r\n                socket.close();\r\n            })\r\n\r\n            socket.on(\"recording_error\", ()=>{\r\n                store.dispatch(roolbackRecord(this.currentRec.id))\r\n            })\r\n        })\r\n    }\r\n\r\n    endRecording() {\r\n      //  console.log(\"im finish recoriding\")\r\n        if (this.mediaRecorder.state !== 'inactive') {\r\n            this.mediaRecorder.stop();\r\n            clearInterval(this.updateInterval);\r\n            this.currentRec.duration =new Date().getTime() - this.currentRec.duration;\r\n        }\r\n    }\r\n\r\n    _updatePeaks(){\r\n        const len = this.currentRec.peaks.length;\r\n        this.currentRec.peaks[len] = this.mixer.currentPeakMinMax[0];\r\n        this.currentRec.peaks[len + 1] = this.mixer.currentPeakMinMax[1];\r\n    }\r\n\r\n}"]},"metadata":{},"sourceType":"module"}