{"ast":null,"code":"function locateMention(value, fromIndex) {\n  return value.indexOf('{', fromIndex);\n}\n\ntokenizeInlineAttr.notInLink = true;\ntokenizeInlineAttr.locator = locateMention;\n\nfunction tokenizeInlineAttr(eat, value, silent) {\n  const startSign = \"{\";\n  const classSign = \".\";\n  const idSign = \"#\";\n  const endSign = \"}\";\n  let content = \"\";\n  let type = null;\n  let i = 0;\n  if (value[i++] !== startSign) return false;\n  if (![classSign, idSign].contains(value[i])) return false;\n\n  if (value[i] === classSign) {\n    type = \"attrClass\";\n    i++;\n  }\n\n  if (value[i] === idSign) {\n    type = \"attrId\";\n    i++;\n  } // while(i < value.length){\n  //\n  // }\n\n\n  let match = /^{(\\.|#)((?:\\w|-)+)}/.exec(value);\n\n  if (match) {\n    if (silent) {\n      return true;\n    }\n\n    return eat(match[0])({\n      type: match[0] === \"#\" ? 'attrId' : 'attrClass',\n      value: match[2]\n    });\n  }\n}\n\nmodule.exports = tokenizeInlineAttr;","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/introduction/MarkDonwExtesnion/remark-attr/components/tokenizers/inlineAttrTokenizer.js"],"names":["locateMention","value","fromIndex","indexOf","tokenizeInlineAttr","notInLink","locator","eat","silent","startSign","classSign","idSign","endSign","content","type","i","contains","match","exec","module","exports"],"mappings":"AACA,SAASA,aAAT,CAAuBC,KAAvB,EAA8BC,SAA9B,EAAyC;AACrC,SAAOD,KAAK,CAACE,OAAN,CAAc,GAAd,EAAmBD,SAAnB,CAAP;AACH;;AAEDE,kBAAkB,CAACC,SAAnB,GAA+B,IAA/B;AACAD,kBAAkB,CAACE,OAAnB,GAA6BN,aAA7B;;AAEA,SAASI,kBAAT,CAA4BG,GAA5B,EAAiCN,KAAjC,EAAwCO,MAAxC,EAAgD;AAE5C,QAAMC,SAAS,GAAG,GAAlB;AACA,QAAMC,SAAS,GAAG,GAAlB;AACA,QAAMC,MAAM,GAAG,GAAf;AACA,QAAMC,OAAO,GAAG,GAAhB;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,IAAI,GAAG,IAAX;AACA,MAAIC,CAAC,GAAG,CAAR;AAEA,MAAGd,KAAK,CAACc,CAAC,EAAF,CAAL,KAAeN,SAAlB,EAA6B,OAAO,KAAP;AAE7B,MAAG,CAAC,CAACC,SAAD,EAAYC,MAAZ,EAAoBK,QAApB,CAA6Bf,KAAK,CAACc,CAAD,CAAlC,CAAJ,EAA4C,OAAO,KAAP;;AAE5C,MAAGd,KAAK,CAACc,CAAD,CAAL,KAAaL,SAAhB,EAA0B;AACtBI,IAAAA,IAAI,GAAG,WAAP;AACAC,IAAAA,CAAC;AACJ;;AAED,MAAGd,KAAK,CAACc,CAAD,CAAL,KAAaJ,MAAhB,EAAuB;AACnBG,IAAAA,IAAI,GAAG,QAAP;AACAC,IAAAA,CAAC;AACJ,GAtB2C,CAwB5C;AACA;AACA;;;AAEA,MAAIE,KAAK,GAAG,uBAAuBC,IAAvB,CAA4BjB,KAA5B,CAAZ;;AACA,MAAIgB,KAAJ,EAAW;AACP,QAAIT,MAAJ,EAAY;AACR,aAAO,IAAP;AACH;;AACD,WAAOD,GAAG,CAACU,KAAK,CAAC,CAAD,CAAN,CAAH,CAAc;AACjBH,MAAAA,IAAI,EAAGG,KAAK,CAAC,CAAD,CAAL,KAAa,GAAd,GAAqB,QAArB,GAAgC,WADrB;AAEjBhB,MAAAA,KAAK,EAAEgB,KAAK,CAAC,CAAD;AAFK,KAAd,CAAP;AAIH;AACJ;;AAEDE,MAAM,CAACC,OAAP,GAAiBhB,kBAAjB","sourcesContent":["\r\nfunction locateMention(value, fromIndex) {\r\n    return value.indexOf('{', fromIndex)\r\n}\r\n\r\ntokenizeInlineAttr.notInLink = true\r\ntokenizeInlineAttr.locator = locateMention\r\n\r\nfunction tokenizeInlineAttr(eat, value, silent) {\r\n\r\n    const startSign = \"{\";\r\n    const classSign = \".\";\r\n    const idSign = \"#\"\r\n    const endSign = \"}\";\r\n    let content = \"\";\r\n    let type = null;\r\n    let i = 0;\r\n\r\n    if(value[i++] !== startSign) return false;\r\n\r\n    if(![classSign, idSign].contains(value[i])) return false;\r\n\r\n    if(value[i] === classSign){\r\n        type = \"attrClass\";\r\n        i++\r\n    }\r\n\r\n    if(value[i] === idSign){\r\n        type = \"attrId\";\r\n        i++\r\n    }\r\n\r\n    // while(i < value.length){\r\n    //\r\n    // }\r\n\r\n    let match = /^{(\\.|#)((?:\\w|-)+)}/.exec(value)\r\n    if (match) {\r\n        if (silent) {\r\n            return true\r\n        }\r\n        return eat(match[0])({\r\n            type: (match[0] === \"#\") ? 'attrId' : 'attrClass',\r\n            value: match[2]\r\n        })\r\n    }\r\n}\r\n\r\nmodule.exports = tokenizeInlineAttr;\r\n"]},"metadata":{},"sourceType":"module"}