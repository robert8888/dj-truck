{"ast":null,"code":"import _regeneratorRuntime from\"D:\\\\PROJEKTY\\\\APKI\\\\dj-truck\\\\node_modules\\\\@babel\\\\runtime/regenerator\";import _asyncToGenerator from\"D:\\\\PROJEKTY\\\\APKI\\\\dj-truck\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";export default(function(){self.addEventListener(\"message\",function(e){/* eslint-disable-line no-restricted-globals */console.log('in worker get message',e);if(!e||!(e.data[0]instanceof Array)){return;}var peaks=e.data[0];console.log(\"in send back peaks\");interpolate(peaks).then(function(peaks){return postMessage([peaks]);});//setTimeout(()=>postMessage([peaks]), 2000);\n});//simple iterpolate by const factor\n//output is between 1000 and 2000 element \n//input arry is kind of heap. includes min max piars. where n-max element \n//have index 2n and min 2n + 1 \n//--corect it was supposedto be interpolation but just\n// peaking evry n'th element of input has better effect\nfunction interpolate(_x){return _interpolate.apply(this,arguments);}function _interpolate(){_interpolate=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(input){var output,targetBoundry,inputSize,ratio,outputSize,i;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:output=[];targetBoundry={max:2000,min:1000};inputSize=input.length;if(!(inputSize<targetBoundry.min)){_context.next=5;break;}return _context.abrupt(\"return\",input);case 5:ratio=Math.floor(inputSize/targetBoundry.max);outputSize=Math.ceil(inputSize/ratio);for(i=0;i<outputSize/2;i++){// for(let m of [0, 1]){ // min max\n//     // let avg = 0;\n//     // let r;\n//     // for (r = 0; r < ratio; r++) {\n//     //     const index = 2 * (i * ratio + r) + m ;\n//     //     if(index > inputSize)\n//     //         break;\n//     //     avg += input[index];\n//     // }\n//     //output[2 * i + m] = avg / r;\n//     output[2 * i + m] = input[2 * (i * ratio) + m];\n// }\noutput[2*i]=input[2*(i*ratio)];output[2*i+1]=input[2*(i*ratio)+1];}// console.log(\"input \", input)\n// console.log(\"outpout\", output);\nreturn _context.abrupt(\"return\",output);case 9:case\"end\":return _context.stop();}}},_callee);}));return _interpolate.apply(this,arguments);}});","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/console/core/console/mixer/recorder/interpolatePeaksWorker.js"],"names":["self","addEventListener","e","console","log","data","Array","peaks","interpolate","then","postMessage","input","output","targetBoundry","max","min","inputSize","length","ratio","Math","floor","outputSize","ceil","i"],"mappings":"iOAAA,eAAe,UAAM,CACjBA,IAAI,CAACC,gBAAL,CAAsB,SAAtB,CAAiC,SAAAC,CAAC,CAAI,CAAC,+CACnCC,OAAO,CAACC,GAAR,CAAY,uBAAZ,CAAqCF,CAArC,EACA,GAAI,CAACA,CAAD,EAAM,EAAEA,CAAC,CAACG,IAAF,CAAO,CAAP,WAAqBC,CAAAA,KAAvB,CAAV,CAAyC,CACrC,OACH,CACD,GAAMC,CAAAA,KAAK,CAAGL,CAAC,CAACG,IAAF,CAAO,CAAP,CAAd,CAEAF,OAAO,CAACC,GAAR,CAAY,oBAAZ,EACAI,WAAW,CAACD,KAAD,CAAX,CAAmBE,IAAnB,CAAwB,SAAAF,KAAK,QAAIG,CAAAA,WAAW,CAAC,CAACH,KAAD,CAAD,CAAf,EAA7B,EACA;AACH,CAVD,EAWA;AACA;AACA;AACA;AAEA;AACA;AAlBiB,QAoBFC,CAAAA,WApBE,6IAoBjB,iBAA2BG,KAA3B,wKACQC,MADR,CACiB,EADjB,CAEUC,aAFV,CAE0B,CAClBC,GAAG,CAAE,IADa,CAElBC,GAAG,CAAE,IAFa,CAF1B,CAMUC,SANV,CAMsBL,KAAK,CAACM,MAN5B,MAQQD,SAAS,CAAGH,aAAa,CAACE,GARlC,0DASeJ,KATf,SAYUO,KAZV,CAYkBC,IAAI,CAACC,KAAL,CAAWJ,SAAS,CAAGH,aAAa,CAACC,GAArC,CAZlB,CAaUO,UAbV,CAauBF,IAAI,CAACG,IAAL,CAAUN,SAAS,CAAGE,KAAtB,CAbvB,CAeI,IAASK,CAAT,CAAa,CAAb,CAAgBA,CAAC,CAAGF,UAAU,CAAG,CAAjC,CAAoCE,CAAC,EAArC,CAAyC,CACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACAX,MAAM,CAAC,EAAIW,CAAL,CAAN,CAAiBZ,KAAK,CAAC,GAAKY,CAAC,CAAGL,KAAT,CAAD,CAAtB,CACAN,MAAM,CAAC,EAAIW,CAAJ,CAAQ,CAAT,CAAN,CAAoBZ,KAAK,CAAE,GAAKY,CAAC,CAAGL,KAAT,CAAD,CAAoB,CAArB,CAAzB,CAEH,CACD;AACA;AAlCJ,gCAoCWN,MApCX,wDApBiB,8CA0DpB,CA1DD","sourcesContent":["export default () => {\r\n    self.addEventListener(\"message\", e => {/* eslint-disable-line no-restricted-globals */\r\n        console.log('in worker get message', e)\r\n        if (!e || !(e.data[0] instanceof Array)) {\r\n            return;\r\n        }\r\n        const peaks = e.data[0]\r\n\r\n        console.log(\"in send back peaks\")\r\n        interpolate(peaks).then(peaks => postMessage([peaks]))\r\n        //setTimeout(()=>postMessage([peaks]), 2000);\r\n    })\r\n    //simple iterpolate by const factor\r\n    //output is between 1000 and 2000 element \r\n    //input arry is kind of heap. includes min max piars. where n-max element \r\n    //have index 2n and min 2n + 1 \r\n\r\n    //--corect it was supposedto be interpolation but just\r\n    // peaking evry n'th element of input has better effect\r\n\r\n    async function interpolate(input) {\r\n        let output = [];\r\n        const targetBoundry = {\r\n            max: 2000,\r\n            min: 1000,\r\n        }\r\n        const inputSize = input.length;\r\n\r\n        if (inputSize < targetBoundry.min) {\r\n            return input;\r\n        }\r\n\r\n        const ratio = Math.floor(inputSize / targetBoundry.max);\r\n        const outputSize = Math.ceil(inputSize / ratio) ;\r\n\r\n        for (let i = 0; i < outputSize / 2; i++) {\r\n            // for(let m of [0, 1]){ // min max\r\n            //     // let avg = 0;\r\n            //     // let r;\r\n            //     // for (r = 0; r < ratio; r++) {\r\n            //     //     const index = 2 * (i * ratio + r) + m ;\r\n            //     //     if(index > inputSize)\r\n            //     //         break;\r\n            //     //     avg += input[index];\r\n            //     // }\r\n\r\n            //     //output[2 * i + m] = avg / r;\r\n            //     output[2 * i + m] = input[2 * (i * ratio) + m];\r\n            // }\r\n            output[2 * i ] = input[2 * (i * ratio) ];\r\n            output[2 * i + 1] = input[(2 * (i * ratio)) + 1];\r\n\r\n        }\r\n        // console.log(\"input \", input)\r\n        // console.log(\"outpout\", output);\r\n\r\n        return output;\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}