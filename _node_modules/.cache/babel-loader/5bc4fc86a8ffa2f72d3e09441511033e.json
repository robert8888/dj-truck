{"ast":null,"code":"import store from \"./../../../../../store\";\nimport { setAvailableEffects } from \"./../../../../../actions\"; //import { throttel } from \"./../../../../../utils/functions/lodash\";\n\nimport Reverb from \"./effects/reverb/reverb\";\nimport Delay from \"./effects/delay/delay\";\nexport default class Effector {\n  constructor(audioContext) {\n    this.config = store.getState().configuration.effector;\n    this.mainAC = audioContext;\n    this.buildChannels(this.config.channels);\n    this.effects = {\n      \"reverb\": {\n        create: Reverb,\n        params: Reverb.defaultParams().params\n      },\n      \"delay\": {\n        create: Delay,\n        params: Delay.defaultParams().params\n      }\n    };\n    const exportEffects = {};\n    Object.entries(this.effects).forEach(([key, element]) => exportEffects[key] = element.params);\n    store.dispatch(setAvailableEffects(exportEffects));\n  }\n\n  buildChannels(channelNumber) {\n    this.channels = Array.from({\n      length: channelNumber\n    }, index => ({\n      channelNumber: index\n    }));\n\n    for (let chNum = 0; chNum < channelNumber; chNum++) {\n      const channel = this.channels[chNum];\n      channel.inputNode = this.mainAC.createGain();\n      channel.dryNode = this.mainAC.createGain();\n      ;\n      channel.wetNode = this.mainAC.createGain();\n      channel.outputNode = this.mainAC.createGain(); //channel.inputNode.connect(channel.dryNode);\n\n      channel.inputNode.connect(channel.wetNode);\n      channel.dryNode.connect(channel.outputNode);\n      channel.wetNode.connect(channel.outputNode);\n    }\n  }\n\n  connect(inputs) {\n    const outputs = [];\n    inputs.forEach((inputNode, chNum) => {\n      inputNode.connect(this.channels[chNum].inputNode);\n      outputs.push(this.channels[chNum].outputNode);\n    });\n    console.log(inputs);\n    return outputs;\n  }\n\n  setDryWet(channelNumber, value) {\n    channelNumber--;\n    console.log(\"set dry wet\", channelNumber + \" val:\", value);\n    const channel = this.channels[channelNumber];\n    channel.dryNode.gain.setTargetAtTime(0, this.mainAC.currentTime, 0.01);\n  }\n\n  setEffect(channelNumber, effectName) {\n    //     console.log(channelNumber)\n    channelNumber--; //array index\n\n    const channel = this.channels[channelNumber]; //     console.log(channel)\n\n    if (effectName) {\n      let params = this.assingDefaultParams({}, effectName);\n      const effectorChannel = store.getState().effector.channels;\n\n      if (effectorChannel && effectorChannel[channelNumber]) {\n        params = { ...effectorChannel[channelNumber].effects[effectName]\n        };\n      }\n\n      const effect = new this.effects[effectName].create(this.mainAC, params);\n      channel.currentEffect = effect;\n      console.log(\"connecting\", channelNumber, channel, effect);\n      channel.inputNode.connect(channel.dryNode);\n      effect.connect(channel.inputNode, channel.wetNode);\n    } else {} //remove effect\n    //  console.log(channel)\n    //  const params = {...channelEffects[effect]};\n    //  console.log(params);\n    //\n\n  }\n\n  assingDefaultParams(obj, effect) {\n    Object.entries(this.effects[effect].params).forEach(([key, value]) => {\n      obj[key] = value.defaultValue;\n    });\n    return obj;\n  }\n\n  setParam(channelNumber, effect, param) {\n    //console.log(\"set param : \"+ channelNumber, \"effect: \" + effect, \" pram: \" + JSON.stringify(param));\n    channelNumber--;\n    const channel = this.channels[channelNumber];\n\n    if (channel.currentEffect && channel.currentEffect.name === effect) {\n      Object.entries(param).forEach(([key, value]) => {\n        channel.currentEffect[key] = value;\n      });\n    }\n  }\n\n  disconectCurrent(channel) {\n    console.log(\"disconnecting chanel\", channel.channelNumber);\n\n    if (!channel.currentEffect) {\n      channel.inputNode.disconect();\n      channel.inputNode.connect(channel.dryNode);\n      channel.currentEffect.disconect();\n      channel.currentEffect = null;\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/src/pages/app/core/console/effector/effector.js"],"names":["store","setAvailableEffects","Reverb","Delay","Effector","constructor","audioContext","config","getState","configuration","effector","mainAC","buildChannels","channels","effects","create","params","defaultParams","exportEffects","Object","entries","forEach","key","element","dispatch","channelNumber","Array","from","length","index","chNum","channel","inputNode","createGain","dryNode","wetNode","outputNode","connect","inputs","outputs","push","console","log","setDryWet","value","gain","setTargetAtTime","currentTime","setEffect","effectName","assingDefaultParams","effectorChannel","effect","currentEffect","obj","defaultValue","setParam","param","name","disconectCurrent","disconect"],"mappings":"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","sourcesContent":["\r\nimport store from \"./../../../../../store\";\r\nimport { setAvailableEffects } from \"./../../../../../actions\";\r\n//import { throttel } from \"./../../../../../utils/functions/lodash\";\r\nimport Reverb from \"./effects/reverb/reverb\";\r\nimport Delay from \"./effects/delay/delay\";\r\n\r\n\r\n\r\nexport default class Effector {\r\n    constructor(audioContext) {\r\n        this.config = store.getState().configuration.effector;\r\n        this.mainAC = audioContext;\r\n\r\n        this.buildChannels(this.config.channels);\r\n\r\n\r\n        this.effects = {\r\n            \"reverb\": {\r\n                create: Reverb,\r\n                params: Reverb.defaultParams().params,\r\n            },\r\n            \"delay\": {\r\n                create: Delay,\r\n                params: Delay.defaultParams().params\r\n            }\r\n        }\r\n\r\n        const exportEffects = {};\r\n        Object.entries(this.effects).forEach(([key, element]) =>\r\n            exportEffects[key] = element.params\r\n        );\r\n        store.dispatch(setAvailableEffects(exportEffects));\r\n    }\r\n\r\n    buildChannels(channelNumber) {\r\n        this.channels =\r\n            Array.from({ length: channelNumber }, (index) => ({ channelNumber: index }));\r\n\r\n        for (let chNum = 0; chNum < channelNumber; chNum++) {\r\n            const channel = this.channels[chNum];\r\n\r\n            channel.inputNode = this.mainAC.createGain();\r\n            channel.dryNode = this.mainAC.createGain();;\r\n            channel.wetNode = this.mainAC.createGain();\r\n            channel.outputNode = this.mainAC.createGain();\r\n\r\n            //channel.inputNode.connect(channel.dryNode);\r\n            channel.inputNode.connect(channel.wetNode);\r\n            channel.dryNode.connect(channel.outputNode);\r\n            channel.wetNode.connect(channel.outputNode);\r\n        }\r\n    }\r\n\r\n    connect(inputs) {\r\n        \r\n        const outputs = [];\r\n        \r\n        inputs.forEach((inputNode, chNum) => {\r\n            inputNode.connect(this.channels[chNum].inputNode);\r\n            outputs.push(this.channels[chNum].outputNode)\r\n        });\r\n        console.log(inputs)\r\n        \r\n        return outputs;\r\n    }\r\n\r\n\r\n    setDryWet(channelNumber, value) {\r\n        channelNumber--;\r\n        console.log(\"set dry wet\", channelNumber + \" val:\", value);\r\n        const channel = this.channels[channelNumber];\r\n        channel.dryNode.gain.setTargetAtTime(0, this.mainAC.currentTime, 0.01);\r\n    }\r\n\r\n    setEffect(channelNumber, effectName) {\r\n        //     console.log(channelNumber)\r\n        channelNumber--;//array index\r\n        const channel = this.channels[channelNumber];\r\n   //     console.log(channel)\r\n\r\n        if (effectName) {\r\n            let params = this.assingDefaultParams({}, effectName);\r\n\r\n            const effectorChannel = store.getState().effector.channels;\r\n\r\n            if (effectorChannel && effectorChannel[channelNumber]) {\r\n                params = { ...effectorChannel[channelNumber].effects[effectName] }\r\n            }\r\n\r\n            const effect = new this.effects[effectName].create(this.mainAC, params);\r\n\r\n            channel.currentEffect = effect;\r\n            console.log(\"connecting\", channelNumber, channel, effect)\r\n            channel.inputNode.connect(channel.dryNode)\r\n\r\n            effect.connect(channel.inputNode, channel.wetNode)\r\n\r\n        } else {\r\n            //remove effect\r\n        }\r\n        //  console.log(channel)\r\n        //  const params = {...channelEffects[effect]};\r\n        //  console.log(params);\r\n        //\r\n    }\r\n\r\n    assingDefaultParams(obj, effect) {\r\n        Object.entries(this.effects[effect].params).forEach(([key, value]) => {\r\n            obj[key] = value.defaultValue;\r\n        })\r\n        return obj;\r\n    }\r\n\r\n    setParam(channelNumber, effect, param) {\r\n        //console.log(\"set param : \"+ channelNumber, \"effect: \" + effect, \" pram: \" + JSON.stringify(param));\r\n        channelNumber--;\r\n        const channel = this.channels[channelNumber];\r\n        if (channel.currentEffect && channel.currentEffect.name === effect) {\r\n            Object.entries(param).forEach(([key, value]) => {\r\n                channel.currentEffect[key] = value;\r\n            })\r\n        }\r\n    }\r\n\r\n\r\n    disconectCurrent(channel) {\r\n        console.log(\"disconnecting chanel\", channel.channelNumber)\r\n        if (!channel.currentEffect) {\r\n            channel.inputNode.disconect();\r\n            channel.inputNode.connect(channel.dryNode);\r\n            channel.currentEffect.disconect();\r\n            channel.currentEffect = null;\r\n        }\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}