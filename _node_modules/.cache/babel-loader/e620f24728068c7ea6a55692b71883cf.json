{"ast":null,"code":"export default (() => {\n  self.addEventListener(\"message\", e => {\n    /* eslint-disable-line no-restricted-globals */\n    console.log('in worker get message', e);\n\n    if (!e || !(e.data[0] instanceof Array)) {\n      return;\n    }\n\n    const peaks = e.data[0];\n    console.log(\"in send back peaks\");\n    interpolate(peaks).then(peaks => postMessage([peaks])); //setTimeout(()=>postMessage([peaks]), 2000);\n  }); //simple iterpolate by const factor\n  //output is between 1000 and 2000 element \n  //input arry is kind of heap. includes min max piars. where n-max element \n  //have index 2n and min 2n + 1 \n\n  async function interpolate(input) {\n    let output = [];\n    const targetBoundry = {\n      max: 2000,\n      min: 1000\n    };\n    const inputSize = input.length;\n\n    if (inputSize < targetBoundry.min) {\n      return input;\n    }\n\n    const ratio = Math.floor(inputSize / targetBoundry.max);\n    const outputSize = Math.ceil(inputSize / ratio);\n\n    for (let i = 0; i < outputSize; i++) {\n      for (let m of [0, 1]) {\n        // min max\n        let avg = 0;\n        let r;\n\n        for (r = 0; r < ratio; r++) {\n          const index = 2 * i + m * ratio + r;\n          if (index > inputSize) break;\n          avg = input[index];\n        }\n\n        output[2 * i + m] = avg / r;\n      }\n    }\n\n    return output;\n  }\n});","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/console/core/console/mixer/recorder/interpolatePeaksWorker.js"],"names":["self","addEventListener","e","console","log","data","Array","peaks","interpolate","then","postMessage","input","output","targetBoundry","max","min","inputSize","length","ratio","Math","floor","outputSize","ceil","i","m","avg","r","index"],"mappings":"AAAA,gBAAe,MAAM;AACjBA,EAAAA,IAAI,CAACC,gBAAL,CAAsB,SAAtB,EAAiCC,CAAC,IAAI;AAAC;AACnCC,IAAAA,OAAO,CAACC,GAAR,CAAY,uBAAZ,EAAqCF,CAArC;;AACA,QAAI,CAACA,CAAD,IAAM,EAAEA,CAAC,CAACG,IAAF,CAAO,CAAP,aAAqBC,KAAvB,CAAV,EAAyC;AACrC;AACH;;AACD,UAAMC,KAAK,GAAGL,CAAC,CAACG,IAAF,CAAO,CAAP,CAAd;AAEAF,IAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ;AACAI,IAAAA,WAAW,CAACD,KAAD,CAAX,CAAmBE,IAAnB,CAAwBF,KAAK,IAAIG,WAAW,CAAC,CAACH,KAAD,CAAD,CAA5C,EARkC,CASlC;AACH,GAVD,EADiB,CAYjB;AACA;AACA;AACA;;AAEA,iBAAeC,WAAf,CAA2BG,KAA3B,EAAkC;AAC9B,QAAIC,MAAM,GAAG,EAAb;AACA,UAAMC,aAAa,GAAG;AAClBC,MAAAA,GAAG,EAAE,IADa;AAElBC,MAAAA,GAAG,EAAE;AAFa,KAAtB;AAIA,UAAMC,SAAS,GAAGL,KAAK,CAACM,MAAxB;;AAEA,QAAID,SAAS,GAAGH,aAAa,CAACE,GAA9B,EAAmC;AAC/B,aAAOJ,KAAP;AACH;;AAED,UAAMO,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWJ,SAAS,GAAGH,aAAa,CAACC,GAArC,CAAd;AACA,UAAMO,UAAU,GAAGF,IAAI,CAACG,IAAL,CAAUN,SAAS,GAAGE,KAAtB,CAAnB;;AAEA,SAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,UAApB,EAAgCE,CAAC,EAAjC,EAAqC;AACjC,WAAI,IAAIC,CAAR,IAAa,CAAC,CAAD,EAAI,CAAJ,CAAb,EAAoB;AAAE;AAClB,YAAIC,GAAG,GAAG,CAAV;AACA,YAAIC,CAAJ;;AACA,aAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGR,KAAhB,EAAuBQ,CAAC,EAAxB,EAA4B;AACxB,gBAAMC,KAAK,GAAG,IAAIJ,CAAJ,GAAQC,CAAC,GAAGN,KAAZ,GAAoBQ,CAAlC;AACA,cAAGC,KAAK,GAAGX,SAAX,EACI;AACJS,UAAAA,GAAG,GAAGd,KAAK,CAACgB,KAAD,CAAX;AACH;;AACDf,QAAAA,MAAM,CAAC,IAAIW,CAAJ,GAAQC,CAAT,CAAN,GAAoBC,GAAG,GAAGC,CAA1B;AACH;AAEJ;;AAED,WAAOd,MAAP;AACH;AACJ,CAjDD","sourcesContent":["export default () => {\r\n    self.addEventListener(\"message\", e => {/* eslint-disable-line no-restricted-globals */\r\n        console.log('in worker get message', e)\r\n        if (!e || !(e.data[0] instanceof Array)) {\r\n            return;\r\n        }\r\n        const peaks = e.data[0]\r\n\r\n        console.log(\"in send back peaks\")\r\n        interpolate(peaks).then(peaks => postMessage([peaks]))\r\n        //setTimeout(()=>postMessage([peaks]), 2000);\r\n    })\r\n    //simple iterpolate by const factor\r\n    //output is between 1000 and 2000 element \r\n    //input arry is kind of heap. includes min max piars. where n-max element \r\n    //have index 2n and min 2n + 1 \r\n\r\n    async function interpolate(input) {\r\n        let output = [];\r\n        const targetBoundry = {\r\n            max: 2000,\r\n            min: 1000,\r\n        }\r\n        const inputSize = input.length;\r\n\r\n        if (inputSize < targetBoundry.min) {\r\n            return input;\r\n        }\r\n\r\n        const ratio = Math.floor(inputSize / targetBoundry.max);\r\n        const outputSize = Math.ceil(inputSize / ratio);\r\n\r\n        for (let i = 0; i < outputSize; i++) {\r\n            for(let m of [0, 1]){ // min max\r\n                let avg = 0;\r\n                let r;\r\n                for (r = 0; r < ratio; r++) {\r\n                    const index = 2 * i + m * ratio + r;\r\n                    if(index > inputSize)\r\n                        break;\r\n                    avg = input[index];\r\n                }\r\n                output[2 * i + m] = avg / r;\r\n            }\r\n\r\n        }\r\n\r\n        return output;\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}