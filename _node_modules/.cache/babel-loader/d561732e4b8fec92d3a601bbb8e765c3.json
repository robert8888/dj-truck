{"ast":null,"code":"import store from \"./../../../../../store\";\nimport { setAvailableEffects } from \"./../../../../../actions\"; //import { throttel } from \"./../../../../../utils/functions/lodash\";\n\nimport Reverb from \"./effects/reverb/reverb\";\nimport Delay from \"./effects/delay/delay\";\nexport default class Effector {\n  constructor(audioContext) {\n    this.config = store.getState().configuration.effector;\n    this.mainAC = audioContext;\n    this.channels = new Array(this.config.channels).fill(null).map(index => Object.create({\n      channelNumber: index\n    }));\n    this.effects = {\n      \"reverb\": {\n        create: Reverb,\n        params: Reverb.defaultParams().params\n      },\n      \"delay\": {\n        create: Delay,\n        params: Delay.defaultParams().params\n      }\n    };\n    const exportEffects = {};\n    Object.entries(this.effects).forEach(([key, element]) => exportEffects[key] = element.params);\n    store.dispatch(setAvailableEffects(exportEffects));\n  }\n\n  connect(inputs) {\n    const outputs = inputs.map(() => this.mainAC.createGain());\n    inputs.forEach((inputNode, channelNumber) => {\n      const dryNode = this.mainAC.createGain();\n      const wetNode = this.mainAC.createGain(); //dryNode.gain.value = .5;\n\n      inputNode.connect(dryNode);\n      dryNode.connect(outputs[channelNumber]);\n      wetNode.connect(outputs[channelNumber]);\n      this.channels[channelNumber].inputNode = inputNode;\n      this.channels[channelNumber].dryNode = dryNode;\n      this.channels[channelNumber].wetNode = wetNode;\n      this.channels[channelNumber].outputNode = outputs[channelNumber];\n    });\n    return outputs;\n  }\n\n  setDryWet(channelNumber, value) {\n    channelNumber--;\n    console.log(\"set dry wet\", channelNumber + \" val:\", value);\n    const channel = this.channels[channelNumber];\n    channel.dryNode.gain.setTargetAtTime(0, this.mainAC.currentTime, 0.01);\n  }\n\n  setEffect(channelNumber, effectName) {\n    //     console.log(channelNumber)\n    channelNumber--; //array index\n\n    const channel = this.channels[channelNumber];\n    console.log(channel);\n\n    if (effectName) {\n      let params = this.assingDefaultParams({}, effectName);\n      const effectorChannel = store.getState().effector.channels;\n\n      if (effectorChannel && effectorChannel[channelNumber]) {\n        params = { ...effectorChannel[channelNumber].effects[effectName]\n        };\n      }\n\n      const effect = new this.effects[effectName].create(this.mainAC, params);\n      channel.currentEffect = effect;\n      console.log(\"connecting\", channelNumber, channel, effect);\n      channel.inputNode.connect(channel.dryNode);\n      effect.connect(channel.inputNode, channel.wetNode);\n    } else {} //remove effect\n    //  console.log(channel)\n    //  const params = {...channelEffects[effect]};\n    //  console.log(params);\n    //\n\n  }\n\n  assingDefaultParams(obj, effect) {\n    Object.entries(this.effects[effect].params).forEach(([key, value]) => {\n      obj[key] = value.defaultValue;\n    });\n    return obj;\n  }\n\n  setParam(channelNumber, effect, param) {\n    //console.log(\"set param : \"+ channelNumber, \"effect: \" + effect, \" pram: \" + JSON.stringify(param));\n    channelNumber--;\n    const channel = this.channels[channelNumber];\n\n    if (channel.currentEffect && channel.currentEffect.name === effect) {\n      Object.entries(param).forEach(([key, value]) => {\n        channel.currentEffect[key] = value;\n      });\n    }\n  }\n\n  disconectCurrent(channel) {\n    if (!channel.currentEffect) {\n      channel.inputNode.disconect();\n      channel.inputNode.connect(channel.dryNode);\n      channel.currentEffect.disconect();\n      channel.currentEffect = null;\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/src/pages/app/core/console/effector/effector.js"],"names":["store","setAvailableEffects","Reverb","Delay","Effector","constructor","audioContext","config","getState","configuration","effector","mainAC","channels","Array","fill","map","index","Object","create","channelNumber","effects","params","defaultParams","exportEffects","entries","forEach","key","element","dispatch","connect","inputs","outputs","createGain","inputNode","dryNode","wetNode","outputNode","setDryWet","value","console","log","channel","gain","setTargetAtTime","currentTime","setEffect","effectName","assingDefaultParams","effectorChannel","effect","currentEffect","obj","defaultValue","setParam","param","name","disconectCurrent","disconect"],"mappings":"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","sourcesContent":["\r\nimport store from \"./../../../../../store\";\r\nimport { setAvailableEffects } from \"./../../../../../actions\";\r\n//import { throttel } from \"./../../../../../utils/functions/lodash\";\r\nimport Reverb from \"./effects/reverb/reverb\";\r\nimport Delay from \"./effects/delay/delay\";\r\n\r\n\r\n\r\nexport default class Effector {\r\n    constructor(audioContext) {\r\n        this.config = store.getState().configuration.effector;\r\n        this.mainAC = audioContext;\r\n\r\n        this.channels = new Array(this.config.channels)\r\n                         .fill(null).map((index) => Object.create({channelNumber : index}));\r\n        \r\n        this.effects = {\r\n            \"reverb\": {\r\n                create: Reverb,\r\n                params: Reverb.defaultParams().params,\r\n            },\r\n            \"delay\": {\r\n                create: Delay,\r\n                params: Delay.defaultParams().params\r\n            }\r\n        }\r\n\r\n        const exportEffects = {};\r\n        Object.entries(this.effects).forEach(([key, element]) =>\r\n                exportEffects[key] = element.params\r\n            );\r\n        store.dispatch(setAvailableEffects(exportEffects));\r\n    }\r\n\r\n    connect(inputs) {\r\n        const outputs = inputs.map(() => this.mainAC.createGain())\r\n\r\n        inputs.forEach((inputNode, channelNumber) => {\r\n            const dryNode = this.mainAC.createGain();\r\n            const wetNode = this.mainAC.createGain();\r\n            \r\n            //dryNode.gain.value = .5;\r\n\r\n            inputNode.connect(dryNode);\r\n            dryNode.connect(outputs[channelNumber]);\r\n            wetNode.connect(outputs[channelNumber]);\r\n\r\n            this.channels[channelNumber].inputNode = inputNode;\r\n            this.channels[channelNumber].dryNode = dryNode;\r\n            this.channels[channelNumber].wetNode = wetNode;\r\n            this.channels[channelNumber].outputNode = outputs[channelNumber];\r\n\r\n\r\n        });\r\n\r\n        return outputs;\r\n    }\r\n\r\n\r\n    setDryWet(channelNumber, value){\r\n        channelNumber--;\r\n        console.log(\"set dry wet\", channelNumber + \" val:\", value);\r\n        const channel = this.channels[channelNumber];\r\n        channel.dryNode.gain.setTargetAtTime(0, this.mainAC.currentTime, 0.01);\r\n    }\r\n       \r\n    setEffect(channelNumber, effectName){ \r\n   //     console.log(channelNumber)\r\n        channelNumber--;//array index\r\n        const channel = this.channels[channelNumber];\r\n        console.log(channel)\r\n\r\n        if(effectName){\r\n            let params = this.assingDefaultParams({}, effectName);\r\n     \r\n            const effectorChannel = store.getState().effector.channels;\r\n\r\n            if(effectorChannel && effectorChannel[channelNumber]){\r\n                params = {...effectorChannel[channelNumber].effects[effectName]}\r\n            }\r\n\r\n            const effect = new this.effects[effectName].create(this.mainAC, params);\r\n\r\n            channel.currentEffect = effect;\r\n            console.log(\"connecting\",channelNumber,  channel, effect)\r\n            channel.inputNode.connect(channel.dryNode)\r\n\r\n            effect.connect(channel.inputNode, channel.wetNode)\r\n\r\n        } else {\r\n            //remove effect\r\n        }\r\n      //  console.log(channel)\r\n      //  const params = {...channelEffects[effect]};\r\n      //  console.log(params);\r\n        //\r\n    }\r\n\r\n    assingDefaultParams(obj, effect){\r\n        Object.entries(this.effects[effect].params).forEach(([key, value])=>{\r\n            obj[key] = value.defaultValue;\r\n        })\r\n        return obj;\r\n    }\r\n\r\n    setParam(channelNumber, effect, param){\r\n        //console.log(\"set param : \"+ channelNumber, \"effect: \" + effect, \" pram: \" + JSON.stringify(param));\r\n        channelNumber--;\r\n        const channel = this.channels[channelNumber];\r\n        if(channel.currentEffect && channel.currentEffect.name === effect){\r\n            Object.entries(param).forEach(([key, value])=>{\r\n                channel.currentEffect[key] = value;\r\n            })\r\n        }\r\n    }\r\n\r\n\r\n    disconectCurrent(channel){\r\n        if(!channel.currentEffect){\r\n            channel.inputNode.disconect();\r\n            channel.inputNode.connect(channel.dryNode);\r\n            channel.currentEffect.disconect();\r\n            channel.currentEffect = null;\r\n        }\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}