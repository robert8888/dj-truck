{"ast":null,"code":"'use strict';\n\nvar xtend = require('xtend');\n\nvar defaults = require('./github.json');\n\nmodule.exports = wrapper;\nvar own = {}.hasOwnProperty;\nvar allData = 'data*';\nvar commentEnd = '-->';\nvar nodeSchema = {\n  root: {\n    children: all\n  },\n  doctype: handleDoctype,\n  comment: handleComment,\n  element: {\n    tagName: handleTagName,\n    properties: handleProperties,\n    children: all\n  },\n  text: {\n    value: handleValue\n  },\n  '*': {\n    data: allow,\n    position: allow\n  }\n}; // Sanitize `node`, according to `schema`.\n\nfunction wrapper(node, schema) {\n  var ctx = {\n    type: 'root',\n    children: []\n  };\n  var replace;\n\n  if (!node || typeof node !== 'object' || !node.type) {\n    return ctx;\n  }\n\n  replace = one(xtend(defaults, schema || {}), node, []);\n\n  if (!replace) {\n    return ctx;\n  }\n\n  if ('length' in replace) {\n    if (replace.length === 1) {\n      return replace[0];\n    }\n\n    ctx.children = replace;\n    return ctx;\n  }\n\n  return replace;\n} // Sanitize `node`.\n\n\nfunction one(schema, node, stack) {\n  var type = node && node.type;\n  var replacement = {\n    type: node.type\n  };\n  var replace = true;\n  var definition;\n  var allowed;\n  var result;\n  var key;\n\n  if (!own.call(nodeSchema, type)) {\n    replace = false;\n  } else {\n    definition = nodeSchema[type];\n\n    if (typeof definition === 'function') {\n      definition = definition(schema, node);\n    }\n\n    if (!definition) {\n      replace = false;\n    } else {\n      allowed = xtend(definition, nodeSchema['*']);\n\n      for (key in allowed) {\n        result = allowed[key](schema, node[key], node, stack);\n\n        if (result === false) {\n          replace = false; // Set the non-safe value.\n\n          replacement[key] = node[key];\n        } else if (result !== null && result !== undefined) {\n          replacement[key] = result;\n        }\n      }\n    }\n  }\n\n  if (!replace) {\n    if (!replacement.children || replacement.children.length === 0 || schema.strip.indexOf(replacement.tagName) !== -1) {\n      return null;\n    }\n\n    return replacement.children;\n  }\n\n  return replacement;\n} // Sanitize `children`.\n\n\nfunction all(schema, children, node, stack) {\n  var nodes = children || [];\n  var length = nodes.length || 0;\n  var results = [];\n  var index = -1;\n  var result;\n  stack = stack.concat(node.tagName);\n\n  while (++index < length) {\n    result = one(schema, nodes[index], stack);\n\n    if (result) {\n      if ('length' in result) {\n        results = results.concat(result);\n      } else {\n        results.push(result);\n      }\n    }\n  }\n\n  return results;\n} // Sanitize `properties`.\n\n\nfunction handleProperties(schema, properties, node, stack) {\n  var name = handleTagName(schema, node.tagName, node, stack);\n  var attrs = schema.attributes;\n  var reqs = schema.required ||\n  /* istanbul ignore next */\n  {};\n  var props = properties || {};\n  var result = {};\n  var allowed;\n  var required;\n  var definition;\n  var prop;\n  var value;\n  allowed = xtend(toPropertyValueMap(attrs['*']), toPropertyValueMap(own.call(attrs, name) ? attrs[name] : []));\n\n  for (prop in props) {\n    value = props[prop];\n\n    if (own.call(allowed, prop)) {\n      definition = allowed[prop];\n    } else if (data(prop) && own.call(allowed, allData)) {\n      definition = allowed[allData];\n    } else {\n      continue;\n    }\n\n    if (value && typeof value === 'object' && 'length' in value) {\n      value = handlePropertyValues(schema, value, prop, definition);\n    } else {\n      value = handlePropertyValue(schema, value, prop, definition);\n    }\n\n    if (value !== null && value !== undefined) {\n      result[prop] = value;\n    }\n  }\n\n  required = own.call(reqs, name) ? reqs[name] : {};\n\n  for (prop in required) {\n    if (!own.call(result, prop)) {\n      result[prop] = required[prop];\n    }\n  }\n\n  return result;\n} // Sanitize a property value which is a list.\n\n\nfunction handlePropertyValues(schema, values, prop, definition) {\n  var length = values.length;\n  var result = [];\n  var index = -1;\n  var value;\n\n  while (++index < length) {\n    value = handlePropertyValue(schema, values[index], prop, definition);\n\n    if (value !== null && value !== undefined) {\n      result.push(value);\n    }\n  }\n\n  return result;\n} // Sanitize a property value.\n\n\nfunction handlePropertyValue(schema, value, prop, definition) {\n  if (typeof value !== 'boolean' && typeof value !== 'number' && typeof value !== 'string') {\n    return null;\n  }\n\n  if (!handleProtocol(schema, value, prop)) {\n    return null;\n  }\n\n  if (definition.length !== 0 && definition.indexOf(value) === -1) {\n    return null;\n  }\n\n  if (schema.clobber.indexOf(prop) !== -1) {\n    value = schema.clobberPrefix + value;\n  }\n\n  return value;\n} // Check whether `value` is a safe URL.\n\n\nfunction handleProtocol(schema, value, prop) {\n  var protocols = schema.protocols;\n  var protocol;\n  var first;\n  var colon;\n  var length;\n  var index;\n  protocols = own.call(protocols, prop) ? protocols[prop].concat() : [];\n\n  if (protocols.length === 0) {\n    return true;\n  }\n\n  value = String(value);\n  first = value.charAt(0);\n\n  if (first === '#' || first === '/') {\n    return true;\n  }\n\n  colon = value.indexOf(':');\n\n  if (colon === -1) {\n    return true;\n  }\n\n  length = protocols.length;\n  index = -1;\n\n  while (++index < length) {\n    protocol = protocols[index];\n\n    if (colon === protocol.length && value.slice(0, protocol.length) === protocol) {\n      return true;\n    }\n  }\n\n  index = value.indexOf('?');\n\n  if (index !== -1 && colon > index) {\n    return true;\n  }\n\n  index = value.indexOf('#');\n\n  if (index !== -1 && colon > index) {\n    return true;\n  }\n\n  return false;\n} // Always return a valid HTML5 doctype.\n\n\nfunction handleDoctypeName() {\n  return 'html';\n} // Sanitize `tagName`.\n\n\nfunction handleTagName(schema, tagName, node, stack) {\n  var name = typeof tagName === 'string' ? tagName : null;\n  var ancestors = schema.ancestors;\n  var length;\n  var index;\n\n  if (!name || name === '*' || schema.tagNames.indexOf(name) === -1) {\n    return false;\n  }\n\n  ancestors = own.call(ancestors, name) ? ancestors[name] : []; // Some nodes can break out of their context if they donâ€™t have a certain\n  // ancestor.\n\n  if (ancestors.length !== 0) {\n    length = ancestors.length + 1;\n    index = -1;\n\n    while (++index < length) {\n      if (!ancestors[index]) {\n        return false;\n      }\n\n      if (stack.indexOf(ancestors[index]) !== -1) {\n        break;\n      }\n    }\n  }\n\n  return name;\n}\n\nfunction handleDoctype(schema) {\n  return schema.allowDoctypes ? {\n    name: handleDoctypeName\n  } : null;\n}\n\nfunction handleComment(schema) {\n  return schema.allowComments ? {\n    value: handleCommentValue\n  } : null;\n} // See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\n\n\nfunction handleCommentValue(schema, value) {\n  var result = typeof value === 'string' ? value : '';\n  var index = result.indexOf(commentEnd);\n  return index === -1 ? result : result.slice(0, index);\n} // Sanitize `value`.\n\n\nfunction handleValue(schema, value) {\n  return typeof value === 'string' ? value : '';\n} // Create a map from a list of props or a list of properties and values.\n\n\nfunction toPropertyValueMap(values) {\n  var result = {};\n  var length = values.length;\n  var index = -1;\n  var value;\n\n  while (++index < length) {\n    value = values[index];\n\n    if (value && typeof value === 'object' && 'length' in value) {\n      result[value[0]] = value.slice(1);\n    } else {\n      result[value] = [];\n    }\n  }\n\n  return result;\n} // Allow `value`.\n\n\nfunction allow(schema, value) {\n  return value;\n} // Check if `prop` is a data property.\n\n\nfunction data(prop) {\n  return prop.length > 4 && prop.slice(0, 4).toLowerCase() === 'data';\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/node_modules/hast-util-sanitize/lib/index.js"],"names":["xtend","require","defaults","module","exports","wrapper","own","hasOwnProperty","allData","commentEnd","nodeSchema","root","children","all","doctype","handleDoctype","comment","handleComment","element","tagName","handleTagName","properties","handleProperties","text","value","handleValue","data","allow","position","node","schema","ctx","type","replace","one","length","stack","replacement","definition","allowed","result","key","call","undefined","strip","indexOf","nodes","results","index","concat","push","name","attrs","attributes","reqs","required","props","prop","toPropertyValueMap","handlePropertyValues","handlePropertyValue","values","handleProtocol","clobber","clobberPrefix","protocols","protocol","first","colon","String","charAt","slice","handleDoctypeName","ancestors","tagNames","allowDoctypes","allowComments","handleCommentValue","toLowerCase"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,eAAD,CAAtB;;AAEAE,MAAM,CAACC,OAAP,GAAiBC,OAAjB;AAEA,IAAIC,GAAG,GAAG,GAAGC,cAAb;AAEA,IAAIC,OAAO,GAAG,OAAd;AACA,IAAIC,UAAU,GAAG,KAAjB;AAEA,IAAIC,UAAU,GAAG;AACfC,EAAAA,IAAI,EAAE;AAACC,IAAAA,QAAQ,EAAEC;AAAX,GADS;AAEfC,EAAAA,OAAO,EAAEC,aAFM;AAGfC,EAAAA,OAAO,EAAEC,aAHM;AAIfC,EAAAA,OAAO,EAAE;AACPC,IAAAA,OAAO,EAAEC,aADF;AAEPC,IAAAA,UAAU,EAAEC,gBAFL;AAGPV,IAAAA,QAAQ,EAAEC;AAHH,GAJM;AASfU,EAAAA,IAAI,EAAE;AAACC,IAAAA,KAAK,EAAEC;AAAR,GATS;AAUf,OAAK;AACHC,IAAAA,IAAI,EAAEC,KADH;AAEHC,IAAAA,QAAQ,EAAED;AAFP;AAVU,CAAjB,C,CAgBA;;AACA,SAAStB,OAAT,CAAiBwB,IAAjB,EAAuBC,MAAvB,EAA+B;AAC7B,MAAIC,GAAG,GAAG;AAACC,IAAAA,IAAI,EAAE,MAAP;AAAepB,IAAAA,QAAQ,EAAE;AAAzB,GAAV;AACA,MAAIqB,OAAJ;;AAEA,MAAI,CAACJ,IAAD,IAAS,OAAOA,IAAP,KAAgB,QAAzB,IAAqC,CAACA,IAAI,CAACG,IAA/C,EAAqD;AACnD,WAAOD,GAAP;AACD;;AAEDE,EAAAA,OAAO,GAAGC,GAAG,CAAClC,KAAK,CAACE,QAAD,EAAW4B,MAAM,IAAI,EAArB,CAAN,EAAgCD,IAAhC,EAAsC,EAAtC,CAAb;;AAEA,MAAI,CAACI,OAAL,EAAc;AACZ,WAAOF,GAAP;AACD;;AAED,MAAI,YAAYE,OAAhB,EAAyB;AACvB,QAAIA,OAAO,CAACE,MAAR,KAAmB,CAAvB,EAA0B;AACxB,aAAOF,OAAO,CAAC,CAAD,CAAd;AACD;;AAEDF,IAAAA,GAAG,CAACnB,QAAJ,GAAeqB,OAAf;AAEA,WAAOF,GAAP;AACD;;AAED,SAAOE,OAAP;AACD,C,CAED;;;AACA,SAASC,GAAT,CAAaJ,MAAb,EAAqBD,IAArB,EAA2BO,KAA3B,EAAkC;AAChC,MAAIJ,IAAI,GAAGH,IAAI,IAAIA,IAAI,CAACG,IAAxB;AACA,MAAIK,WAAW,GAAG;AAACL,IAAAA,IAAI,EAAEH,IAAI,CAACG;AAAZ,GAAlB;AACA,MAAIC,OAAO,GAAG,IAAd;AACA,MAAIK,UAAJ;AACA,MAAIC,OAAJ;AACA,MAAIC,MAAJ;AACA,MAAIC,GAAJ;;AAEA,MAAI,CAACnC,GAAG,CAACoC,IAAJ,CAAShC,UAAT,EAAqBsB,IAArB,CAAL,EAAiC;AAC/BC,IAAAA,OAAO,GAAG,KAAV;AACD,GAFD,MAEO;AACLK,IAAAA,UAAU,GAAG5B,UAAU,CAACsB,IAAD,CAAvB;;AAEA,QAAI,OAAOM,UAAP,KAAsB,UAA1B,EAAsC;AACpCA,MAAAA,UAAU,GAAGA,UAAU,CAACR,MAAD,EAASD,IAAT,CAAvB;AACD;;AAED,QAAI,CAACS,UAAL,EAAiB;AACfL,MAAAA,OAAO,GAAG,KAAV;AACD,KAFD,MAEO;AACLM,MAAAA,OAAO,GAAGvC,KAAK,CAACsC,UAAD,EAAa5B,UAAU,CAAC,GAAD,CAAvB,CAAf;;AAEA,WAAK+B,GAAL,IAAYF,OAAZ,EAAqB;AACnBC,QAAAA,MAAM,GAAGD,OAAO,CAACE,GAAD,CAAP,CAAaX,MAAb,EAAqBD,IAAI,CAACY,GAAD,CAAzB,EAAgCZ,IAAhC,EAAsCO,KAAtC,CAAT;;AAEA,YAAII,MAAM,KAAK,KAAf,EAAsB;AACpBP,UAAAA,OAAO,GAAG,KAAV,CADoB,CAGpB;;AACAI,UAAAA,WAAW,CAACI,GAAD,CAAX,GAAmBZ,IAAI,CAACY,GAAD,CAAvB;AACD,SALD,MAKO,IAAID,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAKG,SAAlC,EAA6C;AAClDN,UAAAA,WAAW,CAACI,GAAD,CAAX,GAAmBD,MAAnB;AACD;AACF;AACF;AACF;;AAED,MAAI,CAACP,OAAL,EAAc;AACZ,QACE,CAACI,WAAW,CAACzB,QAAb,IACAyB,WAAW,CAACzB,QAAZ,CAAqBuB,MAArB,KAAgC,CADhC,IAEAL,MAAM,CAACc,KAAP,CAAaC,OAAb,CAAqBR,WAAW,CAAClB,OAAjC,MAA8C,CAAC,CAHjD,EAIE;AACA,aAAO,IAAP;AACD;;AAED,WAAOkB,WAAW,CAACzB,QAAnB;AACD;;AAED,SAAOyB,WAAP;AACD,C,CAED;;;AACA,SAASxB,GAAT,CAAaiB,MAAb,EAAqBlB,QAArB,EAA+BiB,IAA/B,EAAqCO,KAArC,EAA4C;AAC1C,MAAIU,KAAK,GAAGlC,QAAQ,IAAI,EAAxB;AACA,MAAIuB,MAAM,GAAGW,KAAK,CAACX,MAAN,IAAgB,CAA7B;AACA,MAAIY,OAAO,GAAG,EAAd;AACA,MAAIC,KAAK,GAAG,CAAC,CAAb;AACA,MAAIR,MAAJ;AAEAJ,EAAAA,KAAK,GAAGA,KAAK,CAACa,MAAN,CAAapB,IAAI,CAACV,OAAlB,CAAR;;AAEA,SAAO,EAAE6B,KAAF,GAAUb,MAAjB,EAAyB;AACvBK,IAAAA,MAAM,GAAGN,GAAG,CAACJ,MAAD,EAASgB,KAAK,CAACE,KAAD,CAAd,EAAuBZ,KAAvB,CAAZ;;AAEA,QAAII,MAAJ,EAAY;AACV,UAAI,YAAYA,MAAhB,EAAwB;AACtBO,QAAAA,OAAO,GAAGA,OAAO,CAACE,MAAR,CAAeT,MAAf,CAAV;AACD,OAFD,MAEO;AACLO,QAAAA,OAAO,CAACG,IAAR,CAAaV,MAAb;AACD;AACF;AACF;;AAED,SAAOO,OAAP;AACD,C,CAED;;;AACA,SAASzB,gBAAT,CAA0BQ,MAA1B,EAAkCT,UAAlC,EAA8CQ,IAA9C,EAAoDO,KAApD,EAA2D;AACzD,MAAIe,IAAI,GAAG/B,aAAa,CAACU,MAAD,EAASD,IAAI,CAACV,OAAd,EAAuBU,IAAvB,EAA6BO,KAA7B,CAAxB;AACA,MAAIgB,KAAK,GAAGtB,MAAM,CAACuB,UAAnB;AACA,MAAIC,IAAI,GAAGxB,MAAM,CAACyB,QAAP;AAAmB;AAA2B,IAAzD;AACA,MAAIC,KAAK,GAAGnC,UAAU,IAAI,EAA1B;AACA,MAAImB,MAAM,GAAG,EAAb;AACA,MAAID,OAAJ;AACA,MAAIgB,QAAJ;AACA,MAAIjB,UAAJ;AACA,MAAImB,IAAJ;AACA,MAAIjC,KAAJ;AAEAe,EAAAA,OAAO,GAAGvC,KAAK,CACb0D,kBAAkB,CAACN,KAAK,CAAC,GAAD,CAAN,CADL,EAEbM,kBAAkB,CAACpD,GAAG,CAACoC,IAAJ,CAASU,KAAT,EAAgBD,IAAhB,IAAwBC,KAAK,CAACD,IAAD,CAA7B,GAAsC,EAAvC,CAFL,CAAf;;AAKA,OAAKM,IAAL,IAAaD,KAAb,EAAoB;AAClBhC,IAAAA,KAAK,GAAGgC,KAAK,CAACC,IAAD,CAAb;;AAEA,QAAInD,GAAG,CAACoC,IAAJ,CAASH,OAAT,EAAkBkB,IAAlB,CAAJ,EAA6B;AAC3BnB,MAAAA,UAAU,GAAGC,OAAO,CAACkB,IAAD,CAApB;AACD,KAFD,MAEO,IAAI/B,IAAI,CAAC+B,IAAD,CAAJ,IAAcnD,GAAG,CAACoC,IAAJ,CAASH,OAAT,EAAkB/B,OAAlB,CAAlB,EAA8C;AACnD8B,MAAAA,UAAU,GAAGC,OAAO,CAAC/B,OAAD,CAApB;AACD,KAFM,MAEA;AACL;AACD;;AAED,QAAIgB,KAAK,IAAI,OAAOA,KAAP,KAAiB,QAA1B,IAAsC,YAAYA,KAAtD,EAA6D;AAC3DA,MAAAA,KAAK,GAAGmC,oBAAoB,CAAC7B,MAAD,EAASN,KAAT,EAAgBiC,IAAhB,EAAsBnB,UAAtB,CAA5B;AACD,KAFD,MAEO;AACLd,MAAAA,KAAK,GAAGoC,mBAAmB,CAAC9B,MAAD,EAASN,KAAT,EAAgBiC,IAAhB,EAAsBnB,UAAtB,CAA3B;AACD;;AAED,QAAId,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKmB,SAAhC,EAA2C;AACzCH,MAAAA,MAAM,CAACiB,IAAD,CAAN,GAAejC,KAAf;AACD;AACF;;AAED+B,EAAAA,QAAQ,GAAGjD,GAAG,CAACoC,IAAJ,CAASY,IAAT,EAAeH,IAAf,IAAuBG,IAAI,CAACH,IAAD,CAA3B,GAAoC,EAA/C;;AAEA,OAAKM,IAAL,IAAaF,QAAb,EAAuB;AACrB,QAAI,CAACjD,GAAG,CAACoC,IAAJ,CAASF,MAAT,EAAiBiB,IAAjB,CAAL,EAA6B;AAC3BjB,MAAAA,MAAM,CAACiB,IAAD,CAAN,GAAeF,QAAQ,CAACE,IAAD,CAAvB;AACD;AACF;;AAED,SAAOjB,MAAP;AACD,C,CAED;;;AACA,SAASmB,oBAAT,CAA8B7B,MAA9B,EAAsC+B,MAAtC,EAA8CJ,IAA9C,EAAoDnB,UAApD,EAAgE;AAC9D,MAAIH,MAAM,GAAG0B,MAAM,CAAC1B,MAApB;AACA,MAAIK,MAAM,GAAG,EAAb;AACA,MAAIQ,KAAK,GAAG,CAAC,CAAb;AACA,MAAIxB,KAAJ;;AAEA,SAAO,EAAEwB,KAAF,GAAUb,MAAjB,EAAyB;AACvBX,IAAAA,KAAK,GAAGoC,mBAAmB,CAAC9B,MAAD,EAAS+B,MAAM,CAACb,KAAD,CAAf,EAAwBS,IAAxB,EAA8BnB,UAA9B,CAA3B;;AAEA,QAAId,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKmB,SAAhC,EAA2C;AACzCH,MAAAA,MAAM,CAACU,IAAP,CAAY1B,KAAZ;AACD;AACF;;AAED,SAAOgB,MAAP;AACD,C,CAED;;;AACA,SAASoB,mBAAT,CAA6B9B,MAA7B,EAAqCN,KAArC,EAA4CiC,IAA5C,EAAkDnB,UAAlD,EAA8D;AAC5D,MACE,OAAOd,KAAP,KAAiB,SAAjB,IACA,OAAOA,KAAP,KAAiB,QADjB,IAEA,OAAOA,KAAP,KAAiB,QAHnB,EAIE;AACA,WAAO,IAAP;AACD;;AAED,MAAI,CAACsC,cAAc,CAAChC,MAAD,EAASN,KAAT,EAAgBiC,IAAhB,CAAnB,EAA0C;AACxC,WAAO,IAAP;AACD;;AAED,MAAInB,UAAU,CAACH,MAAX,KAAsB,CAAtB,IAA2BG,UAAU,CAACO,OAAX,CAAmBrB,KAAnB,MAA8B,CAAC,CAA9D,EAAiE;AAC/D,WAAO,IAAP;AACD;;AAED,MAAIM,MAAM,CAACiC,OAAP,CAAelB,OAAf,CAAuBY,IAAvB,MAAiC,CAAC,CAAtC,EAAyC;AACvCjC,IAAAA,KAAK,GAAGM,MAAM,CAACkC,aAAP,GAAuBxC,KAA/B;AACD;;AAED,SAAOA,KAAP;AACD,C,CAED;;;AACA,SAASsC,cAAT,CAAwBhC,MAAxB,EAAgCN,KAAhC,EAAuCiC,IAAvC,EAA6C;AAC3C,MAAIQ,SAAS,GAAGnC,MAAM,CAACmC,SAAvB;AACA,MAAIC,QAAJ;AACA,MAAIC,KAAJ;AACA,MAAIC,KAAJ;AACA,MAAIjC,MAAJ;AACA,MAAIa,KAAJ;AAEAiB,EAAAA,SAAS,GAAG3D,GAAG,CAACoC,IAAJ,CAASuB,SAAT,EAAoBR,IAApB,IAA4BQ,SAAS,CAACR,IAAD,CAAT,CAAgBR,MAAhB,EAA5B,GAAuD,EAAnE;;AAEA,MAAIgB,SAAS,CAAC9B,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,WAAO,IAAP;AACD;;AAEDX,EAAAA,KAAK,GAAG6C,MAAM,CAAC7C,KAAD,CAAd;AACA2C,EAAAA,KAAK,GAAG3C,KAAK,CAAC8C,MAAN,CAAa,CAAb,CAAR;;AAEA,MAAIH,KAAK,KAAK,GAAV,IAAiBA,KAAK,KAAK,GAA/B,EAAoC;AAClC,WAAO,IAAP;AACD;;AAEDC,EAAAA,KAAK,GAAG5C,KAAK,CAACqB,OAAN,CAAc,GAAd,CAAR;;AAEA,MAAIuB,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChB,WAAO,IAAP;AACD;;AAEDjC,EAAAA,MAAM,GAAG8B,SAAS,CAAC9B,MAAnB;AACAa,EAAAA,KAAK,GAAG,CAAC,CAAT;;AAEA,SAAO,EAAEA,KAAF,GAAUb,MAAjB,EAAyB;AACvB+B,IAAAA,QAAQ,GAAGD,SAAS,CAACjB,KAAD,CAApB;;AAEA,QACEoB,KAAK,KAAKF,QAAQ,CAAC/B,MAAnB,IACAX,KAAK,CAAC+C,KAAN,CAAY,CAAZ,EAAeL,QAAQ,CAAC/B,MAAxB,MAAoC+B,QAFtC,EAGE;AACA,aAAO,IAAP;AACD;AACF;;AAEDlB,EAAAA,KAAK,GAAGxB,KAAK,CAACqB,OAAN,CAAc,GAAd,CAAR;;AAEA,MAAIG,KAAK,KAAK,CAAC,CAAX,IAAgBoB,KAAK,GAAGpB,KAA5B,EAAmC;AACjC,WAAO,IAAP;AACD;;AAEDA,EAAAA,KAAK,GAAGxB,KAAK,CAACqB,OAAN,CAAc,GAAd,CAAR;;AAEA,MAAIG,KAAK,KAAK,CAAC,CAAX,IAAgBoB,KAAK,GAAGpB,KAA5B,EAAmC;AACjC,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD,C,CAED;;;AACA,SAASwB,iBAAT,GAA6B;AAC3B,SAAO,MAAP;AACD,C,CAED;;;AACA,SAASpD,aAAT,CAAuBU,MAAvB,EAA+BX,OAA/B,EAAwCU,IAAxC,EAA8CO,KAA9C,EAAqD;AACnD,MAAIe,IAAI,GAAG,OAAOhC,OAAP,KAAmB,QAAnB,GAA8BA,OAA9B,GAAwC,IAAnD;AACA,MAAIsD,SAAS,GAAG3C,MAAM,CAAC2C,SAAvB;AACA,MAAItC,MAAJ;AACA,MAAIa,KAAJ;;AAEA,MAAI,CAACG,IAAD,IAASA,IAAI,KAAK,GAAlB,IAAyBrB,MAAM,CAAC4C,QAAP,CAAgB7B,OAAhB,CAAwBM,IAAxB,MAAkC,CAAC,CAAhE,EAAmE;AACjE,WAAO,KAAP;AACD;;AAEDsB,EAAAA,SAAS,GAAGnE,GAAG,CAACoC,IAAJ,CAAS+B,SAAT,EAAoBtB,IAApB,IAA4BsB,SAAS,CAACtB,IAAD,CAArC,GAA8C,EAA1D,CAVmD,CAYnD;AACA;;AACA,MAAIsB,SAAS,CAACtC,MAAV,KAAqB,CAAzB,EAA4B;AAC1BA,IAAAA,MAAM,GAAGsC,SAAS,CAACtC,MAAV,GAAmB,CAA5B;AACAa,IAAAA,KAAK,GAAG,CAAC,CAAT;;AAEA,WAAO,EAAEA,KAAF,GAAUb,MAAjB,EAAyB;AACvB,UAAI,CAACsC,SAAS,CAACzB,KAAD,CAAd,EAAuB;AACrB,eAAO,KAAP;AACD;;AAED,UAAIZ,KAAK,CAACS,OAAN,CAAc4B,SAAS,CAACzB,KAAD,CAAvB,MAAoC,CAAC,CAAzC,EAA4C;AAC1C;AACD;AACF;AACF;;AAED,SAAOG,IAAP;AACD;;AAED,SAASpC,aAAT,CAAuBe,MAAvB,EAA+B;AAC7B,SAAOA,MAAM,CAAC6C,aAAP,GAAuB;AAACxB,IAAAA,IAAI,EAAEqB;AAAP,GAAvB,GAAmD,IAA1D;AACD;;AAED,SAASvD,aAAT,CAAuBa,MAAvB,EAA+B;AAC7B,SAAOA,MAAM,CAAC8C,aAAP,GAAuB;AAACpD,IAAAA,KAAK,EAAEqD;AAAR,GAAvB,GAAqD,IAA5D;AACD,C,CAED;;;AACA,SAASA,kBAAT,CAA4B/C,MAA5B,EAAoCN,KAApC,EAA2C;AACzC,MAAIgB,MAAM,GAAG,OAAOhB,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoC,EAAjD;AACA,MAAIwB,KAAK,GAAGR,MAAM,CAACK,OAAP,CAAepC,UAAf,CAAZ;AAEA,SAAOuC,KAAK,KAAK,CAAC,CAAX,GAAeR,MAAf,GAAwBA,MAAM,CAAC+B,KAAP,CAAa,CAAb,EAAgBvB,KAAhB,CAA/B;AACD,C,CAED;;;AACA,SAASvB,WAAT,CAAqBK,MAArB,EAA6BN,KAA7B,EAAoC;AAClC,SAAO,OAAOA,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoC,EAA3C;AACD,C,CAED;;;AACA,SAASkC,kBAAT,CAA4BG,MAA5B,EAAoC;AAClC,MAAIrB,MAAM,GAAG,EAAb;AACA,MAAIL,MAAM,GAAG0B,MAAM,CAAC1B,MAApB;AACA,MAAIa,KAAK,GAAG,CAAC,CAAb;AACA,MAAIxB,KAAJ;;AAEA,SAAO,EAAEwB,KAAF,GAAUb,MAAjB,EAAyB;AACvBX,IAAAA,KAAK,GAAGqC,MAAM,CAACb,KAAD,CAAd;;AAEA,QAAIxB,KAAK,IAAI,OAAOA,KAAP,KAAiB,QAA1B,IAAsC,YAAYA,KAAtD,EAA6D;AAC3DgB,MAAAA,MAAM,CAAChB,KAAK,CAAC,CAAD,CAAN,CAAN,GAAmBA,KAAK,CAAC+C,KAAN,CAAY,CAAZ,CAAnB;AACD,KAFD,MAEO;AACL/B,MAAAA,MAAM,CAAChB,KAAD,CAAN,GAAgB,EAAhB;AACD;AACF;;AAED,SAAOgB,MAAP;AACD,C,CAED;;;AACA,SAASb,KAAT,CAAeG,MAAf,EAAuBN,KAAvB,EAA8B;AAC5B,SAAOA,KAAP;AACD,C,CAED;;;AACA,SAASE,IAAT,CAAc+B,IAAd,EAAoB;AAClB,SAAOA,IAAI,CAACtB,MAAL,GAAc,CAAd,IAAmBsB,IAAI,CAACc,KAAL,CAAW,CAAX,EAAc,CAAd,EAAiBO,WAAjB,OAAmC,MAA7D;AACD","sourcesContent":["'use strict'\n\nvar xtend = require('xtend')\nvar defaults = require('./github.json')\n\nmodule.exports = wrapper\n\nvar own = {}.hasOwnProperty\n\nvar allData = 'data*'\nvar commentEnd = '-->'\n\nvar nodeSchema = {\n  root: {children: all},\n  doctype: handleDoctype,\n  comment: handleComment,\n  element: {\n    tagName: handleTagName,\n    properties: handleProperties,\n    children: all\n  },\n  text: {value: handleValue},\n  '*': {\n    data: allow,\n    position: allow\n  }\n}\n\n// Sanitize `node`, according to `schema`.\nfunction wrapper(node, schema) {\n  var ctx = {type: 'root', children: []}\n  var replace\n\n  if (!node || typeof node !== 'object' || !node.type) {\n    return ctx\n  }\n\n  replace = one(xtend(defaults, schema || {}), node, [])\n\n  if (!replace) {\n    return ctx\n  }\n\n  if ('length' in replace) {\n    if (replace.length === 1) {\n      return replace[0]\n    }\n\n    ctx.children = replace\n\n    return ctx\n  }\n\n  return replace\n}\n\n// Sanitize `node`.\nfunction one(schema, node, stack) {\n  var type = node && node.type\n  var replacement = {type: node.type}\n  var replace = true\n  var definition\n  var allowed\n  var result\n  var key\n\n  if (!own.call(nodeSchema, type)) {\n    replace = false\n  } else {\n    definition = nodeSchema[type]\n\n    if (typeof definition === 'function') {\n      definition = definition(schema, node)\n    }\n\n    if (!definition) {\n      replace = false\n    } else {\n      allowed = xtend(definition, nodeSchema['*'])\n\n      for (key in allowed) {\n        result = allowed[key](schema, node[key], node, stack)\n\n        if (result === false) {\n          replace = false\n\n          // Set the non-safe value.\n          replacement[key] = node[key]\n        } else if (result !== null && result !== undefined) {\n          replacement[key] = result\n        }\n      }\n    }\n  }\n\n  if (!replace) {\n    if (\n      !replacement.children ||\n      replacement.children.length === 0 ||\n      schema.strip.indexOf(replacement.tagName) !== -1\n    ) {\n      return null\n    }\n\n    return replacement.children\n  }\n\n  return replacement\n}\n\n// Sanitize `children`.\nfunction all(schema, children, node, stack) {\n  var nodes = children || []\n  var length = nodes.length || 0\n  var results = []\n  var index = -1\n  var result\n\n  stack = stack.concat(node.tagName)\n\n  while (++index < length) {\n    result = one(schema, nodes[index], stack)\n\n    if (result) {\n      if ('length' in result) {\n        results = results.concat(result)\n      } else {\n        results.push(result)\n      }\n    }\n  }\n\n  return results\n}\n\n// Sanitize `properties`.\nfunction handleProperties(schema, properties, node, stack) {\n  var name = handleTagName(schema, node.tagName, node, stack)\n  var attrs = schema.attributes\n  var reqs = schema.required || /* istanbul ignore next */ {}\n  var props = properties || {}\n  var result = {}\n  var allowed\n  var required\n  var definition\n  var prop\n  var value\n\n  allowed = xtend(\n    toPropertyValueMap(attrs['*']),\n    toPropertyValueMap(own.call(attrs, name) ? attrs[name] : [])\n  )\n\n  for (prop in props) {\n    value = props[prop]\n\n    if (own.call(allowed, prop)) {\n      definition = allowed[prop]\n    } else if (data(prop) && own.call(allowed, allData)) {\n      definition = allowed[allData]\n    } else {\n      continue\n    }\n\n    if (value && typeof value === 'object' && 'length' in value) {\n      value = handlePropertyValues(schema, value, prop, definition)\n    } else {\n      value = handlePropertyValue(schema, value, prop, definition)\n    }\n\n    if (value !== null && value !== undefined) {\n      result[prop] = value\n    }\n  }\n\n  required = own.call(reqs, name) ? reqs[name] : {}\n\n  for (prop in required) {\n    if (!own.call(result, prop)) {\n      result[prop] = required[prop]\n    }\n  }\n\n  return result\n}\n\n// Sanitize a property value which is a list.\nfunction handlePropertyValues(schema, values, prop, definition) {\n  var length = values.length\n  var result = []\n  var index = -1\n  var value\n\n  while (++index < length) {\n    value = handlePropertyValue(schema, values[index], prop, definition)\n\n    if (value !== null && value !== undefined) {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n// Sanitize a property value.\nfunction handlePropertyValue(schema, value, prop, definition) {\n  if (\n    typeof value !== 'boolean' &&\n    typeof value !== 'number' &&\n    typeof value !== 'string'\n  ) {\n    return null\n  }\n\n  if (!handleProtocol(schema, value, prop)) {\n    return null\n  }\n\n  if (definition.length !== 0 && definition.indexOf(value) === -1) {\n    return null\n  }\n\n  if (schema.clobber.indexOf(prop) !== -1) {\n    value = schema.clobberPrefix + value\n  }\n\n  return value\n}\n\n// Check whether `value` is a safe URL.\nfunction handleProtocol(schema, value, prop) {\n  var protocols = schema.protocols\n  var protocol\n  var first\n  var colon\n  var length\n  var index\n\n  protocols = own.call(protocols, prop) ? protocols[prop].concat() : []\n\n  if (protocols.length === 0) {\n    return true\n  }\n\n  value = String(value)\n  first = value.charAt(0)\n\n  if (first === '#' || first === '/') {\n    return true\n  }\n\n  colon = value.indexOf(':')\n\n  if (colon === -1) {\n    return true\n  }\n\n  length = protocols.length\n  index = -1\n\n  while (++index < length) {\n    protocol = protocols[index]\n\n    if (\n      colon === protocol.length &&\n      value.slice(0, protocol.length) === protocol\n    ) {\n      return true\n    }\n  }\n\n  index = value.indexOf('?')\n\n  if (index !== -1 && colon > index) {\n    return true\n  }\n\n  index = value.indexOf('#')\n\n  if (index !== -1 && colon > index) {\n    return true\n  }\n\n  return false\n}\n\n// Always return a valid HTML5 doctype.\nfunction handleDoctypeName() {\n  return 'html'\n}\n\n// Sanitize `tagName`.\nfunction handleTagName(schema, tagName, node, stack) {\n  var name = typeof tagName === 'string' ? tagName : null\n  var ancestors = schema.ancestors\n  var length\n  var index\n\n  if (!name || name === '*' || schema.tagNames.indexOf(name) === -1) {\n    return false\n  }\n\n  ancestors = own.call(ancestors, name) ? ancestors[name] : []\n\n  // Some nodes can break out of their context if they donâ€™t have a certain\n  // ancestor.\n  if (ancestors.length !== 0) {\n    length = ancestors.length + 1\n    index = -1\n\n    while (++index < length) {\n      if (!ancestors[index]) {\n        return false\n      }\n\n      if (stack.indexOf(ancestors[index]) !== -1) {\n        break\n      }\n    }\n  }\n\n  return name\n}\n\nfunction handleDoctype(schema) {\n  return schema.allowDoctypes ? {name: handleDoctypeName} : null\n}\n\nfunction handleComment(schema) {\n  return schema.allowComments ? {value: handleCommentValue} : null\n}\n\n// See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\nfunction handleCommentValue(schema, value) {\n  var result = typeof value === 'string' ? value : ''\n  var index = result.indexOf(commentEnd)\n\n  return index === -1 ? result : result.slice(0, index)\n}\n\n// Sanitize `value`.\nfunction handleValue(schema, value) {\n  return typeof value === 'string' ? value : ''\n}\n\n// Create a map from a list of props or a list of properties and values.\nfunction toPropertyValueMap(values) {\n  var result = {}\n  var length = values.length\n  var index = -1\n  var value\n\n  while (++index < length) {\n    value = values[index]\n\n    if (value && typeof value === 'object' && 'length' in value) {\n      result[value[0]] = value.slice(1)\n    } else {\n      result[value] = []\n    }\n  }\n\n  return result\n}\n\n// Allow `value`.\nfunction allow(schema, value) {\n  return value\n}\n\n// Check if `prop` is a data property.\nfunction data(prop) {\n  return prop.length > 4 && prop.slice(0, 4).toLowerCase() === 'data'\n}\n"]},"metadata":{},"sourceType":"script"}