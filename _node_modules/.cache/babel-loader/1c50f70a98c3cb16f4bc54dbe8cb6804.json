{"ast":null,"code":"import store from \"./../../../../../store\";\nimport { setAvailableEffects } from \"./../../../../../actions\";\nimport { equalPower } from \"./../../../../../utils/sound/converter\"; //import { throttel } from \"./../../../../../utils/functions/lodash\";\n\nimport Reverb from \"./effects/reverb/reverb\";\nimport Delay from \"./effects/delay/delay\";\nimport Flanger from \"./effects/flanger/flanger\";\nimport DubDelay from \"./effects/dubDelay/dubDelay\";\nimport PingPongDelay from \"./effects/PingPongDelay/PingPongDelay\";\nexport default class Effector {\n  constructor(audioContext) {\n    this.config = store.getState().configuration.effector;\n    this.mainAC = audioContext;\n    this.buildChannels(this.config.channels);\n    this.effects = {\n      \"Reverb\": {\n        create: Reverb,\n        params: Reverb.defaultParams().params\n      },\n      \"Flanger\": {\n        create: Flanger,\n        params: Flanger.defaultParams().params\n      },\n      \"Delay\": {\n        create: Delay,\n        params: Delay.defaultParams().params\n      },\n      \"Dub Delay\": {\n        create: DubDelay,\n        params: DubDelay.defaultParams().params\n      },\n      \"Ping Pong Delay\": {\n        create: PingPongDelay,\n        params: PingPongDelay.defaultParams().params\n      }\n    };\n    const exportEffects = {};\n    Object.entries(this.effects).forEach(([key, element]) => exportEffects[key] = element.params);\n    store.dispatch(setAvailableEffects(exportEffects));\n  }\n\n  buildChannels(channelNumber) {\n    this.channels = Array.from({\n      length: channelNumber\n    }, (_, index) => ({\n      channelNumber: index\n    }));\n\n    for (let chNum = 0; chNum < channelNumber; chNum++) {\n      const channel = this.channels[chNum];\n      channel.inputNode = this.mainAC.createGain();\n      channel.dryNode = this.mainAC.createGain();\n      ;\n      channel.wetNode = this.mainAC.createGain();\n      channel.outputNode = this.mainAC.createGain();\n      channel.compressorNode = this.mainAC.createDynamicsCompressor();\n      this.configCompressor(channel.compressorNode);\n      channel.inputNode.connect(channel.dryNode);\n      channel.dryNode.connect(channel.compressorNode);\n      channel.wetNode.connect(channel.compressorNode);\n      channel.compressorNode.connect(channel.outputNode);\n      channel.wetNode.gain.value = 0;\n    }\n  }\n\n  configCompressor(compressorNode) {\n    compressorNode.threshold.setValueAtTime(-50, this.mainAC.currentTime);\n    compressorNode.knee.setValueAtTime(40, this.mainAC.currentTime);\n    compressorNode.ratio.setValueAtTime(12, this.mainAC.currentTime);\n    compressorNode.attack.setValueAtTime(0, this.mainAC.currentTime);\n    compressorNode.release.setValueAtTime(0.25, this.mainAC.currentTime);\n  }\n\n  connect(inputs) {\n    const outputs = [];\n    inputs.forEach((inputNode, chNum) => {\n      inputNode.connect(this.channels[chNum].inputNode);\n      const output = this.mainAC.createGain();\n      this.channels[chNum].outputNode.connect(output);\n      outputs.push(output);\n    });\n    return outputs;\n  }\n\n  setDryWet(channelNumber, value) {\n    channelNumber--;\n    const channel = this.channels[channelNumber]; //const {a: dry, b: wet} = equalPower(value / 100);\n\n    let dry = (100 - value) / 100;\n    let wet = value / 100;\n    channel.dryNode.gain.setTargetAtTime(dry, this.mainAC.currentTime, 0.01);\n    channel.wetNode.gain.setTargetAtTime(wet, this.mainAC.currentTime, 0.01);\n  }\n\n  setEffect(channelNumber, effectName) {\n    channelNumber--; //array index\n\n    const channel = this.channels[channelNumber];\n\n    if (effectName) {\n      this.disconectCurrent(channel);\n      let params = this.assingDefaultParams({}, effectName);\n      const effectorChannel = store.getState().effector.channels;\n\n      if (effectorChannel && effectorChannel[channelNumber]) {\n        params = { ...effectorChannel[channelNumber].effects[effectName]\n        };\n      }\n\n      const effect = new this.effects[effectName].create(this.mainAC, params);\n      channel.currentEffect = effect;\n      effect.connect(channel.inputNode, channel.wetNode);\n    } else {\n      this.disconectCurrent(channel);\n    }\n  }\n\n  assingDefaultParams(obj, effect) {\n    Object.entries(this.effects[effect].params).forEach(([key, value]) => {\n      obj[key] = value.defaultValue;\n    });\n    return obj;\n  }\n\n  setParam(channelNumber, effect, param) {\n    channelNumber--;\n    const channel = this.channels[channelNumber];\n\n    if (channel.currentEffect && channel.currentEffect.name === effect) {\n      Object.entries(param).forEach(([key, value]) => {\n        channel.currentEffect[key] = value;\n      });\n    }\n  }\n\n  disconectCurrent(channel) {\n    if (channel.currentEffect) {\n      channel.inputNode.disconnect();\n      channel.inputNode.connect(channel.dryNode);\n      channel.currentEffect.disconnect();\n      channel.currentEffect = null;\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/src/pages/app/core/console/effector/effector.js"],"names":["store","setAvailableEffects","equalPower","Reverb","Delay","Flanger","DubDelay","PingPongDelay","Effector","constructor","audioContext","config","getState","configuration","effector","mainAC","buildChannels","channels","effects","create","params","defaultParams","exportEffects","Object","entries","forEach","key","element","dispatch","channelNumber","Array","from","length","_","index","chNum","channel","inputNode","createGain","dryNode","wetNode","outputNode","compressorNode","createDynamicsCompressor","configCompressor","connect","gain","value","threshold","setValueAtTime","currentTime","knee","ratio","attack","release","inputs","outputs","output","push","setDryWet","dry","wet","setTargetAtTime","setEffect","effectName","disconectCurrent","assingDefaultParams","effectorChannel","effect","currentEffect","obj","defaultValue","setParam","param","name","disconnect"],"mappings":"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","sourcesContent":["\r\nimport store from \"./../../../../../store\";\r\nimport { setAvailableEffects } from \"./../../../../../actions\";\r\nimport { equalPower } from \"./../../../../../utils/sound/converter\"\r\n//import { throttel } from \"./../../../../../utils/functions/lodash\";\r\nimport Reverb from \"./effects/reverb/reverb\";\r\nimport Delay from \"./effects/delay/delay\";\r\nimport Flanger from \"./effects/flanger/flanger\";\r\nimport DubDelay from \"./effects/dubDelay/dubDelay\";\r\nimport PingPongDelay from \"./effects/PingPongDelay/PingPongDelay\";\r\n\r\n\r\n\r\nexport default class Effector {\r\n    constructor(audioContext) {\r\n        this.config = store.getState().configuration.effector;\r\n        this.mainAC = audioContext;\r\n\r\n        this.buildChannels(this.config.channels);\r\n\r\n\r\n        this.effects = {\r\n            \"Reverb\": {\r\n                create: Reverb,\r\n                params: Reverb.defaultParams().params,\r\n            },\r\n            \"Flanger\": {\r\n                create: Flanger,\r\n                params: Flanger.defaultParams().params\r\n            },\r\n            \"Delay\": {\r\n                create: Delay,\r\n                params: Delay.defaultParams().params\r\n            },\r\n            \"Dub Delay\": {\r\n                create: DubDelay,\r\n                params: DubDelay.defaultParams().params,\r\n            },\r\n            \"Ping Pong Delay\": {\r\n                create: PingPongDelay,\r\n                params: PingPongDelay.defaultParams().params,\r\n            }\r\n\r\n\r\n        }\r\n\r\n        const exportEffects = {};\r\n        Object.entries(this.effects).forEach(([key, element]) =>\r\n            exportEffects[key] = element.params\r\n        );\r\n        store.dispatch(setAvailableEffects(exportEffects));\r\n    }\r\n\r\n    buildChannels(channelNumber) {\r\n        this.channels =\r\n            Array.from({ length: channelNumber }, (_, index) => ({ channelNumber: index }));\r\n\r\n        for (let chNum = 0; chNum < channelNumber; chNum++) {\r\n            const channel = this.channels[chNum];\r\n\r\n            channel.inputNode = this.mainAC.createGain();\r\n            channel.dryNode = this.mainAC.createGain();;\r\n            channel.wetNode = this.mainAC.createGain();\r\n            channel.outputNode = this.mainAC.createGain();\r\n            channel.compressorNode = this.mainAC.createDynamicsCompressor();\r\n            this.configCompressor(channel.compressorNode);\r\n\r\n            channel.inputNode.connect(channel.dryNode);\r\n\r\n\r\n            channel.dryNode.connect(channel.compressorNode);\r\n            channel.wetNode.connect(channel.compressorNode);\r\n\r\n            channel.compressorNode.connect(channel.outputNode);\r\n\r\n            channel.wetNode.gain.value = 0;\r\n        }\r\n    }\r\n\r\n    configCompressor(compressorNode){\r\n        compressorNode.threshold.setValueAtTime(-50, this.mainAC.currentTime);\r\n        compressorNode.knee.setValueAtTime(40, this.mainAC.currentTime);\r\n        compressorNode.ratio.setValueAtTime(12, this.mainAC.currentTime);\r\n        compressorNode.attack.setValueAtTime(0, this.mainAC.currentTime);\r\n        compressorNode.release.setValueAtTime(0.25, this.mainAC.currentTime);\r\n    }\r\n\r\n\r\n    connect(inputs) {\r\n        const outputs = [];\r\n\r\n        inputs.forEach((inputNode, chNum) => {\r\n            inputNode.connect(this.channels[chNum].inputNode);\r\n\r\n            const output = this.mainAC.createGain();\r\n            this.channels[chNum].outputNode.connect(output);\r\n            outputs.push(output)\r\n        });\r\n\r\n        return outputs;\r\n    }\r\n\r\n\r\n    setDryWet(channelNumber, value) {\r\n        channelNumber--;\r\n        const channel = this.channels[channelNumber];\r\n\r\n        //const {a: dry, b: wet} = equalPower(value / 100);\r\n        let dry = (100 - value) / 100;\r\n        let wet = value / 100;\r\n\r\n\r\n        channel.dryNode.gain.setTargetAtTime(dry, this.mainAC.currentTime, 0.01);\r\n        channel.wetNode.gain.setTargetAtTime(wet, this.mainAC.currentTime, 0.01);\r\n    }\r\n\r\n    setEffect(channelNumber, effectName) {\r\n        channelNumber--;//array index\r\n        const channel = this.channels[channelNumber];\r\n\r\n        if (effectName) {\r\n            this.disconectCurrent(channel);\r\n\r\n            let params = this.assingDefaultParams({}, effectName);\r\n            const effectorChannel = store.getState().effector.channels;\r\n            if (effectorChannel && effectorChannel[channelNumber]) {\r\n                params = { ...effectorChannel[channelNumber].effects[effectName] }\r\n            }\r\n\r\n            const effect = new this.effects[effectName].create(this.mainAC, params);\r\n            channel.currentEffect = effect;\r\n\r\n            effect.connect(channel.inputNode, channel.wetNode)\r\n\r\n        } else {\r\n            this.disconectCurrent(channel);\r\n        }\r\n\r\n    }\r\n\r\n    assingDefaultParams(obj, effect) {\r\n        Object.entries(this.effects[effect].params).forEach(([key, value]) => {\r\n            obj[key] = value.defaultValue;\r\n        })\r\n        return obj;\r\n    }\r\n\r\n    setParam(channelNumber, effect, param) {\r\n        channelNumber--;\r\n        const channel = this.channels[channelNumber];\r\n\r\n        if (channel.currentEffect && channel.currentEffect.name === effect) {\r\n            Object.entries(param).forEach(([key, value]) => {\r\n                channel.currentEffect[key] = value;\r\n            })\r\n        }\r\n    }\r\n\r\n\r\n    disconectCurrent(channel) {\r\n        if (channel.currentEffect) {\r\n            channel.inputNode.disconnect();\r\n            channel.inputNode.connect(channel.dryNode);\r\n            channel.currentEffect.disconnect();\r\n            channel.currentEffect = null;\r\n        }\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}