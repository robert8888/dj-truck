{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.fastUniqueNumbers = {}));\n})(this, function (exports) {\n  'use strict';\n\n  var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {\n    return function (set) {\n      var number = generateUniqueNumber(set);\n      set.add(number);\n      return number;\n    };\n  };\n\n  var createCache = function createCache(lastNumberWeakMap) {\n    return function (collection, nextNumber) {\n      lastNumberWeakMap.set(collection, nextNumber);\n      return nextNumber;\n    };\n  };\n  /*\n   * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n   * is fairly new.\n   */\n\n\n  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\n\n  var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {\n    return function (collection) {\n      var lastNumber = lastNumberWeakMap.get(collection);\n      /*\n       * Let's try the cheapest algorithm first. It might fail to produce a new\n       * number, but it is so cheap that it is okay to take the risk. Just\n       * increase the last number by one or reset it to 0 if we reached the upper\n       * bound of SMIs (which stands for small integers). When the last number is\n       * unknown it is assumed that the collection contains zero based consecutive\n       * numbers.\n       */\n\n      var nextNumber = lastNumber === undefined ? collection.size : lastNumber > 2147483646 ? 0 : lastNumber + 1;\n\n      if (!collection.has(nextNumber)) {\n        return cache(collection, nextNumber);\n      }\n      /*\n       * If there are less than half of 2 ** 31 numbers stored in the collection,\n       * the chance to generate a new random number in the range from 0 to 2 ** 31\n       * is at least 50%. It's benifitial to use only SMIs because they perform\n       * much better in any environment based on V8.\n       */\n\n\n      if (collection.size < 1073741824) {\n        while (collection.has(nextNumber)) {\n          nextNumber = Math.floor(Math.random() * 2147483648);\n        }\n\n        return cache(collection, nextNumber);\n      } // Quickly check if there is a theoretical chance to generate a new number.\n\n\n      if (collection.size > MAX_SAFE_INTEGER) {\n        throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n      } // Otherwise use the full scale of safely usable integers.\n\n\n      while (collection.has(nextNumber)) {\n        nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n      }\n\n      return cache(collection, nextNumber);\n    };\n  };\n\n  var LAST_NUMBER_WEAK_MAP = new WeakMap();\n  var cache = createCache(LAST_NUMBER_WEAK_MAP);\n  var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\n  var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\n  exports.addUniqueNumber = addUniqueNumber;\n  exports.generateUniqueNumber = generateUniqueNumber;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/node_modules/fast-unique-numbers/build/es5/bundle.js"],"names":["global","factory","exports","module","define","amd","self","fastUniqueNumbers","createAddUniqueNumber","generateUniqueNumber","set","number","add","createCache","lastNumberWeakMap","collection","nextNumber","MAX_SAFE_INTEGER","Number","undefined","createGenerateUniqueNumber","cache","lastNumber","get","size","has","Math","floor","random","Error","LAST_NUMBER_WEAK_MAP","WeakMap","addUniqueNumber","Object","defineProperty","value"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = global || self, factory(global.fastUniqueNumbers = {}));\n}(this, (function (exports) { 'use strict';\n\n    var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {\n      return function (set) {\n        var number = generateUniqueNumber(set);\n        set.add(number);\n        return number;\n      };\n    };\n\n    var createCache = function createCache(lastNumberWeakMap) {\n      return function (collection, nextNumber) {\n        lastNumberWeakMap.set(collection, nextNumber);\n        return nextNumber;\n      };\n    };\n\n    /*\n     * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n     * is fairly new.\n     */\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\n    var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {\n      return function (collection) {\n        var lastNumber = lastNumberWeakMap.get(collection);\n        /*\n         * Let's try the cheapest algorithm first. It might fail to produce a new\n         * number, but it is so cheap that it is okay to take the risk. Just\n         * increase the last number by one or reset it to 0 if we reached the upper\n         * bound of SMIs (which stands for small integers). When the last number is\n         * unknown it is assumed that the collection contains zero based consecutive\n         * numbers.\n         */\n\n        var nextNumber = lastNumber === undefined ? collection.size : lastNumber > 2147483646 ? 0 : lastNumber + 1;\n\n        if (!collection.has(nextNumber)) {\n          return cache(collection, nextNumber);\n        }\n        /*\n         * If there are less than half of 2 ** 31 numbers stored in the collection,\n         * the chance to generate a new random number in the range from 0 to 2 ** 31\n         * is at least 50%. It's benifitial to use only SMIs because they perform\n         * much better in any environment based on V8.\n         */\n\n\n        if (collection.size < 1073741824) {\n          while (collection.has(nextNumber)) {\n            nextNumber = Math.floor(Math.random() * 2147483648);\n          }\n\n          return cache(collection, nextNumber);\n        } // Quickly check if there is a theoretical chance to generate a new number.\n\n\n        if (collection.size > MAX_SAFE_INTEGER) {\n          throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n        } // Otherwise use the full scale of safely usable integers.\n\n\n        while (collection.has(nextNumber)) {\n          nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n        }\n\n        return cache(collection, nextNumber);\n      };\n    };\n\n    var LAST_NUMBER_WEAK_MAP = new WeakMap();\n    var cache = createCache(LAST_NUMBER_WEAK_MAP);\n    var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\n    var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\n\n    exports.addUniqueNumber = addUniqueNumber;\n    exports.generateUniqueNumber = generateUniqueNumber;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]},"metadata":{},"sourceType":"script"}