{"ast":null,"code":"import store from \"./../../../../store\";\nimport { getBeatLength } from \"./../../../../utils/bpm/converter\";\nimport { setChannelReady, setLoadingProgress, setTimeLeft, togglePlay } from \"./../../../../actions\";\nexport default class EventHandler {\n  constructor() {\n    this.startSync = channel => {\n      channel.syncHandle = setInterval(() => {\n        channel.slave.drawer.progress(channel.master.getCurrentTime() / channel.currentDuration);\n      }, 100);\n    };\n\n    this.dispatch = store.dispatch;\n  }\n\n  CreateEventHandling(channel) {\n    channel.master.on(\"load\", () => {\n      console.log(\"fire load\");\n      this.clearState(channel);\n    });\n    channel.master.on(\"loading\", progress => {\n      this.dispatch(setLoadingProgress(channel.channelName, progress));\n    });\n    channel.master.on(\"ready\", () => {\n      channel.currentDuration = channel.master.getDuration();\n      let resolution = 430;\n      channel.slave.load(null, channel.master.backend.getPeaks(resolution, 0, resolution));\n      this.dispatch(setLoadingProgress(channel.channelName, 100));\n      this.dispatch(setChannelReady(true, channel.channelName));\n      this.startSync(channel);\n    });\n    channel.slave.on(\"seek\", progress => {\n      const wasPlaying = channel.master.isPlaying();\n      channel.master.backend.seekTo(progress * channel.currentDuration);\n      channel.master.drawer.progress(progress);\n      channel.master.fireEvent(\"seek\", progress);\n      channel.slave.drawer.progress(progress);\n      const timeLeft = parseInt(channel.master.getDuration() - channel.master.getDuration() * progress);\n      this.dispatch(setTimeLeft(channel.channelName, timeLeft));\n\n      if (wasPlaying) {\n        channel.master.play();\n      }\n    });\n    channel.master.on('finish', () => {\n      this.dispatch(togglePlay(channel.channelName));\n    });\n    let lastUpdate = new Date().getTime();\n    channel.master.on('audioprocess', () => {\n      const currentTime = new Date().getTime();\n\n      if (currentTime - lastUpdate >= 500) {\n        lastUpdate = currentTime;\n        const timeLeft = parseInt(channel.master.getDuration() - channel.master.getCurrentTime());\n        setTimeLeft(channel.channelName, timeLeft);\n      }\n    }); // updating time Left value\n    ///Because on seek event is called a 1000 time per second, is created watcher witch update \n    // value after 500 ms with last progress value \n\n    let lastCall = {\n      time: new Date().getTime(),\n      value: null\n    };\n    let watcher = null;\n    channel.master.on('seek', progress => {\n      lastCall.time = new Date().getTime();\n      lastCall.value = progress;\n\n      if (!watcher) {\n        watcher = setTimeout(() => {\n          if (new Date().getTime() - lastCall.time >= 100) {\n            this.dispatch(setTimeLeft(channel.channelName, parseInt(channel.master.getDuration() * lastCall.value)));\n            clearTimeout(watcher);\n            watcher = null;\n          }\n        }, 500);\n      }\n    });\n  } // --- events below\n  //---helpers\n\n\n  clearState(channel) {\n    channel.slave.load(null, []);\n\n    if (channel.barsElements) {\n      channel.barsElements.forEach(htmlElement => htmlElement.remove());\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/src/core/console/channels/channelEvnetHandler/channelEvnetHandler.js"],"names":["store","getBeatLength","setChannelReady","setLoadingProgress","setTimeLeft","togglePlay","EventHandler","constructor","startSync","channel","syncHandle","setInterval","slave","drawer","progress","master","getCurrentTime","currentDuration","dispatch","CreateEventHandling","on","console","log","clearState","channelName","getDuration","resolution","load","backend","getPeaks","wasPlaying","isPlaying","seekTo","fireEvent","timeLeft","parseInt","play","lastUpdate","Date","getTime","currentTime","lastCall","time","value","watcher","setTimeout","clearTimeout","barsElements","forEach","htmlElement","remove"],"mappings":"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","sourcesContent":["import store from \"./../../../../store\";\r\n\r\nimport { getBeatLength } from \"./../../../../utils/bpm/converter\";\r\nimport {\r\n  setChannelReady,\r\n  setLoadingProgress,\r\n  setTimeLeft,\r\n  togglePlay\r\n} from \"./../../../../actions\";\r\n\r\nexport default class EventHandler {\r\n  constructor() {\r\n    this.dispatch = store.dispatch;\r\n  }\r\n\r\n  CreateEventHandling(channel) {\r\n    channel.master.on(\"load\", () => {\r\n      console.log(\"fire load\");\r\n      this.clearState(channel);\r\n    });\r\n\r\n    channel.master.on(\"loading\", progress => {\r\n      this.dispatch(setLoadingProgress(channel.channelName, progress));\r\n    });\r\n\r\n    channel.master.on(\"ready\", () => {\r\n      channel.currentDuration = channel.master.getDuration();\r\n      let resolution = 430;\r\n      channel.slave.load(\r\n        null,\r\n        channel.master.backend.getPeaks(resolution, 0, resolution)\r\n      );\r\n      this.dispatch(setLoadingProgress(channel.channelName, 100));\r\n\r\n      this.dispatch(setChannelReady(true, channel.channelName));\r\n      this.startSync(channel);\r\n    });\r\n\r\n    channel.slave.on(\"seek\", progress => {\r\n      const wasPlaying = channel.master.isPlaying();\r\n\r\n      channel.master.backend.seekTo(progress * channel.currentDuration);\r\n      channel.master.drawer.progress(progress);\r\n      channel.master.fireEvent(\"seek\", progress);\r\n\r\n      channel.slave.drawer.progress(progress);\r\n\r\n      const timeLeft = parseInt(\r\n        channel.master.getDuration() - (channel.master.getDuration() * progress)\r\n      );\r\n      this.dispatch(setTimeLeft(channel.channelName, timeLeft));\r\n      if (wasPlaying) {\r\n        channel.master.play();\r\n      }\r\n    });\r\n\r\n\r\n    channel.master.on('finish', ()=>{\r\n        this.dispatch(togglePlay(channel.channelName))\r\n    })\r\n\r\n    let lastUpdate = (new Date()).getTime();\r\n    channel.master.on('audioprocess', ()=>{\r\n        const currentTime = (new Date()).getTime();\r\n        if((currentTime - lastUpdate) >= 500){\r\n            lastUpdate = currentTime;\r\n            const timeLeft = parseInt(channel.master.getDuration() - channel.master.getCurrentTime())\r\n            setTimeLeft(channel.channelName, timeLeft);\r\n        }\r\n    })\r\n\r\n\r\n\r\n    // updating time Left value\r\n    ///Because on seek event is called a 1000 time per second, is created watcher witch update \r\n    // value after 500 ms with last progress value \r\n    let lastCall = {\r\n        time :(new Date()).getTime(),\r\n        value : null\r\n    };\r\n    let watcher = null;\r\n    channel.master.on('seek', progress => {\r\n        lastCall.time = (new Date()).getTime();\r\n        lastCall.value = progress;\r\n        if(!watcher){\r\n            watcher = setTimeout(()=>{\r\n                    if(((new Date()).getTime() - lastCall.time) >= 100)\r\n                    {\r\n                        this.dispatch(setTimeLeft(channel.channelName, parseInt(channel.master.getDuration() * lastCall.value)))\r\n                        clearTimeout(watcher);\r\n                        watcher = null\r\n                    }\r\n                }, 500)\r\n        }\r\n    })\r\n\r\n  }\r\n  // --- events below\r\n\r\n\r\n\r\n  //---helpers\r\n  clearState(channel) {\r\n    channel.slave.load(null, []);\r\n    if (channel.barsElements) {\r\n      channel.barsElements.forEach(htmlElement => htmlElement.remove());\r\n    }\r\n  }\r\n\r\n  startSync = channel => {\r\n    channel.syncHandle = setInterval(() => {\r\n      channel.slave.drawer.progress(\r\n        channel.master.getCurrentTime() / channel.currentDuration\r\n      );\r\n    }, 100);\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}