{"ast":null,"code":"import store from \"./../../../../../store\";\nimport { recording, recordingRquestFail, recordFinalUpdate } from \"./../../../../../actions\";\nimport STATUS from \"./../observer/STATUS\";\nimport io from \"socket.io-client\";\nconst recorder_api_url = process.env.REACT_APP_RECORDER_API;\nexport default class Recorder {\n  constructor(mixer) {\n    this.mixer = mixer;\n    const streamDestination = this.mixer.audioNodes.channels['main'].recorderStremDestination;\n    this.mediaRecorder = new MediaRecorder(streamDestination.stream, {\n      mimeType: 'audio/webm;codecs=opus'\n    });\n    console.log(recorder_api_url);\n    this.currentRec = Recorder.initRecState();\n  }\n\n  action(status, param) {\n    switch (status) {\n      case STATUS.RECORD_START:\n        {\n          this.startRecording(param);\n          break;\n        }\n\n      case STATUS.RECORD_END:\n        {\n          this.endRecording();\n          break;\n        }\n    }\n  }\n\n  startRecording({\n    recId,\n    recName\n  }) {\n    console.log(\"im start recording\", recId, recName);\n    const token = store.getState().user.token;\n\n    if (!token) {\n      return;\n    }\n\n    const socket = io.connect(recorder_api_url.replace('http', 'ws').replace('https', 'wss'));\n    socket.on(\"connect\", () => {\n      console.log(\"we have connection\");\n      socket.emit('authentication', {\n        token: token\n      });\n      socket.on('authenticated', () => {\n        console.log('auth');\n        socket.emit(\"record_details\", {\n          recId,\n          recName\n        });\n      });\n      socket.on('recorder_ready', () => {\n        this.currentRec.id = recId;\n        this.currentRec.title = recName;\n\n        this.mediaRecorder.ondataavailable = e => {\n          console.log(e.data);\n          socket.emit('record_chunk', e.data);\n        };\n\n        this.mediaRecorder.addEventListener('stop', () => {\n          socket.close();\n        });\n        this.mediaRecorder.start(1000);\n        this.currentRec.duration = new Date().getTime();\n        this.updateInterval = setInterval(this._updatePeaks.bind(this), 1000);\n        store.dispatch(recording());\n      });\n      socket.on('connect_error', () => {\n        store.dispatch(recordingRquestFail());\n      });\n    });\n  }\n\n  endRecording() {\n    console.log(\"im finish recoriding\");\n\n    if (this.mediaRecorder.state !== 'inactive') {\n      this.mediaRecorder.stop();\n      clearInterval(this.updateInterval);\n      this.currentRec.duration = new Date().getTime() - this.currentRec.duration; //    this._normalizePeaks();\n\n      const {\n        id,\n        duration,\n        peaks\n      } = this.currentRec;\n      store.dispatch(recordFinalUpdate(id, peaks, duration));\n      this.currentRec = Recorder.initRecState();\n    }\n  }\n\n  _updatePeaks() {\n    const len = this.currentRec.peaks.length;\n    this.currentRec.peaks[len] = this.mixer.currentPeakMinMax[0];\n    this.currentRec.peaks[len + 1] = this.mixer.currentPeakMinMax[1]; //this.currentRec.peaks.push(this.mixer.currentPeakMinMax)\n  } //simple interpolation \n\n\n  _normalizePeaks() {\n    const outputSize = 1000; // max amoutn of peaks\n\n    if (this.currentRec.peaks.length > outputSize) {\n      this.currentRec.peaks = this._interpolate(this.currentRec.peaks, outputSize);\n    }\n  }\n\n  _interpolate(input, outputSize) {\n    const inputSize = input.length;\n    const output = [];\n    const ratio = inputSize / outputSize;\n    const range = Math.ceil(ratio) * 2;\n\n    for (let i = 0; i < outputSize; i++) {\n      const from = Math.max(i - range / 2, 0);\n      const to = Math.min(i + range / 2, outputSize - 1);\n      let sum = 0;\n\n      for (let j = from; j <= to; j++) {\n        sum += input[j];\n      }\n\n      output[i] = sum / (to - from);\n    }\n  }\n\n}\n\nRecorder.initRecState = () => ({\n  id: null,\n  title: \"\",\n  peaks: [],\n  duration: 0\n});","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/src/pages/console/core/console/mixer/recorder.js"],"names":["store","recording","recordingRquestFail","recordFinalUpdate","STATUS","io","recorder_api_url","process","env","REACT_APP_RECORDER_API","Recorder","constructor","mixer","streamDestination","audioNodes","channels","recorderStremDestination","mediaRecorder","MediaRecorder","stream","mimeType","console","log","currentRec","initRecState","action","status","param","RECORD_START","startRecording","RECORD_END","endRecording","recId","recName","token","getState","user","socket","connect","replace","on","emit","id","title","ondataavailable","e","data","addEventListener","close","start","duration","Date","getTime","updateInterval","setInterval","_updatePeaks","bind","dispatch","state","stop","clearInterval","peaks","len","length","currentPeakMinMax","_normalizePeaks","outputSize","_interpolate","input","inputSize","output","ratio","range","Math","ceil","i","from","max","to","min","sum","j"],"mappings":"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","sourcesContent":["import store from \"./../../../../../store\";\r\nimport { recording, recordingRquestFail, recordFinalUpdate } from \"./../../../../../actions\"\r\nimport STATUS from \"./../observer/STATUS\";\r\nimport io from \"socket.io-client\";\r\nconst recorder_api_url = process.env.REACT_APP_RECORDER_API\r\n\r\n\r\nexport default class Recorder {\r\n    static initRecState = () => ({\r\n            id : null,\r\n            title :\"\",\r\n            peaks : [],\r\n            duration : 0,\r\n    })\r\n\r\n    constructor(mixer) {\r\n        this.mixer = mixer;\r\n\r\n        const streamDestination = this.mixer.audioNodes.channels['main'].recorderStremDestination;\r\n        this.mediaRecorder = new MediaRecorder(streamDestination.stream, {\r\n            mimeType: 'audio/webm;codecs=opus',\r\n        });\r\n\r\n        console.log(recorder_api_url)\r\n        this.currentRec = Recorder.initRecState();\r\n    }\r\n\r\n\r\n\r\n    action(status, param) {\r\n        switch (status) {\r\n            case STATUS.RECORD_START: {\r\n                this.startRecording(param);\r\n                break;\r\n            }\r\n            case STATUS.RECORD_END: {\r\n                this.endRecording()\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    startRecording({recId, recName}) {\r\n        console.log(\"im start recording\", recId, recName);\r\n        const token = store.getState().user.token;\r\n        if (!token) {\r\n            return;\r\n        }\r\n\r\n\r\n\r\n        const socket = io.connect(\r\n            recorder_api_url.replace('http', 'ws').replace('https', 'wss'));\r\n\r\n        socket.on(\"connect\", () => {\r\n            console.log(\"we have connection\")\r\n            socket.emit('authentication', { token: token });\r\n            socket.on('authenticated', () => {\r\n                console.log('auth')\r\n                socket.emit(\"record_details\", { recId, recName })\r\n            })\r\n            socket.on('recorder_ready', () => {\r\n                this.currentRec.id = recId;\r\n                this.currentRec.title = recName;\r\n\r\n                this.mediaRecorder.ondataavailable = (e) => {\r\n                    console.log(e.data)\r\n                    socket.emit('record_chunk', e.data)\r\n                }\r\n\r\n                this.mediaRecorder.addEventListener('stop', () => {\r\n                    socket.close()\r\n                })\r\n\r\n                this.mediaRecorder.start(1000);\r\n      \r\n                this.currentRec.duration = new Date().getTime();\r\n\r\n                this.updateInterval = setInterval(this._updatePeaks.bind(this), 1000);\r\n\r\n                store.dispatch(recording());\r\n            })\r\n\r\n            socket.on('connect_error', () => {\r\n                store.dispatch(recordingRquestFail())\r\n            })\r\n        })\r\n    }\r\n\r\n    endRecording() {\r\n        console.log(\"im finish recoriding\")\r\n        if (this.mediaRecorder.state !== 'inactive') {\r\n            this.mediaRecorder.stop();\r\n            clearInterval(this.updateInterval);\r\n\r\n            this.currentRec.duration =new Date().getTime() - this.currentRec.duration;\r\n        //    this._normalizePeaks();\r\n\r\n            const {id, duration, peaks} = this.currentRec;\r\n            store.dispatch(recordFinalUpdate(\r\n                id, peaks, duration\r\n            ))\r\n\r\n            this.currentRec = Recorder.initRecState();\r\n        }\r\n    }\r\n\r\n    _updatePeaks(){\r\n        const len = this.currentRec.peaks.length;\r\n        this.currentRec.peaks[len] = this.mixer.currentPeakMinMax[0];\r\n        this.currentRec.peaks[len + 1] = this.mixer.currentPeakMinMax[1];\r\n        //this.currentRec.peaks.push(this.mixer.currentPeakMinMax)\r\n    }\r\n\r\n    //simple interpolation \r\n    _normalizePeaks(){\r\n        const outputSize = 1000 // max amoutn of peaks\r\n        \r\n        if(this.currentRec.peaks.length > outputSize){\r\n            this.currentRec.peaks = this._interpolate(this.currentRec.peaks , outputSize)\r\n        }\r\n    }\r\n\r\n    _interpolate(input, outputSize){\r\n        const inputSize = input.length;\r\n        const output = [];\r\n        const ratio = inputSize/outputSize;\r\n        const range = Math.ceil(ratio) * 2;\r\n        for(let i = 0 ; i < outputSize; i++){\r\n            const from = Math.max(i - range/2, 0);\r\n            const to = Math.min(i + range/2, outputSize - 1)\r\n\r\n            let sum = 0;\r\n            for(let j = from; j <= to; j++){\r\n                sum += input[j]\r\n            }\r\n            output[i] = sum / (to - from);\r\n        }\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}