{"ast":null,"code":"import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport var createDecodeAudioData = function createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, detachedArrayBuffers, getNativeContext, isNativeContext, isNativeOfflineAudioContext, nativeOfflineAudioContextConstructor, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) {\n  return function (anyContext, audioData) {\n    var nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext); // Bug #43: Only Chrome and Opera do throw a DataCloneError.\n\n    if (detachedArrayBuffers.has(audioData)) {\n      var err = createDataCloneError();\n      return Promise.reject(err);\n    } // The audioData parameter maybe of a type which can't be added to a WeakSet.\n\n\n    try {\n      detachedArrayBuffers.add(audioData);\n    } catch (_unused) {} // Ignore errors.\n    // Bug #21: Safari does not support promises yet.\n\n\n    if (cacheTestResult(testPromiseSupport, function () {\n      return testPromiseSupport(nativeContext);\n    })) {\n      // Bug #101: Edge does not decode something on a closed OfflineAudioContext.\n      var nativeContextOrBackupNativeContext = nativeContext.state === 'closed' && nativeOfflineAudioContextConstructor !== null && isNativeOfflineAudioContext(nativeContext) ? new nativeOfflineAudioContextConstructor(1, 1, nativeContext.sampleRate) : nativeContext;\n      var promise = nativeContextOrBackupNativeContext.decodeAudioData(audioData).catch(function (err) {\n        // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.\n        if (err instanceof DOMException && err.name === 'NotSupportedError') {\n          throw new TypeError();\n        }\n\n        throw err;\n      });\n      return promise.then(function (audioBuffer) {\n        // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n        if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, function () {\n          return testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer);\n        })) {\n          wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n        }\n\n        audioBufferStore.add(audioBuffer);\n        return audioBuffer;\n      });\n    } // Bug #21: Safari does not return a Promise yet.\n\n\n    return new Promise(function (resolve, reject) {\n      var complete = function complete() {\n        // Bug #133: Safari does neuter the ArrayBuffer.\n        try {\n          detachArrayBuffer(audioData);\n        } catch (_unused2) {\n          /* Ignore errors. */\n        }\n      };\n\n      var fail = function fail(err) {\n        reject(err);\n        complete();\n      }; // Bug #26: Safari throws a synchronous error.\n\n\n      try {\n        // Bug #1: Safari requires a successCallback.\n        nativeContext.decodeAudioData(audioData, function (audioBuffer) {\n          // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n          // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n          if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n          }\n\n          audioBufferStore.add(audioBuffer);\n          complete();\n          resolve(audioBuffer);\n        }, function (err) {\n          // Bug #4: Safari returns null instead of an error.\n          if (err === null) {\n            fail(createEncodingError());\n          } else {\n            fail(err);\n          }\n        });\n      } catch (err) {\n        fail(err);\n      }\n    });\n  };\n};","map":{"version":3,"sources":["D:/PROJEKTY/APKI/dj-truck/node_modules/standardized-audio-context/build/es2019/factories/decode-audio-data.js"],"names":["detachArrayBuffer","wrapAudioBufferGetChannelDataMethod","createDecodeAudioData","audioBufferStore","cacheTestResult","createDataCloneError","createEncodingError","detachedArrayBuffers","getNativeContext","isNativeContext","isNativeOfflineAudioContext","nativeOfflineAudioContextConstructor","testAudioBufferCopyChannelMethodsOutOfBoundsSupport","testPromiseSupport","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","anyContext","audioData","nativeContext","has","err","Promise","reject","add","nativeContextOrBackupNativeContext","state","sampleRate","promise","decodeAudioData","catch","DOMException","name","TypeError","then","audioBuffer","resolve","complete","fail","copyFromChannel"],"mappings":"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","sourcesContent":["import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createDecodeAudioData = (audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, detachedArrayBuffers, getNativeContext, isNativeContext, isNativeOfflineAudioContext, nativeOfflineAudioContextConstructor, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    return (anyContext, audioData) => {\n        const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n        // Bug #43: Only Chrome and Opera do throw a DataCloneError.\n        if (detachedArrayBuffers.has(audioData)) {\n            const err = createDataCloneError();\n            return Promise.reject(err);\n        }\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n            detachedArrayBuffers.add(audioData);\n        }\n        catch {\n            // Ignore errors.\n        }\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n            // Bug #101: Edge does not decode something on a closed OfflineAudioContext.\n            const nativeContextOrBackupNativeContext = (nativeContext.state === 'closed' &&\n                nativeOfflineAudioContextConstructor !== null &&\n                isNativeOfflineAudioContext(nativeContext)) ?\n                new nativeOfflineAudioContextConstructor(1, 1, nativeContext.sampleRate) :\n                nativeContext;\n            const promise = nativeContextOrBackupNativeContext\n                .decodeAudioData(audioData)\n                .catch((err) => {\n                // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.\n                if (err instanceof DOMException && err.name === 'NotSupportedError') {\n                    throw new TypeError();\n                }\n                throw err;\n            });\n            return promise\n                .then((audioBuffer) => {\n                // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n                if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n                audioBufferStore.add(audioBuffer);\n                return audioBuffer;\n            });\n        }\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise((resolve, reject) => {\n            const complete = () => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                try {\n                    detachArrayBuffer(audioData);\n                }\n                catch { /* Ignore errors. */ }\n            };\n            const fail = (err) => {\n                reject(err);\n                complete();\n            };\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                // Bug #1: Safari requires a successCallback.\n                nativeContext.decodeAudioData(audioData, (audioBuffer) => {\n                    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                    // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                    if (typeof audioBuffer.copyFromChannel !== 'function') {\n                        wrapAudioBufferCopyChannelMethods(audioBuffer);\n                        wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                    }\n                    audioBufferStore.add(audioBuffer);\n                    complete();\n                    resolve(audioBuffer);\n                }, (err) => {\n                    // Bug #4: Safari returns null instead of an error.\n                    if (err === null) {\n                        fail(createEncodingError());\n                    }\n                    else {\n                        fail(err);\n                    }\n                });\n            }\n            catch (err) {\n                fail(err);\n            }\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/decode-audio-data.js.map"]},"metadata":{},"sourceType":"module"}