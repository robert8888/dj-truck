{"ast":null,"code":"import store from \"./../../../../../store\";\nimport { setAvailableEffects } from \"./../../../../../actions\";\nimport { equalPower } from \"./../../../../../utils/sound/converter\"; //import { throttel } from \"./../../../../../utils/functions/lodash\";\n\nimport Reverb from \"./effects/reverb/reverb\";\nimport Delay from \"./effects/delay/delay\";\nimport Flanger from \"./effects/flanger/flanger\";\nimport DubDelay from \"./effects/dubDelay/dubDelay\";\nimport PingPongDelay from \"./effects/PingPongDelay/PingPongDelay\";\nexport default class Effector {\n  constructor(audioContext) {\n    this.config = store.getState().configuration.effector;\n    this.mainAC = audioContext;\n    this.buildChannels(this.config.channels);\n    this.effects = {\n      \"Reverb\": {\n        create: Reverb,\n        params: Reverb.defaultParams().params\n      },\n      \"Flanger\": {\n        create: Flanger,\n        params: Flanger.defaultParams().params\n      },\n      \"Delay\": {\n        create: Delay,\n        params: Delay.defaultParams().params\n      },\n      \"Dub Delay\": {\n        create: DubDelay,\n        params: DubDelay.defaultParams().params\n      },\n      \"Ping Pong Delay\": {\n        create: PingPongDelay,\n        params: PingPongDelay.defaultParams().params\n      }\n    };\n    const exportEffects = {};\n    Object.entries(this.effects).forEach(([key, element]) => exportEffects[key] = element.params);\n    store.dispatch(setAvailableEffects(exportEffects));\n  }\n\n  buildChannels(channelNumber) {\n    this.channels = Array.from({\n      length: channelNumber\n    }, (_, index) => ({\n      channelNumber: index\n    }));\n\n    for (let chNum = 0; chNum < channelNumber; chNum++) {\n      const channel = this.channels[chNum];\n      channel.inputNode = this.mainAC.createGain();\n      channel.dryNode = this.mainAC.createGain();\n      ;\n      channel.wetNode = this.mainAC.createGain();\n      channel.outputNode = this.mainAC.createGain();\n      channel.inputNode.connect(channel.dryNode);\n      channel.dryNode.connect(channel.outputNode);\n      channel.wetNode.connect(channel.outputNode);\n      channel.wetNode.gain.value = 0;\n    }\n  }\n\n  connect(inputs) {\n    const outputs = [];\n    inputs.forEach((inputNode, chNum) => {\n      inputNode.connect(this.channels[chNum].inputNode);\n      const output = this.mainAC.createGain();\n      this.channels[chNum].outputNode.connect(output);\n      outputs.push(output);\n    });\n    return outputs;\n  }\n\n  setDryWet(channelNumber, value) {\n    channelNumber--;\n    const channel = this.channels[channelNumber];\n    let dry = (100 - value) / 100;\n    let wet = value / 100;\n    channel.dryNode.gain.setTargetAtTime(dry, this.mainAC.currentTime, 0.01);\n    channel.wetNode.gain.setTargetAtTime(wet, this.mainAC.currentTime, 0.01);\n  }\n\n  setEffect(channelNumber, effectName) {\n    channelNumber--; //array index\n\n    const channel = this.channels[channelNumber];\n\n    if (effectName) {\n      this.disconectCurrent(channel);\n      let params = this.assingDefaultParams({}, effectName);\n      const effectorChannel = store.getState().effector.channels;\n\n      if (effectorChannel && effectorChannel[channelNumber]) {\n        params = { ...effectorChannel[channelNumber].effects[effectName]\n        };\n      }\n\n      const effect = new this.effects[effectName].create(this.mainAC, params);\n      channel.currentEffect = effect;\n      effect.connect(channel.inputNode, channel.wetNode);\n    } else {\n      this.disconectCurrent(channel);\n    }\n  }\n\n  assingDefaultParams(obj, effect) {\n    Object.entries(this.effects[effect].params).forEach(([key, value]) => {\n      obj[key] = value.defaultValue;\n    });\n    return obj;\n  }\n\n  setParam(channelNumber, effect, param) {\n    channelNumber--;\n    const channel = this.channels[channelNumber];\n\n    if (channel.currentEffect && channel.currentEffect.name === effect) {\n      Object.entries(param).forEach(([key, value]) => {\n        channel.currentEffect[key] = value;\n      });\n    }\n  }\n\n  disconectCurrent(channel) {\n    if (channel.currentEffect) {\n      channel.inputNode.disconnect();\n      channel.inputNode.connect(channel.dryNode);\n      channel.currentEffect.disconnect();\n      channel.currentEffect = null;\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/PROJEKTY/APKI/DjTruck/djtruck/src/pages/app/core/console/effector/effector.js"],"names":["store","setAvailableEffects","equalPower","Reverb","Delay","Flanger","DubDelay","PingPongDelay","Effector","constructor","audioContext","config","getState","configuration","effector","mainAC","buildChannels","channels","effects","create","params","defaultParams","exportEffects","Object","entries","forEach","key","element","dispatch","channelNumber","Array","from","length","_","index","chNum","channel","inputNode","createGain","dryNode","wetNode","outputNode","connect","gain","value","inputs","outputs","output","push","setDryWet","dry","wet","setTargetAtTime","currentTime","setEffect","effectName","disconectCurrent","assingDefaultParams","effectorChannel","effect","currentEffect","obj","defaultValue","setParam","param","name","disconnect"],"mappings":"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","sourcesContent":["\r\nimport store from \"./../../../../../store\";\r\nimport { setAvailableEffects } from \"./../../../../../actions\";\r\nimport { equalPower } from \"./../../../../../utils/sound/converter\"\r\n//import { throttel } from \"./../../../../../utils/functions/lodash\";\r\nimport Reverb from \"./effects/reverb/reverb\";\r\nimport Delay from \"./effects/delay/delay\";\r\nimport Flanger from \"./effects/flanger/flanger\";\r\nimport DubDelay from \"./effects/dubDelay/dubDelay\";\r\nimport PingPongDelay from \"./effects/PingPongDelay/PingPongDelay\";\r\n\r\n\r\n\r\nexport default class Effector {\r\n    constructor(audioContext) {\r\n        this.config = store.getState().configuration.effector;\r\n        this.mainAC = audioContext;\r\n\r\n        this.buildChannels(this.config.channels);\r\n\r\n\r\n        this.effects = {\r\n            \"Reverb\": {\r\n                create: Reverb,\r\n                params: Reverb.defaultParams().params,\r\n            },\r\n            \"Flanger\": {\r\n                create: Flanger,\r\n                params: Flanger.defaultParams().params\r\n            },\r\n            \"Delay\": {\r\n                create: Delay,\r\n                params: Delay.defaultParams().params\r\n            },\r\n            \"Dub Delay\": {\r\n                create: DubDelay,\r\n                params: DubDelay.defaultParams().params,\r\n            },\r\n            \"Ping Pong Delay\": {\r\n                create: PingPongDelay,\r\n                params: PingPongDelay.defaultParams().params,\r\n            }\r\n\r\n\r\n        }\r\n\r\n        const exportEffects = {};\r\n        Object.entries(this.effects).forEach(([key, element]) =>\r\n            exportEffects[key] = element.params\r\n        );\r\n        store.dispatch(setAvailableEffects(exportEffects));\r\n    }\r\n\r\n    buildChannels(channelNumber) {\r\n        this.channels =\r\n            Array.from({ length: channelNumber }, (_, index) => ({ channelNumber: index }));\r\n\r\n        for (let chNum = 0; chNum < channelNumber; chNum++) {\r\n            const channel = this.channels[chNum];\r\n\r\n            channel.inputNode = this.mainAC.createGain();\r\n            channel.dryNode = this.mainAC.createGain();;\r\n            channel.wetNode = this.mainAC.createGain();\r\n            channel.outputNode = this.mainAC.createGain();\r\n\r\n            channel.inputNode.connect(channel.dryNode);\r\n            channel.dryNode.connect(channel.outputNode);\r\n\r\n            channel.wetNode.connect(channel.outputNode);\r\n            channel.wetNode.gain.value = 0;\r\n        }\r\n    }\r\n\r\n    connect(inputs) {\r\n        const outputs = [];\r\n\r\n        inputs.forEach((inputNode, chNum) => {\r\n            inputNode.connect(this.channels[chNum].inputNode);\r\n\r\n            const output = this.mainAC.createGain();\r\n            this.channels[chNum].outputNode.connect(output);\r\n            outputs.push(output)\r\n        });\r\n\r\n        return outputs;\r\n    }\r\n\r\n\r\n    setDryWet(channelNumber, value) {\r\n        channelNumber--;\r\n        const channel = this.channels[channelNumber];\r\n\r\n        let dry = (100 - value) / 100;\r\n        let wet = value / 100;\r\n\r\n        channel.dryNode.gain.setTargetAtTime(dry, this.mainAC.currentTime, 0.01);\r\n        channel.wetNode.gain.setTargetAtTime(wet, this.mainAC.currentTime, 0.01);\r\n    }\r\n\r\n    setEffect(channelNumber, effectName) {\r\n        channelNumber--;//array index\r\n        const channel = this.channels[channelNumber];\r\n\r\n        if (effectName) {\r\n            this.disconectCurrent(channel);\r\n\r\n            let params = this.assingDefaultParams({}, effectName);\r\n            const effectorChannel = store.getState().effector.channels;\r\n            if (effectorChannel && effectorChannel[channelNumber]) {\r\n                params = { ...effectorChannel[channelNumber].effects[effectName] }\r\n            }\r\n\r\n            const effect = new this.effects[effectName].create(this.mainAC, params);\r\n            channel.currentEffect = effect;\r\n\r\n            effect.connect(channel.inputNode, channel.wetNode)\r\n\r\n        } else {\r\n            this.disconectCurrent(channel);\r\n        }\r\n\r\n    }\r\n\r\n    assingDefaultParams(obj, effect) {\r\n        Object.entries(this.effects[effect].params).forEach(([key, value]) => {\r\n            obj[key] = value.defaultValue;\r\n        })\r\n        return obj;\r\n    }\r\n\r\n    setParam(channelNumber, effect, param) {\r\n        channelNumber--;\r\n        const channel = this.channels[channelNumber];\r\n\r\n        if (channel.currentEffect && channel.currentEffect.name === effect) {\r\n            Object.entries(param).forEach(([key, value]) => {\r\n                channel.currentEffect[key] = value;\r\n            })\r\n        }\r\n    }\r\n\r\n\r\n    disconectCurrent(channel) {\r\n        if (channel.currentEffect) {\r\n            channel.inputNode.disconnect();\r\n            channel.inputNode.connect(channel.dryNode);\r\n            channel.currentEffect.disconnect();\r\n            channel.currentEffect = null;\r\n        }\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}